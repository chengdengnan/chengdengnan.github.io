(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d215c7e"],{c050:function(e,o,t){"use strict";t.r(o);var c=t("7a23");const l={id:"ReferenceInformation"},n={class:"overview"},d=Object(c["createElementVNode"])("span",null,"1.",-1),r=Object(c["createElementVNode"])("span",null,"2.",-1),a=Object(c["createElementVNode"])("span",null,"3.",-1),i=Object(c["createElementVNode"])("span",null,"4.",-1),s=Object(c["createElementVNode"])("span",null,"5.",-1),u=Object(c["createElementVNode"])("span",null,"6.",-1),m=Object(c["createElementVNode"])("span",null,"7.",-1),j=Object(c["createElementVNode"])("span",null,"8.",-1),b=Object(c["createElementVNode"])("span",null,"9.",-1),V=Object(c["createElementVNode"])("span",null,"10.",-1);var O=Object(c["defineComponent"])({__name:"promiseReference",setup(e){const o=Object(c["ref"])("http://liubin.org/promises-book/"),t=Object(c["ref"])("https://juejin.cn/post/6844903455962693640"),O=Object(c["ref"])("https://juejin.cn/post/6844903667494027278"),N=Object(c["ref"])("https://juejin.cn/post/6844903550288412679"),p=Object(c["ref"])("https://mp.weixin.qq.com/s/Yrwe2x6HukfqJZM6HkmRcw"),v=Object(c["ref"])("https://zhuanlan.zhihu.com/p/144058361"),f=Object(c["ref"])("https://blog.csdn.net/weixin_56650035/article/details/121070438?spm=1001.2014.3001.5502"),h=Object(c["ref"])("https://promisesaplus.com/"),E=Object(c["ref"])("https://mp.weixin.qq.com/s/Yrwe2x6HukfqJZM6HkmRcw"),P=Object(c["ref"])("https://www.cnblogs.com/sugar-tomato/p/11353546.html");return(e,x)=>{const w=Object(c["resolveComponent"])("RouterLink"),T=Object(c["resolveComponent"])("NavigationBlank");return Object(c["openBlock"])(),Object(c["createElementBlock"])(c["Fragment"],null,[Object(c["createElementVNode"])("h3",l,[Object(c["createVNode"])(w,{to:"#ReferenceInformation",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、参考资料 ")]),Object(c["createElementVNode"])("div",n,[Object(c["createElementVNode"])("div",null,[d,Object(c["createVNode"])(T,{modelValue:o.value,"onUpdate:modelValue":x[0]||(x[0]=e=>o.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])(" JavaScript Promise迷你书(中文版) ")]),_:1},8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[r,Object(c["createVNode"])(T,{modelValue:t.value,"onUpdate:modelValue":x[1]||(x[1]=e=>t.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])(" 深入理解Promise(上) ")]),_:1},8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[a,Object(c["createVNode"])(T,{modelValue:O.value,"onUpdate:modelValue":x[2]||(x[2]=e=>O.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])(" 从手写一个符合Promise/A+规范Promise来深入学习Promise ")]),_:1},8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[i,Object(c["createVNode"])(T,{modelValue:N.value,"onUpdate:modelValue":x[3]||(x[3]=e=>N.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])(" Promise深度学习---我のPromise/A+实现 ")]),_:1},8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[s,Object(c["createVNode"])(T,{modelValue:p.value,"onUpdate:modelValue":x[4]||(x[4]=e=>p.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])(" 【第1738期】100行代码实现 Promises/A+ 规范 ")]),_:1},8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[u,Object(c["createVNode"])(T,{modelValue:v.value,"onUpdate:modelValue":x[5]||(x[5]=e=>v.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])(" 从零开始手写Promise ")]),_:1},8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[m,Object(c["createVNode"])(T,{modelValue:f.value,"onUpdate:modelValue":x[6]||(x[6]=e=>f.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])(" PromiseA+规范之手写Promise ")]),_:1},8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[j,Object(c["createVNode"])(T,{modelValue:h.value,"onUpdate:modelValue":x[7]||(x[7]=e=>h.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])(" promise A plus规范 ")]),_:1},8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[b,Object(c["createVNode"])(T,{modelValue:E.value,"onUpdate:modelValue":x[8]||(x[8]=e=>E.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])(" 【第1738期】100 行代码实现 Promises/A+ 规范 ")]),_:1},8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[V,Object(c["createVNode"])(T,{modelValue:P.value,"onUpdate:modelValue":x[9]||(x[9]=e=>P.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])(" 史上最最最详细的手写Promise教程 ")]),_:1},8,["modelValue"])])])],64)}}});const N=O;var p=N;const v={id:"PromiseStandard"},f={id:"PromiseTerm"},h=Object(c["createStaticVNode"])("<section><div><ul><li><code>Promise</code>是一个具有<code>then</code>方法的对象或者函数，行为遵守本规范 </li><li><code>thenable</code>是一个具有<code>then</code>方法的对象或者是函数 </li><li><code>value</code>是<code>promise</code>状态成功时的值，也就是<code>resolve</code>的参数， 指各种<code>js</code>值，包括：<code>undefined、thenable、promise</code></li><li><code>reason</code>是<code>promise</code>状态失败时的值，也就是<code>reject</code> 的参数，表示拒绝的原因 </li><li><code>exception</code>是一个使用<code>throw</code>抛出的异常值 </li></ul></div></section>",1),E={id:"PromiseStates"},P=Object(c["createStaticVNode"])('<section><p><code>promise</code>有三种状态，注意它们之间的流转关系 </p><div><p class="c-h6">1. pending</p><div><ul><li>初始状态，可以改变</li><li> 一个<code>promise</code>在<code>resolve</code>或者<code>reject</code>之前都处于这个状态 </li><li> 可通过<code>resolve</code>转变为<code>fulfilled</code>状态 </li><li>可通过<code>reject</code>转变为<code>rejected</code></li></ul></div></div><div><p class="c-h6">2. fulfilled</p><div><ul><li> 最终态，不可变 </li><li> 一个<code>promise</code>被<code>resolve</code>后会变为这个状态 </li><li> 必须拥有一个<code>value</code>值 </li></ul></div></div><div><p class="c-h6">3. rejected</p><div><ul><li> 最终态，不可变 </li><li> 一个<code>promise</code>被<code>reject</code>后会变为这个状态 </li><li> 必须拥有一个<code>reason</code></li></ul></div></div><p class="c-h6">状态流转如下：</p><div class="indent"><p><code>pending</code> -&gt; <code>resolve(value)</code> -&gt; <code>fulfilled</code></p><p><code>pending</code> -&gt; <code>reject(reason)</code> -&gt; <code>rejected</code></p></div></section>',1),x={id:"PromiseThen"},w=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"promise"),Object(c["createTextVNode"])("应该有个"),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("方法，用来访问最终的结果，无论是 "),Object(c["createElementVNode"])("code",null,"value"),Object(c["createTextVNode"])("还是"),Object(c["createElementVNode"])("code",null,"reason")],-1),T=Object(c["createStaticVNode"])('<div><p class="c-h6">1. 参数要求</p><section><ul><li><code>onFulfilled</code>必须是函数类型，可选，如果不是函数，应该被忽略 </li><li><code>onRejected</code>必须是函数类型，可选，如果不是函数，应该被忽略 </li></ul><p><span class="red">注意：</span>这里的忽略是指给一个默认值,并不是真正意义上的忽略</p></section></div><div><p class="c-h6">2. onFulfilled特性</p><section><ul><li> 在<code>promise</code>变为<code>fulfilled</code>时，应该调用<code>onFulfilled</code> ，参数是<code>value</code></li><li> 在<code>promise</code>变成<code>fulfilled</code>之前，不应该被调用 </li><li> 只能被调用一次(实现时需使用变量来限制执行次数)， 可以注册若干个回调函数(<code>promise.then().then().then()....</code> ) </li></ul></section></div><div><p class="c-h6">3. onRejected特性</p><section><ul><li> 在<code>promise</code>变成<code>rejected</code>时，应该调用<code>onRejected</code> ，参数是<code>reason</code></li><li> 在<code>promise</code>变成<code>rejected</code>之前，不应该被调用 </li><li> 只能被调用一次 </li></ul></section></div><div><p class="c-h6">4. onFulfilled和onRejected应该是微任务</p><div><p class="indent"> 在执行上下文堆栈仅包含平台代码之前，不得调用<code>onFulfilled</code>或 <code>onRejected</code>函数，<code>onFulfilled</code>和<code>onRejected</code> 必须被作为普通函数调用(即非实例化调用，这样函数内部 <code>this</code>非严格模式下 指向<code>window</code> )，使用<code>queueMicrotask</code>或者 <code>setTimeout</code>来实现微任务的调用。 </p></div></div><div><p class="c-h6">5. then方法可以被调用多次</p><section><ul><li><code>promise</code>状态变成<code>fulfilled</code>状态后，所有的<code>onFulfilled</code> 回调都需要按照<code>then</code>的顺序执行，也就是按照注册顺序执行(实现时用数组存储多个 <code>onFulfilled</code>的回调 ) </li><li><code>promise</code>状态变成<code>rejected</code>后，所有的<code>onRejected</code> 回调都需要按照<code>then</code>的顺序执行，也就是按照注册顺序执行(实现时用数组存储多个 <code>onRejected</code>的回调 ) </li></ul></section></div>',5),g=Object(c["createElementVNode"])("p",{class:"c-h6"},"6. then必须返回一个promise",-1),y=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("必须返回一个"),Object(c["createElementVNode"])("code",null,"promise")],-1),R=Object(c["createStaticVNode"])("<div><ul><li><code>onFulfilled</code>或者<code>onRejected</code>执行的结果是 X， 调用<code>resolvePromise</code></li><li> 如果<code>onFulfilled</code>或者<code>onRejected</code>执行时抛出异常e， <code>promise2</code>需要被<code>reject</code>，其<code>reason</code>为e </li><li> 如果<code>onFulfilled</code>不是一个函数且<code>promise1</code>已经 <code>fulfilled</code>，<code>promise2</code>以<code>promise1</code> 的<code>value</code>触发<code>onFulfilled</code></li><li> 如果<code>onRejected</code>不是一个函数且<code>promise1</code>已经 <code>rejected</code>，<code>promise2</code>以<code>promise1</code> 的<code>reason</code>触发<code>onRejected</code></li></ul></div>",1),C=Object(c["createElementVNode"])("p",{class:"c-h6"},"7. Promise 的解决过程 resolvePromise",-1),S=Object(c["createStaticVNode"])('<ul><li> 如果<code>x</code>是当前<code>promise</code>本身(<code>promise2</code>和 <code>x</code>相等 )，那么<code>reject TypeError</code></li><li> 如果<code>x</code>是另一个<code>promise</code>(即<code>x</code>是一个<code>promise </code> )，那么沿用它的<code>state</code>和<code>result</code>状态。 <div><ul type="cricle"><li>如果<code>x</code>是<code>pending</code>状态，那么 <code>promise</code>必须要在<code>pending</code>，知道<code>x</code>变成 <code>fulfilled</code>或者<code>rejected</code></li><li> 如果<code>x</code>是<code>fulfilled</code>状态，用相同的<code>value</code> 执行<code>promise</code></li><li> 如果<code>x</code>是<code>rejected</code>状态，用相同的<code>reason</code> 拒绝<code>promise</code></li></ul></div></li><li> 如果<code>x</code>是一个<code>object</code>或者是一个<code>function</code>(不常见) <div><ul type="cricle"><li> 首先取<code>x.then</code>的值，<code>let then = x.then</code></li><li> 如果取<code>x.then</code>这步出错抛出<code>e</code>，那么以<code>e</code>为 <code>reason</code>拒绝<code>promise</code></li><li> 如果<code>then</code>是一个函数，将<code>x</code>作为函数的作用域<code>this</code> 调用，即<code>then.call(x, resolvePromise, rejectPromise)</code>,第一个参数 叫<code>resolvePromise</code>，第二个参数叫<code>rejectPromise</code><div><ul type="square"><li> 如果<code>resolvePromise</code>以<code>y</code>为参数被调用，则执行 <code>resolvePromise(promise2, y, resolve, reject)</code></li><li> 如果<code>rejectPromise</code>以<code>r</code>为参数被调用，则以<code>r</code> 为<code>reason</code>拒绝<code>promise</code></li><li> 如果<code>resolvePromise</code> 和<code>rejectPromise</code>都调用了，那么第一个调用 优先，后面的调用忽略 </li><li> 如果调用<code>then</code>抛出异常<code>e</code>：若<code>resolvePromise</code> 或<code>rejectPromise</code>已经被调用，那么忽略，否则以<code>e</code>为 <code>reason</code>拒绝<code>promise</code></li></ul></div></li><li> 如果<code>then</code>不是一个<code>function</code>，以<code>x</code>为<code>value</code> 执行<code>promise</code></li></ul></div></li><li> 如果<code>x</code>不是<code>object</code>或者<code>function</code>，以<code>x</code> 为<code>value</code>执行<code>promise</code></li></ul>',1);var F=Object(c["defineComponent"])({__name:"promiseStandard",setup(e){const o=Object(c["getCurrentInstance"])(),{$builtIn:t}=null===o||void 0===o?void 0:o.appContext.config.globalProperties,l=t("\npromise.then(onFulfilled, onRejected);\n"),n=t("\npromise2 = promise1.then(onFulfilled, onRejected)\n"),d=t("\nresolvePromise(promise2, x, resolve, reject)\n");return(e,o)=>{const t=Object(c["resolveComponent"])("RouterLink"),r=Object(c["resolveComponent"])("WebPrismEditor");return Object(c["openBlock"])(),Object(c["createElementBlock"])(c["Fragment"],null,[Object(c["createElementVNode"])("h3",v,[Object(c["createVNode"])(t,{to:"#PromiseStandard",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、PromiseA+ 规范 ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",f,[Object(c["createVNode"])(t,{to:"#PromiseTerm",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、Promise术语 ")]),h]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",E,[Object(c["createVNode"])(t,{to:"#PromiseStates",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、Promise状态 ")]),P]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",x,[Object(c["createVNode"])(t,{to:"#PromiseThen",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、Promise then 方法 ")]),Object(c["createElementVNode"])("section",null,[w,Object(c["createVNode"])(r,{modelValue:Object(c["unref"])(l),"onUpdate:modelValue":o[0]||(o[0]=e=>Object(c["isRef"])(l)?l.value=e:null)},null,8,["modelValue"]),T,Object(c["createElementVNode"])("div",null,[g,Object(c["createElementVNode"])("div",null,[y,Object(c["createVNode"])(r,{modelValue:Object(c["unref"])(n),"onUpdate:modelValue":o[1]||(o[1]=e=>Object(c["isRef"])(n)?n.value=e:null)},null,8,["modelValue"]),R])]),Object(c["createElementVNode"])("div",null,[C,Object(c["createElementVNode"])("div",null,[Object(c["createVNode"])(r,{modelValue:Object(c["unref"])(d),"onUpdate:modelValue":o[2]||(o[2]=e=>Object(c["isRef"])(d)?d.value=e:null)},null,8,["modelValue"]),S])])])])],64)}}});const U=F;var _=U;const k={id:"Promise"},A={id:"ConstructorStatus"},B=Object(c["createElementVNode"])("div",{class:"c-h5"},"1. 构造函数",-1),I=Object(c["createStaticVNode"])('<section><div class="c-h5">2. 状态</div><section><ul><li>初始状态 -&gt; pending <ul type="cricle" class="ml-15"><li>初始状态可以改变</li><li>在resolve 或者 reject 调用之前都处于这个状态</li></ul></li><li>最终成功状态 -&gt; fulfilled <ul type="cricle" class="ml-15"><li>执行 resolve 函数，状态改变为 fulfilled</li><li>执行 onFulfilled 函数</li></ul></li><li>最终失败状态 -&gt; rejected <ul type="cricle" class="ml-15"><li>执行 reject 函数，状态改变为 rejected</li><li>执行 onRejected 函数</li></ul></li><li>then 方法 <ul type="cricle" class="ml-15"><li>then 方法为 Promise 对象注册了 onFulfilled 和 onRejected 函数</li></ul></li><li>catch 方法 <ul type="cricle" class="ml-15"><li>catch 方法为Promise 对象注册了 onRejected 函数</li></ul></li></ul></section></section>',1),q={id:"NineMethods"},G=Object(c["createElementVNode"])("div",{class:"c-h5"}," 1. Promise.resolve",-1),z=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])("静态方法"),Object(c["createElementVNode"])("code",null,"Promise.resolve(value)"),Object(c["createTextVNode"])("可以认为是"),Object(c["createElementVNode"])("code",null,"new Promise"),Object(c["createTextVNode"])("方法的语法糖,比如"),Object(c["createElementVNode"])("code",null,"Promise.resolve(42)"),Object(c["createTextVNode"])(" 可以认为是以下代码的语法糖 ")],-1),D={class:"indent"},J=Object(c["createElementVNode"])("code",null,"Promise",-1),L=Object(c["createElementVNode"])("code",null,"onFulfilled",-1),M=Object(c["createElementVNode"])("code",null,"new Promise",-1),W=Object(c["createElementVNode"])("code",null,"Promise",-1),$=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])(" 简单总结一下 "),Object(c["createElementVNode"])("code",null,"Promise.resolve"),Object(c["createTextVNode"])("方法的话，它的作用就是将传递给它的参数填充 "),Object(c["createElementVNode"])("code",null,"Fulfilled"),Object(c["createTextVNode"])(" 到 "),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])(" 对象后并返回这个 "),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])(" 对象。 ")],-1),H=Object(c["createElementVNode"])("div",{class:"c-h5"},"2. Promise.reject",-1),Y=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createElementVNode"])("code",null,"Promise.reject(error)"),Object(c["createTextVNode"])("是和"),Object(c["createElementVNode"])("code",null,"Promise.resolve(value)"),Object(c["createTextVNode"])("类似的静态方法，是 "),Object(c["createElementVNode"])("code",null,"new Promise"),Object(c["createTextVNode"])(" 方法的快捷方式。比如 "),Object(c["createElementVNode"])("code",null,'Promise.reject(new Error("Promise reject error"))'),Object(c["createTextVNode"])(" 就是下面代码的语法糖形式 ")],-1),Z=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])(" 简单总结一下 "),Object(c["createElementVNode"])("code",null,"Promise.reject"),Object(c["createTextVNode"])("方法的话：它的功能是调用该 "),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象通过then指定的 "),Object(c["createElementVNode"])("code",null,"onRejected"),Object(c["createTextVNode"])("函数，并讲错误（Error）对象传递给这个"),Object(c["createElementVNode"])("code",null,"onRejected"),Object(c["createTextVNode"])("函数 ")],-1),X=Object(c["createElementVNode"])("div",{class:"c-h5"},"3. Promise.then",-1),K=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"Promise.then(onFulfilled, onRejected)")],-1),Q=Object(c["createElementVNode"])("div",{class:"c-h6"},"① 函调函数异步执行",-1),ee=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"Promise/A+规范"),Object(c["createTextVNode"])("统一规定：Promise 只能使用异步调用方式 ")],-1),oe=Object(c["createStaticVNode"])('<div class="c-h6">② 返回值</div><p class="indent">不管你在回调函数 <code>onFulfilled</code>中会返回一个什么样的值，或者不返回值，该值都会由 <code>Promis.resolve(return 的返回值)</code> 进行响应的包装处理。因此，最终 <code>then</code>的结果都是返回一个新创建的 <code>Promise</code>对象。 </p><p class="indent"> 也就是说，<code>Promis.then</code>不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个<code>Promise</code> 对象。正是 <code>then</code>函数中有了这样返回值的机制，才能使得在整个<code>Promise</code>链式结构当中，每个<code>then</code>方法都能给 下一个<code>then</code>方法传递参数。现在我们知道怎么返回的<code>Promise</code>是之前的还是新的？另外该<code>Promise</code>的状态又是如何？ </p>',3),te=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("从上面结果来看，实际上不管是调用 "),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("还是"),Object(c["createElementVNode"])("code",null,"catch"),Object(c["createTextVNode"])("方法， 都返回了一个新的"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象")],-1),ce=Object(c["createElementVNode"])("div",{class:"c-h6 red"},"③ promise穿透",-1),le=Object(c["createElementVNode"])("p",null,"我们先来举个例子：",-1),ne=Object(c["createElementVNode"])("p",null,"如果你认为输出的是【 Barry Promise 】，那么你就错了，实际上他输出的是 【 Barry 】",-1),de=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("产生这么的输出是因为你给"),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("方法传递了一个非函数(比如"),Object(c["createElementVNode"])("code",null,"promise"),Object(c["createTextVNode"])("对象)的值，代码会这样理解 : "),Object(c["createElementVNode"])("code",null,"then(null)"),Object(c["createTextVNode"])(",因此导致了前一个"),Object(c["createElementVNode"])("code",null,"promise"),Object(c["createTextVNode"])("的结果产生了坠落的效果，也就是和下面代码是一样的， 代码直接穿透了"),Object(c["createElementVNode"])("code",null,"then(null)"),Object(c["createTextVNode"])("进入了下一层链： ")],-1),re=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("随意添加多个"),Object(c["createElementVNode"])("code",null,"then(null)"),Object(c["createTextVNode"])("结果都是一样的")],-1),ae=Object(c["createElementVNode"])("div",{class:"c-h5"},"4. Promise.catch",-1),ie=Object(c["createElementVNode"])("div",{class:"c-h6"},"① 语法糖的本质",-1),se=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])(" 这里我们再说一遍，实际上"),Object(c["createElementVNode"])("code",null,"Promise.catch"),Object(c["createTextVNode"])("只是"),Object(c["createElementVNode"])("code",null,"promise.then(undefined, onRejected)"),Object(c["createTextVNode"])(" 方法的一个别名而已。也就是说，这个方法用来注册当"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象状态变为 "),Object(c["createElementVNode"])("code",null,"Rejected"),Object(c["createTextVNode"])("时 的回调函数。可以看下面代码，两者写法是等价的，但是很明显 "),Object(c["createElementVNode"])("code",null,"Promise.catch"),Object(c["createTextVNode"])("会让人第一眼看上去不会眼花缭乱: ")],-1),ue=Object(c["createStaticVNode"])("<p>那么我们现在来说说为什么推荐使用第二种方法，而不是第一种:</p><div><ul><li>使用<code>promise.then(onFulfilled, onRejected)</code> 的话，在<code>onFulfilled</code>中发生异常的话，<code>onRejected</code> 中是捕获不到这个异常的。而且如果链式很长，每一条链上都要这么写。 </li><li> 在<code>promise.then(onFulfilled).catch(onRejected)</code> 的情况下<code>.then</code>中产生异常能在<code>.catch</code> 中捕获。<code>.then</code>和<code>.catch</code>本质上是没有区别的， 需要分场合使用 </li></ul></div>",2),me=Object(c["createStaticVNode"])('<div class="c-h6">② 只有一个主人</div><p class="indent">我们上面已经说过了，在书写很长的<code>Promise</code>链式，从代码清晰度和简易程度来讲，在最后添加 <code>catch</code>是远远在每一层链上写<code>onRejected</code>回调函数是要好的，因为<code>catch</code>可以捕获 <code>Promise</code>链中每一层节点的错误，这句话本身没有错，但从这句话延伸出一种错误的理解：<code>catch</code> 同时监控着所有节点。实际上<code>catch</code>函数在同一个时间点只属于某一个<code>Promise</code>，因为它的主人是随着程序 的执行而不断变化的，我们来举个例子： </p>',2),je=Object(c["createStaticVNode"])("<p>在上述例子中，如果整个程序每一步都正确执行，那么会顺序产生三个<code>Promise</code>对象，分别是 <code>Promise(1)</code>,<code>Promise(2)</code>,<code>Promise(3)</code>: </p><ul><li>可是如果在第一层具体执行逻辑出错了后，那实际上后面的两个<code>then</code> 中的回调函数压根不会被异步执行，所以会直接异步触发<code>catch</code>中的回调函数执行， 所以这种情况下<code>catch</code>是<code>Promise(1)</code>对象的<code>catch</code>。 </li><li> 如果第一层具体执行逻辑正确执行，就会异步触发第二个<code>then</code>中的回调函数执行，那么同理 ，在第二次具体执行逻辑抛出错误，会导致<code>Promise(2)</code>的状态变化，所以这种情况下<code>catch</code> 是<code>Promise(2)</code>对象的<code>catch</code>。 </li><li>同理<code>Promise(3)</code>也是如此</li></ul><p>总结下来就是：整个<code>Promise</code>链中，<code>catch</code>只属于异步触发它当中回调函数 执行的那个<code>Promise</code>，并不属于所有 <code>Promise</code></p>",3),be=Object(c["createStaticVNode"])('<div class="c-h5">5. Promise.finally</div><p class="indent"><code>promise.finally</code>方法的回调函数不接受任何参数，这意味着<code>finally</code>没有办法 知道，前面的<code>Promise</code>状态到底是<code>fulfilled</code>还是<code>rejected</code> 。这表明，<code>finally</code>方法里面的操作，应该是与<code>Promise</code>状态无关的，不依赖于 <code>Promise</code>的执行结果。我们来看下面代码： </p>',2),Ve=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"finally"),Object(c["createTextVNode"])("本质上是"),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("方法的特例。我们来看下面伪代码：")],-1),Oe=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("上面代码中，如果不使用"),Object(c["createElementVNode"])("code",null,"finally"),Object(c["createTextVNode"])("方法，同样的语句需要为成功和失败的状态各写一次。 有了"),Object(c["createElementVNode"])("code",null,"finally"),Object(c["createTextVNode"])("方法，则只需要写一次。那么它是如何实现的呢？ ")],-1),Ne=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("上述代码中，不管前面的"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("是"),Object(c["createElementVNode"])("code",null,"fulfilled"),Object(c["createTextVNode"])("还是"),Object(c["createElementVNode"])("code",null,"rejected"),Object(c["createTextVNode"])(" ，都会执行回调函数"),Object(c["createElementVNode"])("code",null,"callback")],-1),pe=Object(c["createStaticVNode"])('<div class="c-h5">6. Promise.all</div><p class="indent"><code>Promise.all</code>接受一个<code>promise</code>对象的数组作为参数，当这个数组里的所有 <code>Promise</code> 对象 全部变为<code>resolve</code>或者<code>reject</code>状态的时候，它才会去调用<code>.then</code>方法。 </p><p class="indent"> 传递给<code>Promise.all</code>的 <code>promise</code>并不是一个个的顺序执行的，而是同时开始、并行执行的，我们可以看下面例子 </p>',3),ve=Object(c["createStaticVNode"])('<p>为什么这个例子可以看出来<code>Promise.all()</code>是并行的呢？因为所有<code>Promise</code>执行完只用了5秒，如果3个 <code>Promise</code>是按照顺序执行的，那么应该是9秒或者，在5-9之间，因为4个<code>Promise</code>并不是同时执行的，同时执行的 话总时间就是那个花费时间最长的<code>Promise</code></p><p><code>Promise.all()</code>重要细节点 <span class="red">（面试常考）</span>：</p><div><ul><li> 如果所有的<code>Promise</code>中只有一个执行错误，那么整个<code>Promise.all</code>不会走<code>Promise.all().then()</code> 而是走<code>Promise.all().catch()</code>这个流程了。但是要注意的是虽然走到了<code>Promise.all().catch()</code>这个流程 ，<span class="red">但是其他<code>Promise</code>还是会正常执行，但不会返回结果</span></li><li> 要注意<code>Promise.all()</code>的返回值顺序，<code>Promise.all().then()</code>的返回值顺序和传入的顺序是一致的，笔试时 遇到手写<code>Promise.all()</code>时要注意 </li></ul></div>',3),fe=Object(c["createStaticVNode"])('<div class="c-h5">7. Promise.allSettled</div><p><code>Promise.allSettled()</code>的入参和<code>Promise.all、Promise.race</code>一样，接受一个<code>promise</code> 对象的数组作为参数,也是同时开始、并行执行的。但是<code>Promise.allSettled</code>的返回值需要注意以下几点： </p><p><code>Promise.allSettled</code>不会走进catch，当所有输入<code>Promise</code>都被履行或者拒绝时，<code> statusesPromise </code>会解析一个具有具体完成状态的数组 </p><div><ul><li><code>{ status: &#39;fulfilled&#39;, value:value } </code>：如果相应的<code>promise</code>被履行</li><li><code>{ status: &#39;rejected&#39;, reason: reason }</code>：如果相应的<code>promise</code>被拒绝</li></ul></div><p>我们看下面示例:</p>',5),he=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("总结一下："),Object(c["createElementVNode"])("code",null,"Promise.allSettled()"),Object(c["createTextVNode"])("在你需要执行平行和独立的异步操作并收集所有结果时非常有效， 即使某些异步操作可能失败。")],-1),Ee=Object(c["createStaticVNode"])('<div class="c-h5">8. Promise.race</div><p class="indent"><code>Promise.rece()</code>的使用方法和 <code>Promise.all</code>一样，接收一个<code>promise</code> 对象的数组为参数，<code>Promise.race</code>是要有一个promise对象进入<code>Fulfilled</code>或者 <code>Rejected</code>状态的话，就会继续进行后面的处理。这里依旧有两个点要注意： </p><div><ul><li>和<code>Promise.all</code>一样是所有数组当中的<code>Promise</code>同时并行的</li><li><code>Promise.race</code> 在第一个<code>Promise</code>对象变为<code>Fulfilled</code>之后，并不会 取消其他<code>promise</code>对象的执行。</li><li><code>Promise.race</code>接受的是一个<code>Promise</code>对象数组，但是返回的确实最先完成<code>Fulfilled</code> 或者最先被<code>Rejected</code>的一个Promise的结果 </li></ul></div><p>下面我们来举个例子：</p>',4),Pe=Object(c["createStaticVNode"])("<p>这里我们再复习一下<code>Node</code>当中事件循环的知识：</p><div><ul><li>第一层循环：i为0时，异步触发了<code>Promise.race().catch()</code>，这里面的回调代码被放在了微任务队列中， 后面的3个<code>setTimeout</code>宏任务的回调函数代码被放进了<code>timer</code>阶段中的队列当中(其实并不是这样，因为 三个定时器都有延迟，都是在后面的事件循环中添加进来的) </li><li>第二层循环：清空微任务对列，所以控制台打印出了错误，然后清空宏任务，分别打印出<code>3000/5000/7000</code></li></ul></div>",2),xe=Object(c["createStaticVNode"])('<div class="c-h5">9. Promise.any</div><p><code>Promise.any</code>的入参和<code>Promise.all、Promise.race、Promise.allSettled</code>一样， 接收一个<code>promise</code>对象的数组作为参数。 </p><div><ul><li>只要其中有一个<code>Promise</code>成功执行，就会返回已经成功执行的<code>Promise</code>的结果</li><li>如果这个<code>promise</code>对象的数组中没有一个<code>promise</code> 可以成功执行（即所有的 <code>promise</code>都失败 ），就返回一个失败的<code>promise</code> 和<code>AggregateError</code>类型的实例，它是<code>Error</code>的一个子类，用于把单一的错误集合 在一起 </li></ul></div>',3),we=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])(" 总计一下"),Object(c["createElementVNode"])("code",null,"Promisea.any"),Object(c["createTextVNode"])("的应用场景：如果我们现在有多台服务器，则尽量使用响应速度最快的服务器，在这种情况下， 可以使用"),Object(c["createElementVNode"])("code",null,"Promise.any()"),Object(c["createTextVNode"])("方法从最快的服务器接收响应。 ")],-1),Te={id:"ErrorCapture"},ge=Object(c["createStaticVNode"])('<div class="c-h5">1. 使用reject而不是throw</div><p class="indent"> 在最开始我们先来一句比较重要的话：<code>Promise</code>的构造函数，以及被<code>then</code>调用执行的函数基本上都可以认为是 在<code>try...catch</code>代码块中执行的，所以在这些代码中即使使用<code>throw</code>，程序本身也不会异常而终止。 </p><p class="indent"> 所以其实如果在<code>Promise</code>中使用<code>throw</code>语句的话，会被<code>try...catch</code>住，最终<code>Promise</code> 对象也会变为<code>Rejected</code>状态。但是我们为什么还是推荐使用<code>Promise.reject</code>呢？有下面两个原因： </p><div><ul><li>我们很难区分<code>throw</code>是我们主动抛出来的，还是因为真正的其他异常导致的，无法主动决定，属于被动。</li><li><code>Promise</code>构造函数当中通过<code>throw</code>抛出来的错误未必会被<code>Promise.catch</code> 捕获到 </li></ul></div><p>下面我们就说说什么时候通过<code>throw</code>抛出的错误未必会被<code>Promise.catch</code>捕获到：</p>',5),ye=Object(c["createStaticVNode"])("<p>这个例子非常典型，想知道为什么错误没有被<code>catch</code>住，我们要到推出原因：</p><div><ul><li>首先我们要明确的是，不论是<code>then</code>还是<code>catch</code>中注册的回调函数，都是由<code>Promise</code> 状态的变化触发的，现在也就说<code>Promise</code>状态始终在<code>pending</code>状态。 </li><li> 其次，前面不是说<code>reject</code>和<code>throw</code>都能最终让<code>Promise</code>进入<code>onReject</code> 状态，这里的<code>throw</code>为什么没有改变<code>Promise</code>的状态。 </li><li> 原因还是要从事件循环来说，我们好好想想，这段代码在第一轮的事件循环当中<code>setTimeout</code>的回调函数被放在了 <code>timer</code>阶段的队列当中，但是它没有执行啊，所以第一轮的<code>Promise</code>状态一直处于<code>pending</code> ，所以<code>then</code>和<code>catch</code>部分的代码全部没有触发，也就在第一轮事件循环当中跳过了。然后在第二轮 循环当中才执行了<code>throw</code>语句，把错误直接抛到了全局，就直接报错。所以上面的代码和下面效果一样，catch怎么可能 捕获到在它后面执行的代码呢？ </li></ul></div>",2),Re=Object(c["createStaticVNode"])('<div class="c-h5">2. 在then中进行reject</div><p class="indent">如果我们想在<code>then</code>当中使用<code>reject</code>，首先我们要懂两个知识点：</p><div><ul><li><code>then</code>中的回调函数中，<code>return</code>的返回值类型不光是简单的字面值，还可以是复杂的对象类型， 比如<code>Promise</code>对象等。 </li><li> 只要修改这个返回的<code>Promise</code>的状态，在下一个<code>then</code>中注册的回调函数中的<code>onFulfilled</code> 和<code>onRejected</code>的哪一个会被调用也是能确定的 </li></ul></div><p>所以我们可以这样写代码就能在<code>then</code>当中使用<code>reject</code>:</p>',4),Ce=Object(c["createElementVNode"])("p",null,"当然还能更简洁一些：",-1),Se={id:"ReturnValue"},Fe=Object(c["createStaticVNode"])("<p>关于返回值的知识其实我们在前面都已经讲过，这里总结一下并举个例子巩固一下：</p><div><ul><li><code>Promise</code>会将最后的值存储起来，如果在下次使用<code>Promise</code>方法的时候，会直接返回该值 的<code>Promise</code></li><li><code>Promise</code>能够链式调用的原因是因为它的每一个方法都返回新的<code>Promise</code> ，哪怕是<code>finally</code>方法，特殊的是<code>finally</code>会返回上一个<code>Promise</code>的值 包装成新的<code>Promise</code>，并且<code>finally</code>也不接受参数，因为无论<code>Promise</code>是 <code>reject</code>还是<code>fulfill</code>它都会被调用 </li></ul></div><p>下面我们举个例子：</p>",3),Ue=Object(c["createStaticVNode"])("<p>这个例子也很经典，即使你已经搞清楚了上面的知识点，面对这个例子也还是会蒙掉，我们来说一下：</p><div><ul><li>首先通过构造函数创建了一个<code>Promise</code>，我们这里称之为<code>Promise_1</code> ，通过<code>reject</code>进入<code>catch</code>函数，然后注意，<code>catch</code>的回调 函数返回了一个2，实际上这里是返回了一个新的<code>Promise</code>，我们这里称之为<code> Promise_2 </code>，它的状态是<code>fulfilled</code>。 </li><li> 所以这里很迷惑人的一点就是<code>p1</code>最开始是指向<code>Promise_1</code>的，当 <code>Promise_2</code>返回的时候，它又指向了<code>Promise_20</code></li><li> 最后定时器经过一秒打印出2，因为<code>Promise_2</code>在被返回的时候就是<code>fulfilled</code> 状态，<code>then</code>函数当中的回调函数自然而然的被异步触发。 </li></ul></div>",2),_e={id:"Async"},ke=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"co"),Object(c["createTextVNode"])("模块的语法糖（用于 "),Object(c["createElementVNode"])("code",null,"Generator"),Object(c["createTextVNode"])(" 函数的自动执行）")],-1),Ae=Object(c["createElementVNode"])("p",null,"资料",-1),Be={type:"square"},Ie=Object(c["createStaticVNode"])("<p>参考总结：</p><div><ul><li> 如果一个函数通过<code>async</code>来声明，则一定可以通过<code>await</code>关键字来取到该函数 的返回值。 </li><li> 如果一个函数通过<code>async</code>来声明，则一定也可以通过<code>.then()</code>方法来取到该函数 返回的<code>Promise</code>中的值(因为<code>async</code>声明的函数，<code>return</code>出来的 结果一定是<code>Promise</code>对象 ) </li><li> 如果一个函数没有通过<code>async</code>来声明，但只要<code>return</code>出来一个<code>Promise</code>， 也可以通过<code>.then()</code>拿到里面的值(因为没有<code>async/await</code>的年代就是这样做的 )。 </li><li> 如果一个函数通过<code>async</code>声明，则在该函数内部可以使用<code>await</code>，也可以使用<code>.then()</code>。这表明， </li><li> 如果一个函数没有通过<code>async</code>声明，则在该函数内部不可以使用<code>await</code>， 但是可以使用<code>.then()</code>。 </li></ul></div>",2),qe=Object(c["createElementVNode"])("div",{class:"c-h5"},"1. 语法糖",-1),Ge=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("关键词是添加在函数定义之前的，一个"),Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("函数是定义会返回"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])(" 函数的简便写法。 ")],-1),ze=Object(c["createElementVNode"])("p",null,"比如：以下两个定义是有效的",-1),De=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("相似的，会抛出错误的"),Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("函数等效于返回失败的"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("的函数")],-1),Je=Object(c["createElementVNode"])("div",{class:"c-h5"},"2. async函数的返回值",-1),Le=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("其实"),Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("返回值有下面这四种情况：")],-1),Me=Object(c["createElementVNode"])("p",{class:"indent c-h6"},[Object(c["createTextVNode"])("① 返回值是"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象")],-1),We=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("这种情况是最常见，也是符合"),Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("定义的")],-1),$e=Object(c["createElementVNode"])("p",{class:"indent c-h6"},"② 返回值是普通值",-1),He=Object(c["createStaticVNode"])("<p>如果<code>return</code>出来一个普通值，会被包装成一个<code>Promise</code>对象。该<code>Promise</code> 状态为<code>fulfilled</code>，该<code>Promise</code>的值为该简单值。可以使用<code>.then()</code> 方法取到该<code>Promise</code>对象的值(该值就是 <code>async</code>声明的函数返回来的简单值 )。</p>",1),Ye=Object(c["createElementVNode"])("p",{class:"indent c-h6"},"③ 返回值是Error类型",-1),Ze=Object(c["createStaticVNode"])("<p>如果<code>return</code>出来是一个<code>Error</code>类型，则同样会被包装成一个<code>Promise</code>对象， 该<code>Promise</code>对象的状态是<code>reject</code>，值是<code>Error</code>的信息，想取出来该<code>Promise</code> 的报错信息，可以通过<code>.then()</code>的第二个参数，或者通过<code>.catch</code>方法。 </p>",1),Xe=Object(c["createElementVNode"])("p",{class:"indent c-h6"},"④ 没有返回值",-1),Ke=Object(c["createStaticVNode"])("<p> 如果没有<code>return</code>任何东西，则同样会返回一个<code>Promise</code>对象。该<code>Promise</code> 对象的状态为<code>fulfilled</code>，该<code>Promise</code>的值为<code>undefined</code>。 </p>",1),Qe={id:"Await"},eo=Object(c["createStaticVNode"])("<p><code>await</code>关键字，它只能在<code>async</code>函数内部使用，让我们可以等待一个<code>Promise</code></p><p>如果在<code>async</code>函数外使用<code>Promise</code>，我们依然需要使用<code>then</code>和回调函数 ，例如普通函数和全局函数。所以目前取出<code>Promise</code>对象值的两种方法：<code>.then 和 await</code></p>",2),oo=Object(c["createElementVNode"])("div",{class:"c-h5"},"1. 最大作用",-1),to=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"await"),Object(c["createTextVNode"])("最大的作用就是代替"),Object(c["createElementVNode"])("code",null,".then()"),Object(c["createTextVNode"])("方法，让整个成为同步的写法，更容易理解")],-1),co=Object(c["createElementVNode"])("p",{class:"indent c-h6"},"① 串行异步",-1),lo=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("当串联异步的操作时，"),Object(c["createElementVNode"])("code",null,"await"),Object(c["createTextVNode"])("要比"),Object(c["createElementVNode"])("code",null,".then()"),Object(c["createTextVNode"])("方法更加简洁。")],-1),no=Object(c["createElementVNode"])("p",{class:"indent c-h6"},"① 并行异步",-1),ro=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("虽然并行异步的代码还是离不开"),Object(c["createElementVNode"])("code",null,"Promise.all"),Object(c["createTextVNode"])("或者"),Object(c["createElementVNode"])("code",null,"Promise.race"),Object(c["createTextVNode"])("方法，但是用来处理 最终的并行结果的代码也是很简洁的。 ")],-1),ao=Object(c["createStaticVNode"])('<div class="c-h5">2. await本质</div><p>从上面我们列出的这么多代码来看，<code>await</code>本质就是<code>.then</code>方法的语法糖。事实上 ，<code>async/await</code>其实会编译为<code>Promise</code>与<code>then</code>回调。每次我们使用 <code>await</code>，解释器会创建一个<code>Promise</code>然后把<code>async</code>函数中的后续代码( 也就是书写在<code>await</code>后面的代码 )放在<code>then</code>回调中，并被计划在<code>Promise</code> 完成之后执行。所以下面两段代码是等价的 </p>',2),io=Object(c["createStaticVNode"])('<p>所以<code>await</code>关键字给我们的感觉是会让代码执行到<code>await</code>这一行的时候，“暂停执行” ，等到异步操作有了结果，再继续往下执行。那么问题来了， <span class="red"><code>await</code> 关键字会阻塞线程吗？</span>不会，因为还是我们上面说的那句话： <span class="red"><code>await</code>本质上是<code>.then()</code>的语法糖，<code>await</code>并没有 改变<code>JavaScript</code>单线程的本质，没有改变<code>event Loop</code>的模型，只是方便我们写代码，更快捷 ， 更清晰。</span>如下所示： </p>',1),so=Object(c["createStaticVNode"])('<p>所以通过上面这一段代码我们就能 <span class="red">明白</span> ：</p><br><p><code>await</code>关键字不会阻塞<code>js</code>的<code>event loop</code>线程。当代码执行到<code>async</code> 函数遇到<code>await</code>关键词时，不会继续往下执行，而是会发起异步调用，推入异步任务队列，等待异步处理。 但是此时<code>node</code>线程并不会闲着，而是继续执行<code>async</code>函数被调用的哪一行下面的代码。等到异步 操作的结果发生了变化时，将异步结果推入任务队列，<code>event loop</code>从队列中取出事件，推入的执行栈中。 </p>',3),uo={id:"AsyncAwaitErrorCatch"},mo=Object(c["createElementVNode"])("p",{class:"c-h5"},"1. try-catch",-1),jo=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("因为当我们使用"),Object(c["createElementVNode"])("code",null,"async/await"),Object(c["createTextVNode"])("的时候我们的代码是同步的写法，同步的错误处理理所应当会先想到的就是 "),Object(c["createElementVNode"])("code",null,"try/catch"),Object(c["createTextVNode"])("，所以对于"),Object(c["createElementVNode"])("code",null,"async/await"),Object(c["createTextVNode"])("的处理我们可以采用"),Object(c["createElementVNode"])("code",null,"try/catch"),Object(c["createTextVNode"])("。 ")],-1),bo=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])(" 实际通过上述代码可以看到："),Object(c["createElementVNode"])("code",null,"try/catch"),Object(c["createTextVNode"])("的方法在对于错误类型单一的情况下是简洁明了的，但是如果是 不同类型的错误类型，如果我们还采用"),Object(c["createElementVNode"])("code",null,"try/catch"),Object(c["createTextVNode"])("的方法也不是不行，只能在错误处理的代码上就要分类处理 ，还不一定能准确知道是那个请求方法出了问题，所以使用"),Object(c["createElementVNode"])("code",null,"try/catch"),Object(c["createTextVNode"])("在多类型错误的分析和定位是上是吃亏的： ")],-1),Vo=Object(c["createStaticVNode"])('<p class="c-h5">2. .then和.catch方法输出值</p><p> 针对<code>try/catch</code>的问题我们希望就是在有不同类型错误可能出现的情况下，我们还是能准备并分别不同的类型 做处理。而<code>async/await</code>本质就是<code>Promise</code>的语法糖，既然是<code>Promise</code>那么 就可以使用<code>then</code>函数和<code>catch</code>函数，通过<code>then</code>和<code>catch</code> 输出值。 </p>',2),Oo=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("当在处理不同类型的错误的时候，我么就能分别在对应的不同的"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("的链的末尾 "),Object(c["createElementVNode"])("code",null,"catch"),Object(c["createTextVNode"])("当中书写不同的处理函数 ")],-1),No=Object(c["createElementVNode"])("p",{class:"c-h5"},"3. 更优雅的方式",-1),po=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("使用 "),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("和"),Object(c["createElementVNode"])("code",null,"catch"),Object(c["createTextVNode"])("函数及数组解构，区分正常和异常结果，封装公共处理函数。 ")],-1),vo={id:"AsyncAwaitLoop"},fo=Object(c["createStaticVNode"])("<div><ul><li>如果你想连续执行 <code>await</code>调用，请使用<code>for</code>循环(或者没有任何回调的循环)。</li><li>永远不要和<code>forEach</code>一起使用<code>await</code>，而是使用<code>for</code>循环(或者没有任何回调的循环)。</li><li>不要在<code>filter</code>和<code>reduce</code>中使用<code>await</code>，如果需要，先用<code>map</code> 进一步处理，然后再使用<code>filter</code>和<code>reduce</code>进行处理。 </li></ul></div>",1);var ho=Object(c["defineComponent"])({__name:"promise",setup(e){const o=Object(c["getCurrentInstance"])(),{$builtIn:t}=null===o||void 0===o?void 0:o.appContext.config.globalProperties,l=Object(c["ref"])("https://juejin.cn/post/6844903457170653198"),n=Object(c["ref"])("https://juejin.cn/post/6844903767129718791"),d=Object(c["ref"])("https://juejin.cn/post/6844903860079738887"),r=t("\nvar promise = new Promise(function (resolve, reject) {\n  // 异步处理\n  // 处理结果成功调用 resolve\n  // 失败调用 reject\n});\n"),a=t("\nnew Promise(function (resolve) {\n    resolve(42)\n})\n"),i=t('\nnew Promise(function (reject) {\n    reject(new Error("Promise reject error"))\n})\n'),s=t('\nvar promise = new Promise((resolve, reject) => {\n  console.log("inner Promise"); // 1\n  setTimeout(() => {\n    resolve("Fashion Barry"); // 3\n  }, 1000);\n});\n\npromise.then((res) => {\n  console.log("res", res);\n});\nconsole.log("outer promise"); // 2\n// Promise 实际是一个同步函数，then 方法才是异步\n// 所以输出顺序如上\n'),u=t('\nvar aPromise = new Promise((resolve, reject) => {\n  resolve("aPromise");\n});\nvar thenPromise = aPromise.then((res) => {\n  console.log("thenPromise: ", res);\n});\nvar catchPromise = aPromise.catch((err) => {\n  console.error("catchPromise: ", err);\n});\n\nconsole.log(aPromise !== thenPromise); // true\nconsole.log(thenPromise !== catchPromise); // true\nconsole.log(aPromise, thenPromise, catchPromise); // Promise { "aPromise" }, Promise { <pending> }, Promise { <pending> }\n'),m=t('\nPromise.resolve("Barry")\n.then(Promise.resolve("Barry Promise"))\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),j=t('\nPromise.resolve("Barry")\n.then(null)\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),b=t('\nPromise.resolve("Barry")\n.then(null)\n.then({ name: "My name is Barry" })\n.then(null)\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),V=t("\n// 第一种写法\nPromise.resolve()\n  .then((data) => console.log(data))\n  .then(undefined, (err) => console.log(err));\n\n// 第二种写法\nPromise.resolve()\n  .then((data) => console.log(data))\n  .catch((err) => console.log(err));\n"),O=t('\nlet p1 = new Promise((resolve, reject) => {\n  // 第一层执行逻辑\n  resolve("first promise"); // Promise(1)\n})\n  .then((res) => {\n    // 第二层执行逻辑\n    return "second promise"; // Promise(2)\n  })\n  .then((res) => {\n    // 第三层执行逻辑\n    return "third promise"; // Promise(3)\n  })\n  .catch((err) => {\n    console.log("err", err);\n  });\n'),N=t('\nvar p1 = new Promise((resolve, rejevt) => {\n  setTimeout(() => {\n    resolve;\n  }, 1000);\n});\n\np1.then((res) => console.log(res))\n  .catch((err) => console.log(err))\n  .finally(() => console.log("finally"));\n'),p=t("\npromise.finally(() => {\n  // 执行逻辑\n});\n// 上面代码等同于下面\npromise.then(\n  (onFulilled) => {\n    // 语句\n    return onFulilled;\n  },\n  (onRejected) => {\n    // 语句\n    throw onRejected;\n  }\n);\n"),v=t('\nPromise.prototype.finally = function (callback) {\n  let p = this.constructor;\n  return this.then(\n    (value) => p.resolve(callback()).then(() => value),\n    (reason) =>\n      p.reject(callback()).then(() => {\n        throw reason;\n      })\n  );\n};\n\nvar p = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    reject("Promise err");\n  }, 1000);\n});\np.catch((err) => console.log("err", err)).finally(() => {\n  console.log("finally");\n});'),f=t('\nvar promise1 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise1--3000");\n  }, 3000);\n});\nvar promise2 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise2--1000");\n  }, 1000);\n});\nvar promise3 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise3--5000");\n  }, 5000);\n});\n\nvar promiseArr = [promise1, promise2, promise3];\nconsole.time("promiseArr");\nPromise.all(promiseArr)\n  .then((res) => {\n    console.log("res", res); // [\'promise1--3000\', \'promise1--1000\', \'promise1--5000\']\n    console.timeEnd("promiseArr"); // 5523.29296875 ms\n  })\n  .catch((err) => console.log(err));\n'),h=t('\nlet arr = [1000, 3000, 5000, 7000];\nlet promiseArr = [];\n\nfor (let i = 0; i < arr.length; i++) {\n  let newPromise = new Promise((resolve, reject) => {\n    if (i === 0) {\n      reject(new Error("第二个错误"));\n    } else {\n      setTimeout(() => {\n        console.log(arr[i]);\n        resolve(arr[i]);\n      }, arr[i]);\n    }\n  });\n  promiseArr.push(newPromise);\n}\n\nPromise.race(promiseArr)\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n\n// 控制台报错\n// 3000\n// 5000\n// 7000\n'),E=t('\nvar promise1 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    reject(new Error("promise1--3000"));\n    // resoleve("promise1--3000");\n  }, 3000);\n});\nvar promise2 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // reject(new Error("promise1--1000"))\n    resoleve("promise2--1000");\n  }, 1000);\n});\nvar promise3 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise3--5000");\n    // reject(new Error("promise1--5000"))\n  }, 5000);\n});\nvar promiseArr = [promise1, promise2, promise3];\nconsole.time("promiseArr");\nPromise.allSettled(promiseArr)\n  .then((res) => {\n    console.log("res", res);\n    console.timeEnd("promiseArr");\n  })\n  .catch((err) => console.error(err))\n  .finally(() => console.log("finally"));\n'),P=t('\nvar promise1 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // reject(new Error("promise1--3000"));\n    resoleve("promise1--3000");\n  }, 3000);\n});\nvar promise2 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // reject(new Error("promise2--1000"))\n    resoleve("promise1--1000");\n  }, 1000);\n});\nvar promise3 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // resoleve("promise3--5000");\n    reject(new Error("promise1--5000"))\n  }, 5000);\n});\nvar promiseArr = [promise1, promise2, promise3];\nconsole.time("promiseArr");\nPromise.any(promiseArr)\n  .then((res) => {\n    console.log("res", res); // res promise1--1000\n    console.timeEnd("promiseArr");\n  })\n  .catch((err) => console.error(err)); \n  //所有的Promise都失败， AggregateError: All promises were rejected\n'),x=t('\nvar p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    throw new Error("async error");\n  }, 500);\n});\n\np1.then((res) => {\n  console.log("res--", res);\n}).catch((err) => {\n  console.error("err--", err);\n});\n// 会直接报错，不会走到 catch\n'),w=t("\nvar p1 = new Promise(function(resolve, reject) {\n})\n.then(res => {\n})\n.catch(err => {\n})\nthrow Error('async error')   "),T=t('\nvar onRejected = console.error.bind(console);\nvar promise = Promise.resolve();\npromise\n  .then(() => {\n    var retPromise = new Promise(function (resolve, reject) {\n      reject(new Error("this promise is rejected"));\n    });\n    return retPromise;\n  })\n  .catch(onRejected);\n'),g=t('\nvar promise = Promise.resolve();\npromise\n  .then(function () {\n    return (retPromise = Promise.reject(\n      new Error("this promise is rejected")\n    ));\n  })\n  .catch((err) => console.error("err", err));\n'),y=t('\nvar p1 = new Promise((resolve, reject) => {\n  reject("p1");\n}).catch((err) => {\n  console.error("err", err);\n  return "p2";\n});\n\nsetTimeout(() => {\n  p1.then((res) => console.log(res));\n}, 1000);\n// 先打印出error 1\n// 1秒钟以后打印出 P2\n'),R=t('\n(function* () {\n  var f1 = yield readFile("/etc/fstab");\n  var f2 = yield readFile("/etc/shells");\n  console.log(f1.toString());\n})();\n'),C=t('\nfunction f() {\n  return Promise.resolve("TEST");\n}\n\n// asyncF is equivalent to f!\nasync function asyncF() {\n  return "Test";\n}\n// console.log(f());\n// console.log(asyncF());\n'),S=t('\nfunction f() {\n  return Promise.reject("TEST");\n}\n\n// asyncF is equivalent to f!\nasync function asyncF() {\n  throw "Test";\n}\n// console.log(f());\n// console.log(asyncF());\n'),F=t('\nconst request = require("request");\nasync function f1() {\n  return new Promise(function (resolve, reject) {\n    request("https://www.baidu.com/", function (err, res, body) {\n      resolve(body);\n    });\n  });\n}\n// 用then来拿到返回值\nf1().then((res) => console.log(res));\n// 用await来拿到返回值\n(async function () {\n  console.log(await f1());\n})();\n'),U=t("\nasync function f1 () {\n    return 10;\n}\n\nconsole.log(f1());     // Promise {<resolved>: 10}\nfn1().then(function (x) {\n  console.log(x);      // 10\n})\n"),_=t('\nasync function f1() {\n  throw new Error("ssss");\n}\n// 第一种\nf1().then(\n  (onFulfilled) => {},\n  (onRejected) => console.log(onRejected)\n);\n// 第二种\nf1().catch(function (e) {\n  console.log(e);\n});\n'),ho=t('\nvar p1 = new Promise((resolve, reject) => {\n  resolve();\n});\np1.then((res) => console.log("p1", res));\n\nasync function p2() {\n  await (1 + 1);\n}\n(async () => {\n  console.log("p2", p2());\n})();\n'),Eo=t('\nvar asyncFunc1 = function () {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve("asyncFunc1");\n    }, 1000);\n  });\n};\nvar asyncFunc2 = function () {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve("asyncFunc2");\n    }, 1000);\n  });\n};\n\n// 使用 .then 进行串联操作\nfunction asyncF() {\n  asyncFunc1()\n    .then((res) => {\n      console.log("res", res);\n      return asyncFunc2();\n    })\n    .then((res2) => {\n      console.log("res2", res2);\n    });\n}\nasyncF();\n\n// 使用 await 关键字\nasync function asyncF2() {\n  let res = await asyncFunc1();\n  let res2 = await asyncFunc2();\n  console.log("res", res);\n  console.log("res2", res2);\n}\nasyncF2();\n'),Po=t('\nvar asyncFunc1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve("asyncFunc1");\n  }, 1000);\n});\n\nvar asyncFunc2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve("asyncFunc2");\n  }, 1000);\n});\n\n// 使用 .then 进行串联操作\nfunction asyncF() {\n  // [ res1, res2 ] 结构\n  Promise.all([asyncFunc1, asyncFunc2]).then(([res1, res2]) => {\n    console.log("asyncF", res1, res2);\n  });\n}\nasyncF();\n\n// 使用 await 关键字\nasync function asyncF2() {\n  let [res1, res2] = await Promise.all([asyncFunc1, asyncFunc2]);\n  console.log("asyncF2", res1, res2);\n}\nasyncF2();\n'),xo=t('\n// await写法\nawait foo();         \nconsole.log("hello");\n\n// .then写法\nfoo().then(() => {\n    console.log("hello");\n});\n'),wo=t("\nvar p1 = new Promise((resolve, reject) => {\n  console.log(1);\n  setTimeout(() => {\n    resolve(6);\n  }, 1000);\n});\n\nasync function multipleRequestAsync() {\n  console.log(3);\n  let result = await p1;\n  console.log(result);\n  console.log(7);\n}\nconsole.log(2);\nmultipleRequestAsync();\nconsole.log(4);\nconsole.log(5);\n\n// 1 2 3 4 5 6 7\n"),To=t('\n(async () => {\n  const _fetch = () => {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject("reject promise");\n      }, 1000);\n    });\n  };\n\n  try {\n    let result = await _fetch();\n    console.log("result", result);\n  } catch (err) {\n    console.log("err", err);\n  }\n})();\n'),go=t("\ntry {\n    let result = await fsData()        // 读取文件\n    let result = await requestData()   // 网络请求\n    let result = await readDb()        // 读取数据库\n} catch (error) {\n    // 不同的错误进行分类\n}\n"),yo=t('\n(async () => {\n  const _fetch = () => {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject("reject promise");\n      }, 1000);\n    });\n  };\n\n  let result = await _fetch()\n    .then((res) => res)\n    .catch((err) => console.log(err));\n  console.log("result", result);\n})();\n'),Ro=t("\nconst data = await fsData().then(data => data ).catch(err => // 文件读取错误的处理)\nconst data = await requestData().then(data => data ).catch(err => // 网络请求错误的处理)\nconst data = await readDb().then(data => data ).catch(err => // 数据库读写错误的处理)\n"),Co=t('\n(async () => {\n  function handleError(err) {\n    if (err !== null) {\n      console.log("err", err);\n      // 具体错误处理逻辑，Tip 还是？\n    }\n  }\n\n  function handleData(data) {\n    if (data !== null) {\n      // 具体处理结果\n    }\n  }\n  const _fetch = () => {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject("reject promise");\n      }, 1000);\n    });\n  };\n\n  const [err, data] = await _fetch()\n    .then((data) => [null, data])\n    .catch((err) => [err, null]);\n  handleData(data);\n  handleError(err);\n\n  // 抽离成公共方法\n\n  const awaitWrap = (promise) => {\n    return promise.then((data) => [null, data]).catch((err) => [err, null]);\n  };\n  const [err1, data1] = await awaitWrap(_fetch());\n  handleData(data1);\n  handleError(err1);\n})();\n');return(e,o)=>{const t=Object(c["resolveComponent"])("RouterLink"),So=Object(c["resolveComponent"])("WebPrismEditor"),Fo=Object(c["resolveComponent"])("cod"),Uo=Object(c["resolveComponent"])("NavigationBlank");return Object(c["openBlock"])(),Object(c["createElementBlock"])(c["Fragment"],null,[Object(c["createElementVNode"])("h3",k,[Object(c["createVNode"])(t,{to:"#Promise",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、Promise(异步编程) ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",A,[Object(c["createVNode"])(t,{to:"#ConstructorStatus",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、构造函数和状态 ")]),Object(c["createElementVNode"])("section",null,[B,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(r),"onUpdate:modelValue":o[0]||(o[0]=e=>Object(c["isRef"])(r)?r.value=e:null)},null,8,["modelValue"])]),I]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",q,[Object(c["createVNode"])(t,{to:"#NineMethods",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、九大方法 ")]),Object(c["createElementVNode"])("section",null,[G,z,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(a),"onUpdate:modelValue":o[1]||(o[1]=e=>Object(c["isRef"])(a)?a.value=e:null)},null,8,["modelValue"]),Object(c["createElementVNode"])("p",D,[Object(c["createTextVNode"])("这个静态方法会让"),J,Object(c["createTextVNode"])("对象立即进入确定(即resolved) 状态，并将42传递给后面 "),Object(c["createVNode"])(Fo,null,{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("then")]),_:1}),Object(c["createTextVNode"])(" 里所指定的 "),L,Object(c["createTextVNode"])("函数。作为 "),M,Object(c["createTextVNode"])("的快捷方式，在进行 "),W,Object(c["createTextVNode"])(" 对象的初始化或者编写测试代码的时候都非常方便。 ")]),$]),Object(c["createElementVNode"])("section",null,[H,Y,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(i),"onUpdate:modelValue":o[2]||(o[2]=e=>Object(c["isRef"])(i)?i.value=e:null)},null,8,["modelValue"]),Z]),Object(c["createElementVNode"])("section",null,[X,K,Object(c["createElementVNode"])("div",null,[Q,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(s),"onUpdate:modelValue":o[3]||(o[3]=e=>Object(c["isRef"])(s)?s.value=e:null)},null,8,["modelValue"]),ee]),Object(c["createElementVNode"])("div",null,[oe,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(u),"onUpdate:modelValue":o[4]||(o[4]=e=>Object(c["isRef"])(u)?u.value=e:null)},null,8,["modelValue"]),te]),Object(c["createElementVNode"])("div",null,[ce,le,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(m),"onUpdate:modelValue":o[5]||(o[5]=e=>Object(c["isRef"])(m)?m.value=e:null)},null,8,["modelValue"]),ne,de,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(j),"onUpdate:modelValue":o[6]||(o[6]=e=>Object(c["isRef"])(j)?j.value=e:null)},null,8,["modelValue"]),re,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(b),"onUpdate:modelValue":o[7]||(o[7]=e=>Object(c["isRef"])(b)?b.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("section",null,[ae,Object(c["createElementVNode"])("div",null,[ie,se,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(V),"onUpdate:modelValue":o[8]||(o[8]=e=>Object(c["isRef"])(V)?V.value=e:null)},null,8,["modelValue"]),ue]),Object(c["createElementVNode"])("div",null,[me,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(O),"onUpdate:modelValue":o[9]||(o[9]=e=>Object(c["isRef"])(O)?O.value=e:null)},null,8,["modelValue"]),je])]),Object(c["createElementVNode"])("section",null,[be,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(N),"onUpdate:modelValue":o[10]||(o[10]=e=>Object(c["isRef"])(N)?N.value=e:null)},null,8,["modelValue"]),Ve,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(p),"onUpdate:modelValue":o[11]||(o[11]=e=>Object(c["isRef"])(p)?p.value=e:null)},null,8,["modelValue"]),Oe,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(v),"onUpdate:modelValue":o[12]||(o[12]=e=>Object(c["isRef"])(v)?v.value=e:null)},null,8,["modelValue"]),Ne]),Object(c["createElementVNode"])("section",null,[pe,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(f),"onUpdate:modelValue":o[13]||(o[13]=e=>Object(c["isRef"])(f)?f.value=e:null)},null,8,["modelValue"]),ve]),Object(c["createElementVNode"])("section",null,[fe,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(E),"onUpdate:modelValue":o[14]||(o[14]=e=>Object(c["isRef"])(E)?E.value=e:null)},null,8,["modelValue"]),he]),Object(c["createElementVNode"])("section",null,[Ee,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(h),"onUpdate:modelValue":o[15]||(o[15]=e=>Object(c["isRef"])(h)?h.value=e:null)},null,8,["modelValue"]),Pe]),Object(c["createElementVNode"])("section",null,[xe,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(P),"onUpdate:modelValue":o[16]||(o[16]=e=>Object(c["isRef"])(P)?P.value=e:null)},null,8,["modelValue"]),we])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Te,[Object(c["createVNode"])(t,{to:"#ErrorCapture",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、错误捕获 ")]),Object(c["createElementVNode"])("section",null,[ge,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(x),"onUpdate:modelValue":o[17]||(o[17]=e=>Object(c["isRef"])(x)?x.value=e:null)},null,8,["modelValue"]),ye,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(w),"onUpdate:modelValue":o[18]||(o[18]=e=>Object(c["isRef"])(w)?w.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("section",null,[Re,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(T),"onUpdate:modelValue":o[19]||(o[19]=e=>Object(c["isRef"])(T)?T.value=e:null)},null,8,["modelValue"]),Ce,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(g),"onUpdate:modelValue":o[20]||(o[20]=e=>Object(c["isRef"])(g)?g.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Se,[Object(c["createVNode"])(t,{to:"#ReturnValue",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、返回值 ")]),Object(c["createElementVNode"])("section",null,[Fe,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(y),"onUpdate:modelValue":o[21]||(o[21]=e=>Object(c["isRef"])(y)?y.value=e:null)},null,8,["modelValue"]),Ue])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",_e,[Object(c["createVNode"])(t,{to:"#Async",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("6、async ")]),Object(c["createElementVNode"])("section",null,[ke,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(R),"onUpdate:modelValue":o[22]||(o[22]=e=>Object(c["isRef"])(R)?R.value=e:null)},null,8,["modelValue"]),Ae,Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("ul",Be,[Object(c["createElementVNode"])("li",null,[Object(c["createVNode"])(Uo,{modelValue:l.value,"onUpdate:modelValue":o[23]||(o[23]=e=>l.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("深入理解 ES7 的async/await")]),_:1},8,["modelValue"])]),Object(c["createElementVNode"])("li",null,[Object(c["createVNode"])(Uo,{modelValue:n.value,"onUpdate:modelValue":o[24]||(o[24]=e=>n.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("async/await优雅的错误处理方法")]),_:1},8,["modelValue"])]),Object(c["createElementVNode"])("li",null,[Object(c["createVNode"])(Uo,{modelValue:d.value,"onUpdate:modelValue":o[25]||(o[25]=e=>d.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("如何在 JS 循环中正确使用async 与 await")]),_:1},8,["modelValue"])])])]),Ie,Object(c["createElementVNode"])("div",null,[qe,Ge,ze,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(C),"onUpdate:modelValue":o[26]||(o[26]=e=>Object(c["isRef"])(C)?C.value=e:null)},null,8,["modelValue"]),De,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(S),"onUpdate:modelValue":o[27]||(o[27]=e=>Object(c["isRef"])(S)?S.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[Je,Le,Object(c["createElementVNode"])("div",null,[Me,Object(c["createElementVNode"])("section",null,[We,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(F),"onUpdate:modelValue":o[28]||(o[28]=e=>Object(c["isRef"])(F)?F.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[$e,Object(c["createElementVNode"])("section",null,[He,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(U),"onUpdate:modelValue":o[29]||(o[29]=e=>Object(c["isRef"])(U)?U.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Ye,Object(c["createElementVNode"])("section",null,[Ze,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(_),"onUpdate:modelValue":o[30]||(o[30]=e=>Object(c["isRef"])(_)?_.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Xe,Object(c["createElementVNode"])("section",null,[Ke,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(ho),"onUpdate:modelValue":o[31]||(o[31]=e=>Object(c["isRef"])(ho)?ho.value=e:null)},null,8,["modelValue"])])])])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Qe,[Object(c["createVNode"])(t,{to:"#Await",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("7、await ")]),Object(c["createElementVNode"])("section",null,[eo,Object(c["createElementVNode"])("div",null,[oo,to,Object(c["createElementVNode"])("div",null,[co,Object(c["createElementVNode"])("section",null,[lo,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(Eo),"onUpdate:modelValue":o[32]||(o[32]=e=>Object(c["isRef"])(Eo)?Eo.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[no,Object(c["createElementVNode"])("section",null,[ro,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(Po),"onUpdate:modelValue":o[33]||(o[33]=e=>Object(c["isRef"])(Po)?Po.value=e:null)},null,8,["modelValue"])])])]),Object(c["createElementVNode"])("div",null,[ao,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(xo),"onUpdate:modelValue":o[34]||(o[34]=e=>Object(c["isRef"])(xo)?xo.value=e:null)},null,8,["modelValue"]),io,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(wo),"onUpdate:modelValue":o[35]||(o[35]=e=>Object(c["isRef"])(wo)?wo.value=e:null)},null,8,["modelValue"]),so])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",uo,[Object(c["createVNode"])(t,{to:"#AsyncAwaitErrorCatch",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("8、async和await错误处理 ")]),Object(c["createElementVNode"])("section",null,[Object(c["createElementVNode"])("div",null,[mo,jo,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(To),"onUpdate:modelValue":o[36]||(o[36]=e=>Object(c["isRef"])(To)?To.value=e:null)},null,8,["modelValue"]),bo,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(go),"onUpdate:modelValue":o[37]||(o[37]=e=>Object(c["isRef"])(go)?go.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[Vo,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(yo),"onUpdate:modelValue":o[38]||(o[38]=e=>Object(c["isRef"])(yo)?yo.value=e:null)},null,8,["modelValue"]),Oo,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(Ro),"onUpdate:modelValue":o[39]||(o[39]=e=>Object(c["isRef"])(Ro)?Ro.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[No,po,Object(c["createVNode"])(So,{modelValue:Object(c["unref"])(Co),"onUpdate:modelValue":o[40]||(o[40]=e=>Object(c["isRef"])(Co)?Co.value=e:null)},null,8,["modelValue"])])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",vo,[Object(c["createVNode"])(t,{to:"#AsyncAwaitLoop",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("9、async和await循环中使用 ")]),Object(c["createElementVNode"])("section",null,[Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("参考资料: "),Object(c["createVNode"])(Uo,{modelValue:d.value,"onUpdate:modelValue":o[41]||(o[41]=e=>d.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("如何在JS循环中正确使用 async 与 await")]),_:1},8,["modelValue"])]),fo])])],64)}}});const Eo=ho;var Po=Eo;const xo={id:"PromiseRealization"},wo={id:"RealizationSteps"},To={id:"PromiseATest"};var go=Object(c["defineComponent"])({__name:"promiseRealization",setup(e){const o=Object(c["getCurrentInstance"])(),{$builtIn:t}=null===o||void 0===o?void 0:o.appContext.config.globalProperties;return(e,o)=>{const t=Object(c["resolveComponent"])("RouterLink");return Object(c["openBlock"])(),Object(c["createElementBlock"])(c["Fragment"],null,[Object(c["createElementVNode"])("h3",xo,[Object(c["createVNode"])(t,{to:"#PromiseRealization",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、PromiseA+ 实现 ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",wo,[Object(c["createVNode"])(t,{to:"#RealizationSteps",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、实现步骤 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",To,[Object(c["createVNode"])(t,{to:"#PromiseATest",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、测试 ")])])],64)}}});const yo=go;var Ro=yo;const Co={id:"Generator"},So=Object(c["createElementVNode"])("div",{class:"brief-introduction"},[Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("迭代器的英文"),Object(c["createElementVNode"])("code",null,"iteration"),Object(c["createTextVNode"])("源自拉丁文"),Object(c["createElementVNode"])("code",null,"itero"),Object(c["createTextVNode"])("，意思是“重复”或“再来”。在软件开发领域 ，“迭代”的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。"),Object(c["createElementVNode"])("code",null,"ECMAScript 6"),Object(c["createTextVNode"])(" 规范新增了两个高级特性：迭代器和生成器。使用这两个特性，能够更清晰、高效、方便的实现迭代。 ")]),Object(c["createElementVNode"])("p",{class:"right"},"摘自《高级JavaScript程序设计 第四版》")],-1),Fo={id:"Iterator"},Uo=Object(c["createStaticVNode"])("<p>迭代器<code>Iterator</code>是ES6引入的一种新的遍历机制，一中接口，本质是一个指针对象，供 <code>for...of</code>消费。 </p><div><ul><li>迭代器也有<code>next()</code>方法，返回对象<code>{ value:&quot;&quot;, done:false }</code> ，第一次调用时返回第一个值 </li><li> 迭代器部署在<code>Symbol.iterator</code>属性上 </li><li><code>Array、Map、Set、String、Function的arguments</code>对象等具有原生 <code>Iterator</code>接口 </li><li><code>Number/Object</code>没有实现迭代工厂函数</li></ul></div>",2),_o=Object(c["createElementVNode"])("p",null," 每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的示例相互之间没有联系，只会独立地遍历 可迭代对象。请看看下述代码： ",-1),ko=Object(c["createElementVNode"])("p",null," 迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅而仅仅是使用【游标】来记录遍历可迭代对象的历程。 如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化。请看看下述代码： ",-1),Ao=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("span",{class:"red"},"【注意】"),Object(c["createTextVNode"])(" 迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。")],-1),Bo={id:"CustomIterator"},Io=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])(" 与"),Object(c["createElementVNode"])("code",null,"Interable"),Object(c["createTextVNode"])("接口类似，任何实现"),Object(c["createElementVNode"])("code",null,"Iterator"),Object(c["createTextVNode"])("接口的对象都可以作为迭代器使用。 下面这个例子中"),Object(c["createElementVNode"])("code",null,"Counter"),Object(c["createTextVNode"])("类只能被一定的次数。 ")],-1),qo=Object(c["createElementVNode"])("p",null,"为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此可以把计数器 放到闭包里，然后通过闭包返回迭代器。 ",-1),Go=Object(c["createStaticVNode"])('<p class="c-h5">如何提前终止迭代器</p><p class="indent">可选的<code>return()</code>方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在 想让迭代器知道他不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。可能情况包括：</p><div><ul><li><code>for-of</code>循环通过<code>break、continue、return 或 throw</code>提前退出 </li><li> 解构操作并未消费所有值 </li></ul></div><p>需要注意的是：<code>return()</code>方法必须返回一个有效的<code>IteratorResult</code>对象。 简单情况下，可以返回<code>{ done:true }</code>。因为这个返回值只会用在生成器的上下文中。</p>',4),zo=Object(c["createElementVNode"])("p",null,"如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如：数组的迭代器就是不能关闭的：",-1),Do=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("因为"),Object(c["createElementVNode"])("code",null,"return()"),Object(c["createTextVNode"])("方法是可选，所以并非所有迭代器都是可以关闭的。要知道某个迭代器是否可关闭， 可以测试这个迭代器实例的"),Object(c["createElementVNode"])("code",null,"return"),Object(c["createTextVNode"])("属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加 这个方法"),Object(c["createElementVNode"])("span",{class:"red"},"并不能"),Object(c["createTextVNode"])("让它可关闭的。这是因为调用"),Object(c["createElementVNode"])("code",null,"return()"),Object(c["createTextVNode"])("不会强制 迭代器进入关闭状态。 ")],-1),Jo={id:"SubGenerator"},Lo=Object(c["createStaticVNode"])('<p>生成遍历器对象的函数，使用<code>*</code>表示函数(星号可以紧挨着<code>function</code>关键字 也可以在中间添加一个空格)，内部使用<code>yield</code>定义内部状态。</p><div><ul><li>每当执行完一条<code>yield</code>语句后，函数就会自动停止执行，直到再次调用<code>next()</code></li><li><code>yield</code>关键字，只可在生成器内部使用，在其他地方使用会导致程序抛出错误 </li><li> 可以通过函数表达式来创建生成器，但是不能使用箭头函数 </li><li> 可以在<code>generator</code>函数运行的不同阶段从外部内部注入不同的值，从而改变函数行为 <div><ul type="circle"><li><code>yield</code>语句无返回值，总是返回<code>undefined</code>。</li><li><code>next</code>方法可以带一个参数，参数被当做上一条<code>yield</code> 的返回值。</li></ul></div></li></ul></div>',2),Mo=Object(c["createStaticVNode"])('<p class="c-h5">1. throw方法</p><p><code>Generator</code>函数返回的遍历器对象都有一个<code>throw</code>方法，可以在函数体外 抛出错误，然后在<code>Generator</code>函数体内捕获。 </p><div><ul><li>若<code>Generator</code>函数体内部署了<code>try...catch</code>代码块， 那么遍历器的<code>throw</code>方法抛出的错误不会影响下一次遍历，反之如果 <code>Generator</code>函数体内没有部署<code>try...catch</code> ，使用遍历器的<code>throw</code>方法抛出的错误，遍历则会终止。 </li><li> 一旦<code>Generator</code>执行过程中抛出错误，就不会再执行下去，如果后续调用 <code>next</code>方法，返回<code>{ value: undefined, done: true,}</code>对象 </li></ul></div>',3),Wo=Object(c["createElementVNode"])("p",null,"g.throw() 方法被【捕获】后会自动执行一次【next】方法，内部部署了【try...catch】 遍历器的【throw】方法抛出的异常不会影响下次遍历 ",-1),$o=Object(c["createElementVNode"])("p",{class:"c-h5"},"2. return方法",-1),Ho=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"Generator.prototype.return()"),Object(c["createTextVNode"])("，返回给的值，并终结"),Object(c["createElementVNode"])("code",null,"Generator"),Object(c["createTextVNode"])(" 函数的遍历 ")],-1),Yo={id:"AutoGenerator"};var Zo=Object(c["defineComponent"])({__name:"generator",setup(e){const o=Object(c["getCurrentInstance"])(),{$builtIn:t}=null===o||void 0===o?void 0:o.appContext.config.globalProperties,l=t("\nlet num = 1;\nlet obj = {};\n\nconsole.log(num[Symbol.iterator]); // undefined\nconsole.log(obj[Symbol.iterator]); // undefined\n\n\n\nlet arr = [\"own\", \"two\", \"three\"];\n\nlet iter = arr[Symbol.iterator]();\nconsole.log(iter.next()); // {value: 'own', done: false}\nconsole.log(iter.next()); // {value: 'two', done: false}\nconsole.log(iter.next()); // {value: 'three', done: false}\nconsole.log(iter.next()); // {value: undefined, done: true}\n\nfor (let key in arr) {\n  console.log(key); // 0,1,2 去键名\n}\nfor (let value of arr) {\n  console.log(value); // 取值\n}\n"),n=t("\nlet arr = [\"own\", \"two\", \"three\"];\n\nlet iter1 = arr[Symbol.iterator]();\nlet iter2 = arr[Symbol.iterator]();\n\nconsole.log(iter1.next()); //{value: 'own', done: false}\nconsole.log(iter2.next()); //{value: 'own', done: false}\nconsole.log(iter1.next()); //{value: 'two', done: false}\nconsole.log(iter2.next()); //{value: 'two', done: false}\n"),d=t("\nlet arr = [\"own\", \"two\", \"three\"];\nlet iter = arr[Symbol.iterator]();\n\nconsole.log(iter.next()); //{value: 'own', done: false}\n\n// 在 arr 中间插入值\narr.splice(1, 0, \"four\");\nconsole.log(iter.next()); //{value: 'four', done: false}\nconsole.log(iter.next()); //{value: 'two', done: false}\nconsole.log(iter.next()); //{value: 'three', done: false}\nconsole.log(iter.next()); //{value: undefined, done: true}\n"),r=t("\nclass Counter {\n  // counter 的实例应该被迭代 limit 次\n  constructor(limit) {\n    this.limit = limit;\n  }\n\n  [Symbol.iterator]() {\n    let count = 1;\n    let limit = this.limit;\n\n    return {\n      next() {\n        if (count <= limit) {\n          return { done: false, value: count++ };\n        } else {\n          return { done: true, value: undefined };\n        }\n      },\n    };\n  }\n}\n\nlet counter = new Counter(3);\n\nfor (let v of counter) {\n  console.log(v);\n}\n\nfor (let v of counter) {\n  console.log(v);\n}\n"),a=t('\nclass Counter {\n  // counter 的实例应该被迭代 limit 次\n  constructor(limit) {\n    this.limit = limit;\n  }\n\n  [Symbol.iterator]() {\n    let count = 1;\n    let limit = this.limit;\n\n    return {\n      next() {\n        if (count <= limit) {\n          return { done: false, value: count++ };\n        } else {\n          return { done: true, value: undefined };\n        }\n      },\n      return() {\n        console.error("Exiting early");\n        return { done: true };\n      },\n    };\n  }\n}\n\nlet counter = new Counter(3);\n\nfor (let v of counter) {\n  if (v > 2) {\n    break;\n  }\n  console.log(v);\n}\n'),i=t("\nlet a = [1, 2, 3, 4, 5];\nlet iter = a[Symbol.iterator]();\nfor (let i of iter) {\n  console.log(i);\n  if (i > 2) {\n    break;\n  }\n}\n// 1\n// 2\n// 3\nfor (let i of iter) {\n  console.log(i);\n}\n// 4\n// 5\n"),s=t("\nfunction* generator() {\n  const list = [1, 2, 3];\n  for (let i of list) {\n    yield i;\n  }\n}\n\nlet g = generator();\nconsole.log(g.next()); // { value: 1, done: false }\nconsole.log(g.next()); // { value: 2, done: false }\nconsole.log(g.next()); // { value: 3, done: false }\nconsole.log(g.next()); // { value: undefined, done: true }\n\nfunction* foo(x) {\n  var y = 2 * (yield x + 1);\n  var z = yield y / 3;\n  return x + y + z;\n}\n\nvar a = foo(5);\nconsole.log(a.next()); // { value: 6, done: false }\nconsole.log(a.next()); // { value: NaN, done: false }\nconsole.log(a.next()); // { value: NaN, done: true }\n\nvar b = foo(5);\nconsole.log(b.next()); // { value: 6, done: false }\nconsole.log(b.next()); // { value: NaN, done: false }\nconsole.log(b.next()); // { value: NaN, done: true }\n"),u=t('\nvar gen = function* gen() {\n  try {\n    yield console.log("a");\n  } catch (e) {\n    console.log(e);\n  }\n  yield console.log("b");\n  yield console.log("c");\n};\n\nvar g = gen();\nconsole.log(g.next()); //a { value: undefined, done: false }\nconsole.log(g.throw()); //undefined b { value: undefined, done: false }\n// g.throw() 方法被【捕获】后会自动执行一次【next】方法，内部部署了【try...catch】，\n// 遍历器的【throw】方法抛出的异常不会影响下次遍历\nconsole.log(g.next()); //b { value: undefined, done: false }\nconsole.log(g.next()); // { value: undefined, done: true }\n'),m=t('\nvar gen = function* gen() {\n  yield console.log("a");\n  yield console.log("b");\n  throw new Error("Generator Error");\n  yield console.log("c");\n};\n\nvar g = gen();\nconsole.log(g.next()); //a { value: undefined, done: false }\nconsole.log(g.next()); //b { value: undefined, done: false }\nconsole.log(g.next()); // Generator Error 后续不会再执行\n'),j=t('\nvar gen = function* gen() {\n  yield 1;\n  yield 2;\n  throw new Error("Generator Error");\n  yield 3;\n};\n\nvar g = gen();\nconsole.log(g.next()); // { value: 1, done: false }\nconsole.log(g.return("return")); // { value: \'return\', done: true }\nconsole.log(g.next()); // { value: undefined, done: true }\n'),b=t("\nfunction longTimeFn(time) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(time);\n    }, time);\n  });\n}\n\n// 自动执行封装，递归回调\nfunction asyncFun(generator) {\n  const iterator = generator(); // 接下里要执行next\n  // data 为第一次执行之后的返回结果，用于传给第二次执行\n  const next = (data) => {\n    // 第一次执行next时，yield 返回的 promise 实例赋值给了value\n    const { value, done } = iterator.next(data);\n    if (done) return;\n    value.then((data) => next(data));\n  };\n  next();\n}\n\n// 生成器函数内自动执行，无需显示next()\n\nasyncFun(function* () {\n  let data = yield longTimeFn(1000);\n  console.log(data);\n  data = yield longTimeFn(1500);\n  console.log(data);\n  return data;\n});\n");return(e,o)=>{const t=Object(c["resolveComponent"])("RouterLink"),V=Object(c["resolveComponent"])("WebPrismEditor");return Object(c["openBlock"])(),Object(c["createElementBlock"])("div",null,[Object(c["createElementVNode"])("h3",Co,[Object(c["createVNode"])(t,{to:"#Generator",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 3、Generator ")]),So,Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Fo,[Object(c["createVNode"])(t,{to:"#Iterator",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、迭代器Iterator ")]),Object(c["createElementVNode"])("section",null,[Object(c["createElementVNode"])("div",null,[Uo,Object(c["createVNode"])(V,{modelValue:Object(c["unref"])(l),"onUpdate:modelValue":o[0]||(o[0]=e=>Object(c["isRef"])(l)?l.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[_o,Object(c["createVNode"])(V,{modelValue:Object(c["unref"])(n),"onUpdate:modelValue":o[1]||(o[1]=e=>Object(c["isRef"])(n)?n.value=e:null)},null,8,["modelValue"]),ko,Object(c["createVNode"])(V,{modelValue:Object(c["unref"])(d),"onUpdate:modelValue":o[2]||(o[2]=e=>Object(c["isRef"])(d)?d.value=e:null)},null,8,["modelValue"]),Ao])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Bo,[Object(c["createVNode"])(t,{to:"#CustomIterator",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 2、自定义迭代器Iterator ")]),Object(c["createElementVNode"])("section",null,[Io,qo,Object(c["createVNode"])(V,{modelValue:Object(c["unref"])(r),"onUpdate:modelValue":o[3]||(o[3]=e=>Object(c["isRef"])(r)?r.value=e:null)},null,8,["modelValue"]),Go,Object(c["createVNode"])(V,{modelValue:Object(c["unref"])(a),"onUpdate:modelValue":o[4]||(o[4]=e=>Object(c["isRef"])(a)?a.value=e:null)},null,8,["modelValue"]),zo,Object(c["createVNode"])(V,{modelValue:Object(c["unref"])(i),"onUpdate:modelValue":o[5]||(o[5]=e=>Object(c["isRef"])(i)?i.value=e:null)},null,8,["modelValue"]),Do])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Jo,[Object(c["createVNode"])(t,{to:"#SubGenerator",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 3、生成器Generator ")]),Object(c["createElementVNode"])("section",null,[Lo,Object(c["createVNode"])(V,{modelValue:Object(c["unref"])(s),"onUpdate:modelValue":o[6]||(o[6]=e=>Object(c["isRef"])(s)?s.value=e:null)},null,8,["modelValue"]),Object(c["createElementVNode"])("div",null,[Mo,Object(c["createVNode"])(V,{modelValue:Object(c["unref"])(u),"onUpdate:modelValue":o[7]||(o[7]=e=>Object(c["isRef"])(u)?u.value=e:null)},null,8,["modelValue"]),Wo,Object(c["createVNode"])(V,{modelValue:Object(c["unref"])(m),"onUpdate:modelValue":o[8]||(o[8]=e=>Object(c["isRef"])(m)?m.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[$o,Ho,Object(c["createVNode"])(V,{modelValue:Object(c["unref"])(j),"onUpdate:modelValue":o[9]||(o[9]=e=>Object(c["isRef"])(j)?j.value=e:null)},null,8,["modelValue"])])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Yo,[Object(c["createVNode"])(t,{to:"#AutoGenerator",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 4、Generator自动执行 ")]),Object(c["createElementVNode"])("section",null,[Object(c["createVNode"])(V,{modelValue:Object(c["unref"])(b),"onUpdate:modelValue":o[10]||(o[10]=e=>Object(c["isRef"])(b)?b.value=e:null)},null,8,["modelValue"])])])])}}});const Xo=Zo;var Ko=Xo;const Qo={class:"main"},et=Object(c["createElementVNode"])("h2",null,"Promise规范和应用",-1);var ot=Object(c["defineComponent"])({__name:"index",setup(e){const o=Object(c["getCurrentInstance"])(),{$builtIn:t}=null===o||void 0===o?void 0:o.appContext.config.globalProperties;return(e,o)=>(Object(c["openBlock"])(),Object(c["createElementBlock"])("div",Qo,[et,Object(c["createVNode"])(p),Object(c["createVNode"])(_),Object(c["createVNode"])(Po),Object(c["createVNode"])(Ro),Object(c["createVNode"])(Ko)]))}});const tt=ot;o["default"]=tt}}]);