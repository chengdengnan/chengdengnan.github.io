(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d216a20"],{c2fa:function(e,t,o){"use strict";o.r(t);var c=o("7a23");const n={id:"This"},l={id:"GlobalFunction"},r=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("this指向全局对象window，"),Object(c["createElementVNode"])("span",{class:"red"},"注意严格模式下"),Object(c["createTextVNode"])("，this为undefined")],-1),d={id:"ObjectMethod"},a=Object(c["createElementVNode"])("p",null,"this指向调用该方法的对象",-1),i={id:"Constructor"},s=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("this指向 "),Object(c["createElementVNode"])("span",{class:"red"},"new 关键字 "),Object(c["createTextVNode"])("创建出的实例")],-1),m={id:"SetTimeout"},u=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("定时器 setTimeout 或 setInterval，以及回调函数或匿名函数自调用，"),Object(c["createElementVNode"])("span",{class:"red"},"this指向全局对象window")],-1),j={id:"EventFunction"},b=Object(c["createElementVNode"])("p",null,"元素绑定事件，事件触发后执行函数，this指向的是当前元素",-1),O={id:"ArrowFunction"},V=Object(c["createElementVNode"])("p",null,"this指向箭头函数定义时所处的对象",-1),p={id:"CallApplyBind"},N=Object(c["createStaticVNode"])('<section><ul type="square"><li> call和apply：<span class="red">改变 this 指向后</span>执行函数。 <ul style="margin-left:1rem;" type="circle"><li>call(thisScope,arg1,arg2,arg...);<span class="red"> 多个参数，第一个参数为null、undefined时，默认指向Window</span></li><li>apply(thisScope,[arg1,arg2,arg...]);<span class="red"> 两个参数</span></li></ul></li></ul><ul type="square"><li>bind: 改变 this 指向后，返回函数，不执行。</li><p>bind(thisScopr,arg1,arg2,arg...) 多个参数</p></ul></section>',1),h=Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("div",{class:"c-h5"},"apply的使用方法(函数劫持、对象复制)"),Object(c["createElementVNode"])("div",{class:"indent"},[Object(c["createElementVNode"])("span",null,[Object(c["createTextVNode"])("可以看到 Student 不具备任何方法，但是在 "),Object(c["createElementVNode"])("span",{class:"red"},"Person.apply(this,arguments)"),Object(c["createTextVNode"])("之后，他就具备了Person类的方法及属性")])]),Object(c["createElementVNode"])("div",null,"由此得出结论： Function.apply() 能“劫持”另外一个对象， 继承另外一个对象的属性")],-1);var v=Object(c["defineComponent"])({__name:"this",setup(e){const t=Object(c["getCurrentInstance"])(),{$builtIn:o}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,v=o("\n// 'not strict' 【window】\nconsole.log(this);\nfunction funs(){\n    console.log(this); \n};\nfuns();\n\n// 'use strict' 【undefined】\nfunction stractDemo(){\n    'use strict'\n    console.log(this);\n};\nstractDemo();\n"),f=o("\nlet name = 'Global Barry';\nlet obj = {\n    name: 'Obj Barry',\n    getName: function(){\n        console.log(this.name)\n    },\n};\nobj.getName(); // 'Obj Barry'\n\nlet funs = obj.getName;\nfuns(); // 'Global Barry'\n"),P=o('\nfunction Barry(){\n    this.name = "Fashion pro Barry";\n    console.log(this);\n}\n\nlet n = new Barry();\nconsole.log(n)\n'),E=o('\n// setTimeout\nsetTimeout(function () {\n    console.log(this)\n}, 0)\n\nvar name = "my name is window"; // 注意var 和 const 输出是不一样的\nvar obj = {\n    name: "my name is obj",\n    funs: function () {\n        let timer = null;\n        clearInterval(timer);\n        timer = setInterval(function () {\n            console.log(this.name); // "my name is window"\n        }, 100);\n    },\n};\nobj.funs();\n\n\n// 回调函数\nvar o = {\n    age: 18,\n    say: function () {\n        function callback() {\n            return this.age;\n        }\n        func(callback);\n    },\n};\nfunction func(callback) {\n    var name = "Fashion Barry";\n    console.log(name, " is", callback() + " years"); \n}\no.say(); // Fashion Barry  is undefined years\n/**\n * 【解析】：\n * 函数内部的【this】指向于此函数的调用者（拥有者）\n * 但在上面这个例子中，为什么会输出unidentified\n * 虽然【callback】定义在对象【o】的【say】方法中，但实际上由于【callback】是在【func】函数中被普通调用的\n * 那么【func】中的【callback】的调用对象我们可以理解为【window】对象\n * 当使用一个对象未定义的属性时不会报错，会返回undefined，而直接使用一个未定义的变量便会报错\n*/\n\n'),y=o('\n<button id="btn">click me</button>\n\nwindow.onload = function () {\n    var btn = document.getElementById("btn");\n    btn.onclick = function () {\n        console.log(this);\n    };\n};\n'),x=o('\nvar name = "my name is window";\nvar obj = {\n    name: "my name is obj",\n    func: function () {\n        return (() => {\n            console.log(this.name); // my name is obj\n        })();\n    },\n};\nobj.func()\n'),T=o('\n// 对象方法:this指向方法前的对象\nvar person = {\n  name: "dog",\n  say: function (language) {\n    console.log(this.name + " say " + language);\n  },\n};\nperson.say("Hello world!");\n\n//call  改变this指向，传入多个参数\nvar name = "duck";\nperson.say.call(window, "Helo Window!");\n\n//apply 改变this指向，两个参数\n// person.say.apply(this, "Hello Apply!"); // 会报错TypeError: CreateListFromArrayLike called on non-object\n\nperson.say.apply(window, { name: "Hello Apply!" }); // nduck say undefined\n// apply 的第二个参数必须为数组\nperson.say.apply(this, ["Hello Apply!"]); // duck say Hello Apply\n\nvar arr = [1, 2, 3, 4];\nMath.max.apply(null, arr); //4, null表示不改变this指向\n\n// bind:改变this指向，不立即调用，而是返回该函数\nfunction multiply(x, y, z) {\n  return x * y * z;\n}\n\nvar double = multiply.bind(null, 2);\nconsole.log(double(3, 4)); // 24\n\nvar person1 = {\n  name: "dog",\n  sayHello: function () {\n    setTimeout(\n      function () {\n        console.log(this.name + " Say Hello!");\n      }.bind(this),\n      1000\n    );\n  },\n};\n\nperson1.sayHello(); //dog Say Hello!\n\n'),g=o('\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayHello = function () {\n    console.log(this.name + " Say hello!");\n  };\n}\n\nfunction Student(name, age, grade) {\n  Person.apply(this, arguments);\n  this.grade = grade;\n}\n\nvar s = new Student("Barry", 18, "middle school");\nconsole.log(s.name); // Barry\nconsole.log(s.age); // 18\nconsole.log(s.grade); //middle school\ns.sayHello(); // Barry Say hello!\n'),w=o("\n// 面试题解析\nvar x = 20;\nvar a = {\n  x: 15,\n  fn: function () {\n    var x = 30;\n    return function () {\n      return this.x;\n    };\n  },\n};\n\nconsole.log(a.fn()); // Function ƒ(){return this.x}\nconsole.log((a.fn())()); // 20 a.fn()返回的是一个函数，()()这是自执行表达式。this -> window\nconsole.log(a.fn()()); // 20 a.fn()相当于在全局定义了一个函数，然后再自己调用执行。this -> window\nconsole.log(a.fn()() == (a.fn())()); //true\nconsole.log(a.fn().call(this)); // 20 这段代码在全局环境中执行，this -> window\nconsole.log(a.fn().call(a)); // 15, 更改this指向为 a，a的x为15\n\n");return(e,t)=>{const o=Object(c["resolveComponent"])("RouterLink"),R=Object(c["resolveComponent"])("WebPrismEditor");return Object(c["openBlock"])(),Object(c["createElementBlock"])("div",null,[Object(c["createElementVNode"])("h3",n,[Object(c["createVNode"])(o,{to:"#This",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、This指向 ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",l,[Object(c["createVNode"])(o,{to:"#GlobalFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、全局函数 ")]),Object(c["createElementVNode"])("section",null,[r,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(v),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(c["isRef"])(v)?v.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",d,[Object(c["createVNode"])(o,{to:"#ObjectMethod",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、对象方法 ")]),Object(c["createElementVNode"])("section",null,[a,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(f),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(c["isRef"])(f)?f.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",i,[Object(c["createVNode"])(o,{to:"#Constructor",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、构造函数 ")]),Object(c["createElementVNode"])("section",null,[s,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(P),"onUpdate:modelValue":t[2]||(t[2]=e=>Object(c["isRef"])(P)?P.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",m,[Object(c["createVNode"])(o,{to:"#SetTimeout",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、定时器、回调函数 ")]),Object(c["createElementVNode"])("section",null,[u,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(E),"onUpdate:modelValue":t[3]||(t[3]=e=>Object(c["isRef"])(E)?E.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",j,[Object(c["createVNode"])(o,{to:"#EventFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、事件函数 ")]),Object(c["createElementVNode"])("section",null,[b,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(y),"onUpdate:modelValue":t[4]||(t[4]=e=>Object(c["isRef"])(y)?y.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",O,[Object(c["createVNode"])(o,{to:"#ArrowFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("6、箭头函数 ")]),Object(c["createElementVNode"])("section",null,[V,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(x),"onUpdate:modelValue":t[5]||(t[5]=e=>Object(c["isRef"])(x)?x.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",p,[Object(c["createVNode"])(o,{to:"#CallApplyBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("7、call、apply、bind ")]),Object(c["createElementVNode"])("section",null,[N,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(T),"onUpdate:modelValue":t[6]||(t[6]=e=>Object(c["isRef"])(T)?T.value=e:null)},null,8,["modelValue"]),h,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(g),"onUpdate:modelValue":t[7]||(t[7]=e=>Object(c["isRef"])(g)?g.value=e:null)},null,8,["modelValue"]),Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(w),"onUpdate:modelValue":t[8]||(t[8]=e=>Object(c["isRef"])(w)?w.value=e:null)},null,8,["modelValue"])])])])}}});const f=v;var P=f;const E={id:"Promise"},y={id:"Reference"},x=Object(c["createStaticVNode"])('<section><div><span>1.</span><a target="_blank" rel="help" href="http://liubin.org/promises-book/" class="a-navigation">JavaScript Promise迷你书(中文版)</a></div><div><span>2.</span><a target="_blank" href="https://juejin.cn/post/6844903455962693640" class="a-navigation">深入理解Promise(上)</a></div><div><span>3.</span><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903667494027278">从手写一个符合Promise/A+规范Promise来深入学习Promise</a></div><div><span>4.</span><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903550288412679">Promise深度学习---我のPromise/A+实现 </a></div><div><span>5.</span><a target="_blank" class="a-navigation" href="https://mp.weixin.qq.com/s/Yrwe2x6HukfqJZM6HkmRcw">【第1738期】100 行代码实现 Promises/A+ 规范</a></div><div><span>6.</span><a target="_blank" class="a-navigation" href="https://zhuanlan.zhihu.com/p/144058361">从零开始手写Promise </a></div><div><span>7.</span><a target="_blank" class="a-navigation" href="https://blog.csdn.net/weixin_56650035/article/details/121070438?spm=1001.2014.3001.5502">PromiseA+规范之手写Promise </a></div></section>',1),T={id:"ConstructorStatus"},g=Object(c["createElementVNode"])("div",{class:"c-h5"},"1. 构造函数",-1),w=Object(c["createStaticVNode"])('<section><div class="c-h5">2. 状态</div><section><ul><li>初始状态 -&gt; pending <ul type="cricle" class="ml-15"><li>初始状态可以改变</li><li>在resolve 或者 reject 调用之前都处于这个状态</li></ul></li><li>最终成功状态 -&gt; fulfilled <ul type="cricle" class="ml-15"><li>执行 resolve 函数，状态改变为 fulfilled</li><li>执行 onFulfilled 函数</li></ul></li><li>最终失败状态 -&gt; rejected <ul type="cricle" class="ml-15"><li>执行 reject 函数，状态改变为 rejected</li><li>执行 onRejected 函数</li></ul></li><li>then 方法 <ul type="cricle" class="ml-15"><li>then 方法为 Promise 对象注册了 onFulfilled 和 onRejected 函数</li></ul></li><li>catch 方法 <ul type="cricle" class="ml-15"><li>catch 方法为Promise 对象注册了 onRejected 函数</li></ul></li></ul></section></section>',1),R={id:"NineMethods"},k=Object(c["createElementVNode"])("div",{class:"c-h5"}," 1. Promise.resolve",-1),S=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])("静态方法"),Object(c["createElementVNode"])("code",null,"Promise.resolve(value)"),Object(c["createTextVNode"])("可以认为是"),Object(c["createElementVNode"])("code",null,"new Promise"),Object(c["createTextVNode"])("方法的语法糖,比如"),Object(c["createElementVNode"])("code",null,"Promise.resolve(42)"),Object(c["createTextVNode"])(" 可以认为是以下代码的语法糖 ")],-1),A={class:"indent"},C=Object(c["createElementVNode"])("code",null,"Promise",-1),_=Object(c["createElementVNode"])("code",null,"onFulfilled",-1),F=Object(c["createElementVNode"])("code",null,"new Promise",-1),U=Object(c["createElementVNode"])("code",null,"Promise",-1),B=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])(" 简单总结一下 "),Object(c["createElementVNode"])("code",null,"Promise.resolve"),Object(c["createTextVNode"])("方法的话，它的作用就是将传递给它的参数填充 "),Object(c["createElementVNode"])("code",null,"Fulfilled"),Object(c["createTextVNode"])(" 到 "),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])(" 对象后并返回这个 "),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])(" 对象。 ")],-1),H=Object(c["createElementVNode"])("div",{class:"c-h5"},"2. Promise.reject",-1),q=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createElementVNode"])("code",null,"Promise.reject(error)"),Object(c["createTextVNode"])("是和"),Object(c["createElementVNode"])("code",null,"Promise.resolve(value)"),Object(c["createTextVNode"])("类似的静态方法，是 "),Object(c["createElementVNode"])("code",null,"new Promise"),Object(c["createTextVNode"])(" 方法的快捷方式。比如 "),Object(c["createElementVNode"])("code",null,'Promise.reject(new Error("Promise reject error"))'),Object(c["createTextVNode"])(" 就是下面代码的语法糖形式 ")],-1),I=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])(" 简单总结一下 "),Object(c["createElementVNode"])("code",null,"Promise.reject"),Object(c["createTextVNode"])("方法的话：它的功能是调用该 "),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象通过then指定的 "),Object(c["createElementVNode"])("code",null,"onRejected"),Object(c["createTextVNode"])("函数，并讲错误（Error）对象传递给这个"),Object(c["createElementVNode"])("code",null,"onRejected"),Object(c["createTextVNode"])("函数 ")],-1),G=Object(c["createElementVNode"])("div",{class:"c-h5"},"3. Promise.then",-1),M=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"Promise.then(onFulfilled, onRejected)")],-1),L=Object(c["createElementVNode"])("div",{class:"c-h6"},"① 函调函数异步执行",-1),J=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"Promise/A+规范"),Object(c["createTextVNode"])("统一规定：Promise 只能使用异步调用方式 ")],-1),z=Object(c["createStaticVNode"])('<div class="c-h6">② 返回值</div><p class="indent">不管你在回调函数 <code>onFulfilled</code>中会返回一个什么样的值，或者不返回值，该值都会由 <code>Promis.resolve(return 的返回值)</code> 进行响应的包装处理。因此，最终 <code>then</code>的结果都是返回一个新创建的 <code>Promise</code>对象。 </p><p class="indent"> 也就是说，<code>Promis.then</code>不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个<code>Promise</code> 对象。正是 <code>then</code>函数中有了这样返回值的机制，才能使得在整个<code>Promise</code>链式结构当中，每个<code>then</code>方法都能给 下一个<code>then</code>方法传递参数。现在我们知道怎么返回的<code>Promise</code>是之前的还是新的？另外该<code>Promise</code>的状态又是如何？ </p>',3),W=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("从上面结果来看，实际上不管是调用 "),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("还是"),Object(c["createElementVNode"])("code",null,"catch"),Object(c["createTextVNode"])("方法， 都返回了一个新的"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象")],-1),D=Object(c["createElementVNode"])("div",{class:"c-h6 red"},"③ promise穿透",-1),$=Object(c["createElementVNode"])("p",null,"我们先来举个例子：",-1),Y=Object(c["createElementVNode"])("p",null,"如果你认为输出的是【 Barry Promise 】，那么你就错了，实际上他输出的是 【 Barry 】",-1),Z=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("产生这么的输出是因为你给"),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("方法传递了一个非函数(比如"),Object(c["createElementVNode"])("code",null,"promise"),Object(c["createTextVNode"])("对象)的值，代码会这样理解 : "),Object(c["createElementVNode"])("code",null,"then(null)"),Object(c["createTextVNode"])(",因此导致了前一个"),Object(c["createElementVNode"])("code",null,"promise"),Object(c["createTextVNode"])("的结果产生了坠落的效果，也就是和下面代码是一样的， 代码直接穿透了"),Object(c["createElementVNode"])("code",null,"then(null)"),Object(c["createTextVNode"])("进入了下一层链： ")],-1),K=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("随意添加多个"),Object(c["createElementVNode"])("code",null,"then(null)"),Object(c["createTextVNode"])("结果都是一样的")],-1),Q=Object(c["createElementVNode"])("div",{class:"c-h5"},"4. Promise.catch",-1),X=Object(c["createElementVNode"])("div",{class:"c-h6"},"① 语法糖的本质",-1),ee=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])(" 这里我们再说一遍，实际上"),Object(c["createElementVNode"])("code",null,"Promise.catch"),Object(c["createTextVNode"])("只是"),Object(c["createElementVNode"])("code",null,"promise.then(undefined, onRejected)"),Object(c["createTextVNode"])(" 方法的一个别名而已。也就是说，这个方法用来注册当"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象状态变为 "),Object(c["createElementVNode"])("code",null,"Rejected"),Object(c["createTextVNode"])("时 的回调函数。可以看下面代码，两者写法是等价的，但是很明显 "),Object(c["createElementVNode"])("code",null,"Promise.catch"),Object(c["createTextVNode"])("会让人第一眼看上去不会眼花缭乱: ")],-1),te=Object(c["createStaticVNode"])("<p>那么我们现在来说说为什么推荐使用第二种方法，而不是第一种:</p><div><ul><li>使用<code>promise.then(onFulfilled, onRejected)</code> 的话，在<code>onFulfilled</code>中发生异常的话，<code>onRejected</code> 中是捕获不到这个异常的。而且如果链式很长，每一条链上都要这么写。 </li><li> 在<code>promise.then(onFulfilled).catch(onRejected)</code> 的情况下<code>.then</code>中产生异常能在<code>.catch</code> 中捕获。<code>.then</code>和<code>.catch</code>本质上是没有区别的， 需要分场合使用 </li></ul></div>",2),oe=Object(c["createStaticVNode"])('<div class="c-h6">② 只有一个主人</div><p class="indent">我们上面已经说过了，在书写很长的<code>Promise</code>链式，从代码清晰度和简易程度来讲，在最后添加 <code>catch</code>是远远在每一层链上写<code>onRejected</code>回调函数是要好的，因为<code>catch</code>可以捕获 <code>Promise</code>链中每一层节点的错误，这句话本身没有错，但从这句话延伸出一种错误的理解：<code>catch</code> 同时监控着所有节点。实际上<code>catch</code>函数在同一个时间点只属于某一个<code>Promise</code>，因为它的主人是随着程序 的执行而不断变化的，我们来举个例子： </p>',2),ce=Object(c["createStaticVNode"])("<p>在上述例子中，如果整个程序每一步都正确执行，那么会顺序产生三个<code>Promise</code>对象，分别是 <code>Promise(1)</code>,<code>Promise(2)</code>,<code>Promise(3)</code>: </p><ul><li>可是如果在第一层具体执行逻辑出错了后，那实际上后面的两个<code>then</code> 中的回调函数压根不会被异步执行，所以会直接异步触发<code>catch</code>中的回调函数执行， 所以这种情况下<code>catch</code>是<code>Promise(1)</code>对象的<code>catch</code>。 </li><li> 如果第一层具体执行逻辑正确执行，就会异步触发第二个<code>then</code>中的回调函数执行，那么同理 ，在第二次具体执行逻辑抛出错误，会导致<code>Promise(2)</code>的状态变化，所以这种情况下<code>catch</code> 是<code>Promise(2)</code>对象的<code>catch</code>。 </li><li>同理<code>Promise(3)</code>也是如此</li></ul><p>总结下来就是：整个<code>Promise</code>链中，<code>catch</code>只属于异步触发它当中回调函数 执行的那个<code>Promise</code>，并不属于所有 <code>Promise</code></p>",3),ne=Object(c["createStaticVNode"])('<div class="c-h5">5. Promise.finally</div><p class="indent"><code>promise.finally</code>方法的回调函数不接受任何参数，这意味着<code>finally</code>没有办法 知道，前面的<code>Promise</code>状态到底是<code>fulfilled</code>还是<code>rejected</code> 。这表明，<code>finally</code>方法里面的操作，应该是与<code>Promise</code>状态无关的，不依赖于 <code>Promise</code>的执行结果。我们来看下面代码： </p>',2),le=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"finally"),Object(c["createTextVNode"])("本质上是"),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("方法的特例。我们来看下面伪代码：")],-1),re=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("上面代码中，如果不使用"),Object(c["createElementVNode"])("code",null,"finally"),Object(c["createTextVNode"])("方法，同样的语句需要为成功和失败的状态各写一次。 有了"),Object(c["createElementVNode"])("code",null,"finally"),Object(c["createTextVNode"])("方法，则只需要写一次。那么它是如何实现的呢？ ")],-1),de=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("上述代码中，不管前面的"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("是"),Object(c["createElementVNode"])("code",null,"fulfilled"),Object(c["createTextVNode"])("还是"),Object(c["createElementVNode"])("code",null,"rejected"),Object(c["createTextVNode"])(" ，都会执行回调函数"),Object(c["createElementVNode"])("code",null,"callback")],-1),ae=Object(c["createStaticVNode"])('<div class="c-h5">6. Promise.all</div><p class="indent"><code>Promise.all</code>接受一个<code>promise</code>对象的数组作为参数，当这个数组里的所有 <code>Promise</code> 对象 全部变为<code>resolve</code>或者<code>reject</code>状态的时候，它才会去调用<code>.then</code>方法。 </p><p class="indent"> 传递给<code>Promise.all</code>的 <code>promise</code>并不是一个个的顺序执行的，而是同时开始、并行执行的，我们可以看下面例子 </p>',3),ie=Object(c["createStaticVNode"])('<p>为什么这个例子可以看出来<code>Promise.all()</code>是并行的呢？因为所有<code>Promise</code>执行完只用了5秒，如果3个 <code>Promise</code>是按照顺序执行的，那么应该是9秒或者，在5-9之间，因为4个<code>Promise</code>并不是同时执行的，同时执行的 话总时间就是那个花费时间最长的<code>Promise</code></p><p><code>Promise.all()</code>重要细节点 <span class="red">（面试常考）</span>：</p><div><ul><li> 如果所有的<code>Promise</code>中只有一个执行错误，那么整个<code>Promise.all</code>不会走<code>Promise.all().then()</code> 而是走<code>Promise.all().catch()</code>这个流程了。但是要注意的是虽然走到了<code>Promise.all().catch()</code>这个流程 ，<span class="red">但是其他<code>Promise</code>还是会正常执行，但不会返回结果</span></li><li> 要注意<code>Promise.all()</code>的返回值顺序，<code>Promise.all().then()</code>的返回值顺序和传入的顺序是一致的，笔试时 遇到手写<code>Promise.all()</code>时要注意 </li></ul></div>',3),se=Object(c["createStaticVNode"])('<div class="c-h5">7. Promise.allSettled</div><p><code>Promise.allSettled()</code>的入参和<code>Promise.all、Promise.race</code>一样，接受一个<code>promise</code> 对象的数组作为参数,也是同时开始、并行执行的。但是<code>Promise.allSettled</code>的返回值需要注意以下几点： </p><p><code>Promise.allSettled</code>不会走进catch，当所有输入<code>Promise</code>都被履行或者拒绝时，<code> statusesPromise </code>会解析一个具有具体完成状态的数组 </p><div><ul><li><code>{ status: &#39;fulfilled&#39;, value:value } </code>：如果相应的<code>promise</code>被履行</li><li><code>{ status: &#39;rejected&#39;, reason: reason }</code>：如果相应的<code>promise</code>被拒绝</li></ul></div><p>我们看下面示例:</p>',5),me=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("总结一下："),Object(c["createElementVNode"])("code",null,"Promise.allSettled()"),Object(c["createTextVNode"])("在你需要执行平行和独立的异步操作并收集所有结果时非常有效， 即使某些异步操作可能失败。")],-1),ue=Object(c["createStaticVNode"])('<div class="c-h5">8. Promise.race</div><p class="indent"><code>Promise.rece()</code>的使用方法和 <code>Promise.all</code>一样，接收一个<code>promise</code> 对象的数组为参数，<code>Promise.race</code>是要有一个promise对象进入<code>Fulfilled</code>或者 <code>Rejected</code>状态的话，就会继续进行后面的处理。这里依旧有两个点要注意： </p><div><ul><li>和<code>Promise.all</code>一样是所有数组当中的<code>Promise</code>同时并行的</li><li><code>Promise.race</code> 在第一个<code>Promise</code>对象变为<code>Fulfilled</code>之后，并不会 取消其他<code>promise</code>对象的执行。</li><li><code>Promise.race</code>接受的是一个<code>Promise</code>对象数组，但是返回的确实最先完成<code>Fulfilled</code> 或者最先被<code>Rejected</code>的一个Promise的结果 </li></ul></div><p>下面我们来举个例子：</p>',4),je=Object(c["createStaticVNode"])("<p>这里我们再复习一下<code>Node</code>当中事件循环的知识：</p><div><ul><li>第一层循环：i为0时，异步触发了<code>Promise.race().catch()</code>，这里面的回调代码被放在了微任务队列中， 后面的3个<code>setTimeout</code>宏任务的回调函数代码被放进了<code>timer</code>阶段中的队列当中(其实并不是这样，因为 三个定时器都有延迟，都是在后面的事件循环中添加进来的) </li><li>第二层循环：清空微任务对列，所以控制台打印出了错误，然后清空宏任务，分别打印出<code>3000/5000/7000</code></li></ul></div>",2),be=Object(c["createStaticVNode"])('<div class="c-h5">9. Promise.any</div><p><code>Promise.any</code>的入参和<code>Promise.all、Promise.race、Promise.allSettled</code>一样， 接收一个<code>promise</code>对象的数组作为参数。 </p><div><ul><li>只要其中有一个<code>Promise</code>成功执行，就会返回已经成功执行的<code>Promise</code>的结果</li><li>如果这个<code>promise</code>对象的数组中没有一个<code>promise</code> 可以成功执行（即所有的 <code>promise</code>都失败 ），就返回一个失败的<code>promise</code> 和<code>AggregateError</code>类型的实例，它是<code>Error</code>的一个子类，用于把单一的错误集合 在一起 </li></ul></div>',3),Oe=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])(" 总计一下"),Object(c["createElementVNode"])("code",null,"Promisea.any"),Object(c["createTextVNode"])("的应用场景：如果我们现在有多台服务器，则尽量使用响应速度最快的服务器，在这种情况下， 可以使用"),Object(c["createElementVNode"])("code",null,"Promise.any()"),Object(c["createTextVNode"])("方法从最快的服务器接收响应。 ")],-1),Ve={id:"ErrorCapture"},pe=Object(c["createStaticVNode"])('<div class="c-h5">1. 使用reject而不是throw</div><p class="indent"> 在最开始我们先来一句比较重要的话：<code>Promise</code>的构造函数，以及被<code>then</code>调用执行的函数基本上都可以认为是 在<code>try...catch</code>代码块中执行的，所以在这些代码中即使使用<code>throw</code>，程序本身也不会异常而终止。 </p><p class="indent"> 所以其实如果在<code>Promise</code>中使用<code>throw</code>语句的话，会被<code>try...catch</code>住，最终<code>Promise</code> 对象也会变为<code>Rejected</code>状态。但是我们为什么还是推荐使用<code>Promise.reject</code>呢？有下面两个原因： </p><div><ul><li>我们很难区分<code>throw</code>是我们主动抛出来的，还是因为真正的其他异常导致的，无法主动决定，属于被动。</li><li><code>Promise</code>构造函数当中通过<code>throw</code>抛出来的错误未必会被<code>Promise.catch</code> 捕获到 </li></ul></div><p>下面我们就说说什么时候通过<code>throw</code>抛出的错误未必会被<code>Promise.catch</code>捕获到：</p>',5),Ne=Object(c["createStaticVNode"])("<p>这个例子非常典型，想知道为什么错误没有被<code>catch</code>住，我们要到推出原因：</p><div><ul><li>首先我们要明确的是，不论是<code>then</code>还是<code>catch</code>中注册的回调函数，都是由<code>Promise</code> 状态的变化触发的，现在也就说<code>Promise</code>状态始终在<code>pending</code>状态。 </li><li> 其次，前面不是说<code>reject</code>和<code>throw</code>都能最终让<code>Promise</code>进入<code>onReject</code> 状态，这里的<code>throw</code>为什么没有改变<code>Promise</code>的状态。 </li><li> 原因还是要从事件循环来说，我们好好想想，这段代码在第一轮的事件循环当中<code>setTimeout</code>的回调函数被放在了 <code>timer</code>阶段的队列当中，但是它没有执行啊，所以第一轮的<code>Promise</code>状态一直处于<code>pending</code> ，所以<code>then</code>和<code>catch</code>部分的代码全部没有触发，也就在第一轮事件循环当中跳过了。然后在第二轮 循环当中才执行了<code>throw</code>语句，把错误直接抛到了全局，就直接报错。所以上面的代码和下面效果一样，catch怎么可能 捕获到在它后面执行的代码呢？ </li></ul></div>",2),he=Object(c["createStaticVNode"])('<div class="c-h5">2. 在then中进行reject</div><p class="indent">如果我们想在<code>then</code>当中使用<code>reject</code>，首先我们要懂两个知识点：</p><div><ul><li><code>then</code>中的回调函数中，<code>return</code>的返回值类型不光是简单的字面值，还可以是复杂的对象类型， 比如<code>Promise</code>对象等。 </li><li> 只要修改这个返回的<code>Promise</code>的状态，在下一个<code>then</code>中注册的回调函数中的<code>onFulfilled</code> 和<code>onRejected</code>的哪一个会被调用也是能确定的 </li></ul></div><p>所以我们可以这样写代码就能在<code>then</code>当中使用<code>reject</code>:</p>',4),ve=Object(c["createElementVNode"])("p",null,"当然还能更简洁一些：",-1),fe={id:"ReturnValue"},Pe=Object(c["createStaticVNode"])("<p>关于返回值的知识其实我们在前面都已经讲过，这里总结一下并举个例子巩固一下：</p><div><ul><li><code>Promise</code>会将最后的值存储起来，如果在下次使用<code>Promise</code>方法的时候，会直接返回该值 的<code>Promise</code></li><li><code>Promise</code>能够链式调用的原因是因为它的每一个方法都返回新的<code>Promise</code> ，哪怕是<code>finally</code>方法，特殊的是<code>finally</code>会返回上一个<code>Promise</code>的值 包装成新的<code>Promise</code>，并且<code>finally</code>也不接受参数，因为无论<code>Promise</code>是 <code>reject</code>还是<code>fulfill</code>它都会被调用 </li></ul></div><p>下面我们举个例子：</p>",3),Ee=Object(c["createStaticVNode"])("<p>这个例子也很经典，即使你已经搞清楚了上面的知识点，面对这个例子也还是会蒙掉，我们来说一下：</p><div><ul><li>首先通过构造函数创建了一个<code>Promise</code>，我们这里称之为<code>Promise_1</code> ，通过<code>reject</code>进入<code>catch</code>函数，然后注意，<code>catch</code>的回调 函数返回了一个2，实际上这里是返回了一个新的<code>Promise</code>，我们这里称之为<code> Promise_2 </code>，它的状态是<code>fulfilled</code>。 </li><li> 所以这里很迷惑人的一点就是<code>p1</code>最开始是指向<code>Promise_1</code>的，当 <code>Promise_2</code>返回的时候，它又指向了<code>Promise_20</code></li><li> 最后定时器经过一秒打印出2，因为<code>Promise_2</code>在被返回的时候就是<code>fulfilled</code> 状态，<code>then</code>函数当中的回调函数自然而然的被异步触发。 </li></ul></div>",2),ye={id:"Async"},xe=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"co"),Object(c["createTextVNode"])("模块的语法糖（用于 "),Object(c["createElementVNode"])("code",null,"Generator"),Object(c["createTextVNode"])(" 函数的自动执行）")],-1),Te=Object(c["createStaticVNode"])('<p>资料</p><div><ul type="square"><li><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903457170653198">深入理解 ES7 的 async/await </a></li><li><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903767129718791">async/await 优雅的错误处理方法 </a></li><li><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903860079738887">如何在 JS 循环中正确使用 async 与 await </a></li></ul></div><p>参考总结：</p><div><ul><li> 如果一个函数通过<code>async</code>来声明，则一定可以通过<code>await</code>关键字来取到该函数 的返回值。 </li><li> 如果一个函数通过<code>async</code>来声明，则一定也可以通过<code>.then()</code>方法来取到该函数 返回的<code>Promise</code>中的值(因为<code>async</code>声明的函数，<code>return</code>出来的 结果一定是<code>Promise</code>对象 ) </li><li> 如果一个函数没有通过<code>async</code>来声明，但只要<code>return</code>出来一个<code>Promise</code>， 也可以通过<code>.then()</code>拿到里面的值(因为没有<code>async/await</code>的年代就是这样做的 )。 </li><li> 如果一个函数通过<code>async</code>声明，则在该函数内部可以使用<code>await</code>，也可以使用<code>.then()</code>。这表明， </li><li> 如果一个函数没有通过<code>async</code>声明，则在该函数内部不可以使用<code>await</code>， 但是可以使用<code>.then()</code>。 </li></ul></div>',4),ge=Object(c["createElementVNode"])("div",{class:"c-h5"},"1. 语法糖",-1),we=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("关键词是添加在函数定义之前的，一个"),Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("函数是定义会返回"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])(" 函数的简便写法。 ")],-1),Re=Object(c["createElementVNode"])("p",null,"比如：以下两个定义是有效的",-1),ke=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("相似的，会抛出错误的"),Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("函数等效于返回失败的"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("的函数")],-1),Se=Object(c["createElementVNode"])("div",{class:"c-h5"},"2. async函数的返回值",-1),Ae=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("其实"),Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("返回值有下面这四种情况：")],-1),Ce=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])("① 返回值是"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象")],-1),_e=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("这种情况是最常见，也是符合"),Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("定义的")],-1),Fe=Object(c["createElementVNode"])("p",{class:"indent"},"② 返回值是普通值",-1),Ue=Object(c["createStaticVNode"])("<p>如果<code>return</code>出来一个普通值，会被包装成一个<code>Promise</code>对象。该<code>Promise</code> 状态为<code>fulfilled</code>，该<code>Promise</code>的值为该简单值。可以使用<code>.then()</code> 方法取到该<code>Promise</code>对象的值(该值就是 <code>async</code>声明的函数返回来的简单值 )。</p>",1),Be=Object(c["createElementVNode"])("p",{class:"indent"},"③ 返回值是Error类型",-1),He=Object(c["createStaticVNode"])("<p>如果<code>return</code>出来是一个<code>Error</code>类型，则同样会被包装成一个<code>Promise</code>对象， 该<code>Promise</code>对象的状态是<code>reject</code>，值是<code>Error</code>的信息，想取出来该<code>Promise</code> 的报错信息，可以通过<code>.then()</code>的第二个参数，或者通过<code>.catch</code>方法。 </p>",1),qe={id:"Await"},Ie={id:"AsyncAwaitErrorCatch"},Ge={id:"AsyncAwaitLoop"};var Me=Object(c["defineComponent"])({__name:"promise",setup(e){const t=Object(c["getCurrentInstance"])(),{$builtIn:o}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,n=o("\nvar promise = new Promise(function (resolve, reject) {\n  // 异步处理\n  // 处理结果成功调用 resolve\n  // 失败调用 reject\n});\n"),l=o("\nnew Promise(function (resolve) {\n    resolve(42)\n})\n"),r=o('\nnew Promise(function (reject) {\n    reject(new Error("Promise reject error"))\n})\n'),d=o('\nvar promise = new Promise((resolve, reject) => {\n  console.log("inner Promise"); // 1\n  setTimeout(() => {\n    resolve("Fashion Barry"); // 3\n  }, 1000);\n});\n\npromise.then((res) => {\n  console.log("res", res);\n});\nconsole.log("outer promise"); // 2\n// Promise 实际是一个同步函数，then 方法才是异步\n// 所以输出顺序如上\n'),a=o('\nvar aPromise = new Promise((resolve, reject) => {\n  resolve("aPromise");\n});\nvar thenPromise = aPromise.then((res) => {\n  console.log("thenPromise: ", res);\n});\nvar catchPromise = aPromise.catch((err) => {\n  console.error("catchPromise: ", err);\n});\n\nconsole.log(aPromise !== thenPromise); // true\nconsole.log(thenPromise !== catchPromise); // true\nconsole.log(aPromise, thenPromise, catchPromise); // Promise { "aPromise" }, Promise { <pending> }, Promise { <pending> }\n'),i=o('\nPromise.resolve("Barry")\n.then(Promise.resolve("Barry Promise"))\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),s=o('\nPromise.resolve("Barry")\n.then(null)\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),m=o('\nPromise.resolve("Barry")\n.then(null)\n.then({ name: "My name is Barry" })\n.then(null)\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),u=o("\n// 第一种写法\nPromise.resolve()\n  .then((data) => console.log(data))\n  .then(undefined, (err) => console.log(err));\n\n// 第二种写法\nPromise.resolve()\n  .then((data) => console.log(data))\n  .catch((err) => console.log(err));\n"),j=o('\nlet p1 = new Promise((resolve, reject) => {\n  // 第一层执行逻辑\n  resolve("first promise"); // Promise(1)\n})\n  .then((res) => {\n    // 第二层执行逻辑\n    return "second promise"; // Promise(2)\n  })\n  .then((res) => {\n    // 第三层执行逻辑\n    return "third promise"; // Promise(3)\n  })\n  .catch((err) => {\n    console.log("err", err);\n  });\n'),b=o('\nvar p1 = new Promise((resolve, rejevt) => {\n  setTimeout(() => {\n    resolve;\n  }, 1000);\n});\n\np1.then((res) => console.log(res))\n  .catch((err) => console.log(err))\n  .finally(() => console.log("finally"));\n'),O=o("\npromise.finally(() => {\n  // 执行逻辑\n});\n// 上面代码等同于下面\npromise.then(\n  (onFulilled) => {\n    // 语句\n    return onFulilled;\n  },\n  (onRejected) => {\n    // 语句\n    throw onRejected;\n  }\n);\n"),V=o('\nPromise.prototype.finally = function (callback) {\n  let p = this.constructor;\n  return this.then(\n    (value) => p.resolve(callback()).then(() => value),\n    (reason) =>\n      p.reject(callback()).then(() => {\n        throw reason;\n      })\n  );\n};\n\nvar p = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    reject("Promise err");\n  }, 1000);\n});\np.catch((err) => console.log("err", err)).finally(() => {\n  console.log("finally");\n});'),p=o('\nvar promise1 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise1--3000");\n  }, 3000);\n});\nvar promise2 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise2--1000");\n  }, 1000);\n});\nvar promise3 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise3--5000");\n  }, 5000);\n});\n\nvar promiseArr = [promise1, promise2, promise3];\nconsole.time("promiseArr");\nPromise.all(promiseArr)\n  .then((res) => {\n    console.log("res", res); // [\'promise1--3000\', \'promise1--1000\', \'promise1--5000\']\n    console.timeEnd("promiseArr"); // 5523.29296875 ms\n  })\n  .catch((err) => console.log(err));\n'),N=o('\nlet arr = [1000, 3000, 5000, 7000];\nlet promiseArr = [];\n\nfor (let i = 0; i < arr.length; i++) {\n  let newPromise = new Promise((resolve, reject) => {\n    if (i === 0) {\n      reject(new Error("第二个错误"));\n    } else {\n      setTimeout(() => {\n        console.log(arr[i]);\n        resolve(arr[i]);\n      }, arr[i]);\n    }\n  });\n  promiseArr.push(newPromise);\n}\n\nPromise.race(promiseArr)\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n\n// 控制台报错\n// 3000\n// 5000\n// 7000\n'),h=o('\nvar promise1 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    reject(new Error("promise1--3000"));\n    // resoleve("promise1--3000");\n  }, 3000);\n});\nvar promise2 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // reject(new Error("promise1--1000"))\n    resoleve("promise2--1000");\n  }, 1000);\n});\nvar promise3 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise3--5000");\n    // reject(new Error("promise1--5000"))\n  }, 5000);\n});\nvar promiseArr = [promise1, promise2, promise3];\nconsole.time("promiseArr");\nPromise.allSettled(promiseArr)\n  .then((res) => {\n    console.log("res", res);\n    console.timeEnd("promiseArr");\n  })\n  .catch((err) => console.error(err))\n  .finally(() => console.log("finally"));\n'),v=o('\nvar promise1 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // reject(new Error("promise1--3000"));\n    resoleve("promise1--3000");\n  }, 3000);\n});\nvar promise2 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // reject(new Error("promise2--1000"))\n    resoleve("promise1--1000");\n  }, 1000);\n});\nvar promise3 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // resoleve("promise3--5000");\n    reject(new Error("promise1--5000"))\n  }, 5000);\n});\nvar promiseArr = [promise1, promise2, promise3];\nconsole.time("promiseArr");\nPromise.any(promiseArr)\n  .then((res) => {\n    console.log("res", res); // res promise1--1000\n    console.timeEnd("promiseArr");\n  })\n  .catch((err) => console.error(err)); \n  //所有的Promise都失败， AggregateError: All promises were rejected\n'),f=o('\nvar p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    throw new Error("async error");\n  }, 500);\n});\n\np1.then((res) => {\n  console.log("res--", res);\n}).catch((err) => {\n  console.error("err--", err);\n});\n// 会直接报错，不会走到 catch\n'),P=o("\nvar p1 = new Promise(function(resolve, reject) {\n})\n.then(res => {\n})\n.catch(err => {\n})\nthrow Error('async error')   "),Me=o('\nvar onRejected = console.error.bind(console);\nvar promise = Promise.resolve();\npromise\n  .then(() => {\n    var retPromise = new Promise(function (resolve, reject) {\n      reject(new Error("this promise is rejected"));\n    });\n    return retPromise;\n  })\n  .catch(onRejected);\n'),Le=o('\nvar promise = Promise.resolve();\npromise\n  .then(function () {\n    return (retPromise = Promise.reject(\n      new Error("this promise is rejected")\n    ));\n  })\n  .catch((err) => console.error("err", err));\n'),Je=o('\nvar p1 = new Promise((resolve, reject) => {\n  reject("p1");\n}).catch((err) => {\n  console.error("err", err);\n  return "p2";\n});\n\nsetTimeout(() => {\n  p1.then((res) => console.log(res));\n}, 1000);\n// 先打印出error 1\n// 1秒钟以后打印出 P2\n'),ze=o('\n(function* () {\n  var f1 = yield readFile("/etc/fstab");\n  var f2 = yield readFile("/etc/shells");\n  console.log(f1.toString());\n})();\n'),We=o('\nfunction f() {\n  return Promise.resolve("TEST");\n}\n\n// asyncF is equivalent to f!\nasync function asyncF() {\n  return "Test";\n}\n// console.log(f());\n// console.log(asyncF());\n'),De=o('\nfunction f() {\n  return Promise.reject("TEST");\n}\n\n// asyncF is equivalent to f!\nasync function asyncF() {\n  throw "Test";\n}\n// console.log(f());\n// console.log(asyncF());\n'),$e=o('\nconst request = require("request");\nasync function f1() {\n  return new Promise(function (resolve, reject) {\n    request("https://www.baidu.com/", function (err, res, body) {\n      resolve(body);\n    });\n  });\n}\n// 用then来拿到返回值\nf1().then((res) => console.log(res));\n// 用await来拿到返回值\n(async function () {\n  console.log(await f1());\n})();\n'),Ye=o("\nasync function f1 () {\n    return 10;\n}\n\nconsole.log(f1());     // Promise {<resolved>: 10}\nfn1().then(function (x) {\n  console.log(x);      // 10\n})\n"),Ze=o('\nasync function f1() {\n  throw new Error("ssss");\n}\n// 第一种\nf1().then(\n  (onFulfilled) => {},\n  (onRejected) => console.log(onRejected)\n);\n// 第二种\nf1().catch(function (e) {\n  console.log(e);\n});\n');return(e,t)=>{const o=Object(c["resolveComponent"])("RouterLink"),Ke=Object(c["resolveComponent"])("WebPrismEditor"),Qe=Object(c["resolveComponent"])("cod");return Object(c["openBlock"])(),Object(c["createElementBlock"])("div",null,[Object(c["createElementVNode"])("h3",E,[Object(c["createVNode"])(o,{to:"#Promise",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、Promise(异步编程) ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",y,[Object(c["createVNode"])(o,{to:"#Reference",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、参考资料 ")]),x]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",T,[Object(c["createVNode"])(o,{to:"#ConstructorStatus",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、构造函数和状态 ")]),Object(c["createElementVNode"])("section",null,[g,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(n),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(c["isRef"])(n)?n.value=e:null)},null,8,["modelValue"])]),w]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",R,[Object(c["createVNode"])(o,{to:"#NineMethods",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、九大方法 ")]),Object(c["createElementVNode"])("section",null,[k,S,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(l),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(c["isRef"])(l)?l.value=e:null)},null,8,["modelValue"]),Object(c["createElementVNode"])("p",A,[Object(c["createTextVNode"])("这个静态方法会让"),C,Object(c["createTextVNode"])("对象立即进入确定(即resolved) 状态，并将42传递给后面 "),Object(c["createVNode"])(Qe,null,{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("then")]),_:1}),Object(c["createTextVNode"])(" 里所指定的 "),_,Object(c["createTextVNode"])("函数。作为 "),F,Object(c["createTextVNode"])("的快捷方式，在进行 "),U,Object(c["createTextVNode"])(" 对象的初始化或者编写测试代码的时候都非常方便。 ")]),B]),Object(c["createElementVNode"])("section",null,[H,q,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(r),"onUpdate:modelValue":t[2]||(t[2]=e=>Object(c["isRef"])(r)?r.value=e:null)},null,8,["modelValue"]),I]),Object(c["createElementVNode"])("section",null,[G,M,Object(c["createElementVNode"])("div",null,[L,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(d),"onUpdate:modelValue":t[3]||(t[3]=e=>Object(c["isRef"])(d)?d.value=e:null)},null,8,["modelValue"]),J]),Object(c["createElementVNode"])("div",null,[z,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(a),"onUpdate:modelValue":t[4]||(t[4]=e=>Object(c["isRef"])(a)?a.value=e:null)},null,8,["modelValue"]),W]),Object(c["createElementVNode"])("div",null,[D,$,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(i),"onUpdate:modelValue":t[5]||(t[5]=e=>Object(c["isRef"])(i)?i.value=e:null)},null,8,["modelValue"]),Y,Z,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(s),"onUpdate:modelValue":t[6]||(t[6]=e=>Object(c["isRef"])(s)?s.value=e:null)},null,8,["modelValue"]),K,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(m),"onUpdate:modelValue":t[7]||(t[7]=e=>Object(c["isRef"])(m)?m.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("section",null,[Q,Object(c["createElementVNode"])("div",null,[X,ee,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(u),"onUpdate:modelValue":t[8]||(t[8]=e=>Object(c["isRef"])(u)?u.value=e:null)},null,8,["modelValue"]),te]),Object(c["createElementVNode"])("div",null,[oe,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(j),"onUpdate:modelValue":t[9]||(t[9]=e=>Object(c["isRef"])(j)?j.value=e:null)},null,8,["modelValue"]),ce])]),Object(c["createElementVNode"])("section",null,[ne,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(b),"onUpdate:modelValue":t[10]||(t[10]=e=>Object(c["isRef"])(b)?b.value=e:null)},null,8,["modelValue"]),le,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(O),"onUpdate:modelValue":t[11]||(t[11]=e=>Object(c["isRef"])(O)?O.value=e:null)},null,8,["modelValue"]),re,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(V),"onUpdate:modelValue":t[12]||(t[12]=e=>Object(c["isRef"])(V)?V.value=e:null)},null,8,["modelValue"]),de]),Object(c["createElementVNode"])("section",null,[ae,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(p),"onUpdate:modelValue":t[13]||(t[13]=e=>Object(c["isRef"])(p)?p.value=e:null)},null,8,["modelValue"]),ie]),Object(c["createElementVNode"])("section",null,[se,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(h),"onUpdate:modelValue":t[14]||(t[14]=e=>Object(c["isRef"])(h)?h.value=e:null)},null,8,["modelValue"]),me]),Object(c["createElementVNode"])("section",null,[ue,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(N),"onUpdate:modelValue":t[15]||(t[15]=e=>Object(c["isRef"])(N)?N.value=e:null)},null,8,["modelValue"]),je]),Object(c["createElementVNode"])("section",null,[be,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(v),"onUpdate:modelValue":t[16]||(t[16]=e=>Object(c["isRef"])(v)?v.value=e:null)},null,8,["modelValue"]),Oe])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Ve,[Object(c["createVNode"])(o,{to:"#ErrorCapture",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、错误捕获 ")]),Object(c["createElementVNode"])("section",null,[pe,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(f),"onUpdate:modelValue":t[17]||(t[17]=e=>Object(c["isRef"])(f)?f.value=e:null)},null,8,["modelValue"]),Ne,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(P),"onUpdate:modelValue":t[18]||(t[18]=e=>Object(c["isRef"])(P)?P.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("section",null,[he,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Me),"onUpdate:modelValue":t[19]||(t[19]=e=>Object(c["isRef"])(Me)?Me.value=e:null)},null,8,["modelValue"]),ve,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Le),"onUpdate:modelValue":t[20]||(t[20]=e=>Object(c["isRef"])(Le)?Le.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",fe,[Object(c["createVNode"])(o,{to:"#ReturnValue",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、返回值 ")]),Object(c["createElementVNode"])("section",null,[Pe,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Je),"onUpdate:modelValue":t[21]||(t[21]=e=>Object(c["isRef"])(Je)?Je.value=e:null)},null,8,["modelValue"]),Ee])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",ye,[Object(c["createVNode"])(o,{to:"#Async",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("7、async ")]),Object(c["createElementVNode"])("section",null,[xe,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(ze),"onUpdate:modelValue":t[22]||(t[22]=e=>Object(c["isRef"])(ze)?ze.value=e:null)},null,8,["modelValue"]),Te,Object(c["createElementVNode"])("div",null,[ge,we,Re,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(We),"onUpdate:modelValue":t[23]||(t[23]=e=>Object(c["isRef"])(We)?We.value=e:null)},null,8,["modelValue"]),ke,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(De),"onUpdate:modelValue":t[24]||(t[24]=e=>Object(c["isRef"])(De)?De.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[Se,Ae,Object(c["createElementVNode"])("div",null,[Ce,Object(c["createElementVNode"])("section",null,[_e,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])($e),"onUpdate:modelValue":t[25]||(t[25]=e=>Object(c["isRef"])($e)?$e.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Fe,Object(c["createElementVNode"])("section",null,[Ue,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Ye),"onUpdate:modelValue":t[26]||(t[26]=e=>Object(c["isRef"])(Ye)?Ye.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Be,Object(c["createElementVNode"])("section",null,[He,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Ze),"onUpdate:modelValue":t[27]||(t[27]=e=>Object(c["isRef"])(Ze)?Ze.value=e:null)},null,8,["modelValue"])])])])])]),Object(c["createElementVNode"])("h4",qe,[Object(c["createVNode"])(o,{to:"#Await",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("8、await ")]),Object(c["createElementVNode"])("h4",Ie,[Object(c["createVNode"])(o,{to:"#AsyncAwaitErrorCatch",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("7、async和await错误处理 ")]),Object(c["createElementVNode"])("h4",Ge,[Object(c["createVNode"])(o,{to:"#AsyncAwaitLoop",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("7、async和await循环中使用 ")])])}}});const Le=Me;var Je=Le;const ze={class:"main"},We=Object(c["createElementVNode"])("h2",{id:"javascript"},"javascript基础问题梳理",-1),De=Object(c["createStaticVNode"])('<div><h3 id="Generator">3、Generator</h3><h4 id="Iterator">1、迭代器Iterator</h4><h4 id="SubGenerator">2、生成器Generator</h4><h4 id="AutoGenerator">3、Generator自动执行</h4></div><h3 id="DeepClone">4、深拷贝和浅拷贝</h3>',2);var $e=Object(c["defineComponent"])({__name:"index",setup(e){const t=Object(c["getCurrentInstance"])(),{$builtIn:o}=null===t||void 0===t?void 0:t.appContext.config.globalProperties;return(e,t)=>(Object(c["openBlock"])(),Object(c["createElementBlock"])("div",ze,[We,Object(c["createVNode"])(P),Object(c["createVNode"])(Je),De]))}});const Ye=$e;t["default"]=Ye}}]);