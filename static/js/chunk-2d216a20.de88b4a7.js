(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d216a20"],{c2fa:function(e,n,t){"use strict";t.r(n);var c=t("7a23");const o={id:"This"},l={style:{"padding-top":"20px","margin-left":"10px"}},a=Object(c["createStaticVNode"])('<div class="lineH-p-40" style="margin-left:30px;"><p> 1. 对于直接调用的函数来说，不管函数被放在了什么地方，<code>this</code>都是<code>window</code>; </p><p> 2. 对于被别人调用的函数来说，被谁【点】出来的，<code>this</code>就是谁; </p><p> 3. <code>call、apply</code>时，<code>this</code>是第一个参数。<code>bind</code>要优与 <code>call/apply</code>，<code>call</code>参数多，<code>apply</code>参数少; </p><p> 4. 在构造函数中，类中(函数体中)出现的<code>this.xxx = xxx</code>中的<code>this</code> 是当前类的一个实例; </p><p> 5. 箭头函数没有自己的<code>this</code>,需要看其外层是否有函数，如果有：外层函数的<code>this</code> 就是内部箭头函数的<code>this</code>，如果没有，<code>this</code>则是<code>window</code>; </p></div>',1),r={id:"GlobalFunction"},d=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"this"),Object(c["createTextVNode"])("指向全局对象"),Object(c["createElementVNode"])("code",null,"window"),Object(c["createTextVNode"])("，"),Object(c["createElementVNode"])("span",{class:"red"},"注意严格模式下"),Object(c["createTextVNode"])("， "),Object(c["createElementVNode"])("code",null,"this"),Object(c["createTextVNode"])("为"),Object(c["createElementVNode"])("code",null,"undefined"),Object(c["createTextVNode"])("; ")],-1),i={id:"ObjectMethod"},s=Object(c["createElementVNode"])("p",null,"this指向调用该方法的对象",-1),u={id:"Constructor"},b=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("this指向 "),Object(c["createElementVNode"])("span",{class:"red"},"new 关键字 "),Object(c["createTextVNode"])("创建出的实例")],-1),j={id:"SetTimeout"},O=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("定时器 setTimeout 或 setInterval，以及回调函数或匿名函数自调用，"),Object(c["createElementVNode"])("span",{class:"red"},"this指向全局对象window")],-1),m={id:"EventFunction"},V=Object(c["createElementVNode"])("p",null,"元素绑定事件，事件触发后执行函数，this指向的是当前元素",-1),N={id:"ArrowFunction"},f=Object(c["createElementVNode"])("p",null,"this指向箭头函数定义时所处的对象",-1),p={id:"CallApplyBind"},h=Object(c["createStaticVNode"])('<section><ul type="square"><li> call和apply：<span class="red">改变 this 指向后</span>执行函数。 <ul style="margin-left:1rem;" type="circle"><li>call(thisScope,arg1,arg2,arg...);<span class="red"> 多个参数，第一个参数为null、undefined时，默认指向Window</span></li><li>apply(thisScope,[arg1,arg2,arg...]);<span class="red"> 两个参数</span></li></ul></li></ul><ul type="square"><li>bind: 改变 this 指向后，返回函数，不执行。</li><p>bind(thisScopr,arg1,arg2,arg...) 多个参数</p></ul></section>',1),v=Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("div",{class:"c-h5"},"apply的使用方法(函数劫持、对象复制)"),Object(c["createElementVNode"])("div",{class:"indent"},[Object(c["createElementVNode"])("span",null,[Object(c["createTextVNode"])("可以看到 Student 不具备任何方法，但是在 "),Object(c["createElementVNode"])("span",{class:"red"},"Person.apply(this,arguments)"),Object(c["createTextVNode"])("之后，他就具备了Person类的方法及属性")])]),Object(c["createElementVNode"])("div",null,"由此得出结论： Function.apply() 能“劫持”另外一个对象， 继承另外一个对象的属性")],-1);var g=Object(c["defineComponent"])({__name:"this",setup(e){const n=Object(c["getCurrentInstance"])(),{$builtIn:t}=null===n||void 0===n?void 0:n.appContext.config.globalProperties,g=Object(c["ref"])("http://liubin.org/promises-book/"),x=t("\n// 'not strict' 【window】\nconsole.log(this);\nfunction funs(){\n    console.log(this); \n};\nfuns();\n\n// 'use strict' 【undefined】\nfunction stractDemo(){\n    'use strict'\n    console.log(this);\n};\nstractDemo();\n"),E=t("\nlet name = 'Global Barry';\nlet obj = {\n    name: 'Obj Barry',\n    getName: function(){\n        console.log(this.name)\n    },\n};\nobj.getName(); // 'Obj Barry'\n\nlet funs = obj.getName;\nfuns(); // 'Global Barry'\n"),w=t('\nfunction Barry(){\n    this.name = "Fashion pro Barry";\n    console.log(this);\n}\n\nlet n = new Barry();\nconsole.log(n)\n'),y=t('\n// setTimeout\nsetTimeout(function () {\n    console.log(this)\n}, 0)\n\nvar name = "my name is window"; // 注意var 和 const 输出是不一样的\nvar obj = {\n    name: "my name is obj",\n    funs: function () {\n        let timer = null;\n        clearInterval(timer);\n        timer = setInterval(function () {\n            console.log(this.name); // "my name is window"\n        }, 100);\n    },\n};\nobj.funs();\n\n\n// 回调函数\nvar o = {\n    age: 18,\n    say: function () {\n        function callback() {\n            return this.age;\n        }\n        func(callback);\n    },\n};\nfunction func(callback) {\n    var name = "Fashion Barry";\n    console.log(name, " is", callback() + " years"); \n}\no.say(); // Fashion Barry  is undefined years\n/**\n * 【解析】：\n * 函数内部的【this】指向于此函数的调用者（拥有者）\n * 但在上面这个例子中，为什么会输出unidentified\n * 虽然【callback】定义在对象【o】的【say】方法中，但实际上由于【callback】是在【func】函数中被普通调用的\n * 那么【func】中的【callback】的调用对象我们可以理解为【window】对象\n * 当使用一个对象未定义的属性时不会报错，会返回undefined，而直接使用一个未定义的变量便会报错\n*/\n\n'),T=t('\n<button id="btn">click me</button>\n\nwindow.onload = function () {\n    var btn = document.getElementById("btn");\n    btn.onclick = function () {\n        console.log(this);\n    };\n};\n'),C=t('\nvar name = "my name is window";\nvar obj = {\n    name: "my name is obj",\n    func: function () {\n        return (() => {\n            console.log(this.name); // my name is obj\n        })();\n    },\n};\nobj.func()\n'),B=t('\n// 对象方法:this指向方法前的对象\nvar person = {\n  name: "dog",\n  say: function (language) {\n    console.log(this.name + " say " + language);\n  },\n};\nperson.say("Hello world!");\n\n//call  改变this指向，传入多个参数\nvar name = "duck";\nperson.say.call(window, "Helo Window!");\n\n//apply 改变this指向，两个参数\n// person.say.apply(this, "Hello Apply!"); // 会报错TypeError: CreateListFromArrayLike called on non-object\n\nperson.say.apply(window, { name: "Hello Apply!" }); // nduck say undefined\n// apply 的第二个参数必须为数组\nperson.say.apply(this, ["Hello Apply!"]); // duck say Hello Apply\n\nvar arr = [1, 2, 3, 4];\nMath.max.apply(null, arr); //4, null表示不改变this指向\n\n// bind:改变this指向，不立即调用，而是返回该函数\nfunction multiply(x, y, z) {\n  return x * y * z;\n}\n\nvar double = multiply.bind(null, 2);\nconsole.log(double(3, 4)); // 24\n\nvar person1 = {\n  name: "dog",\n  sayHello: function () {\n    setTimeout(\n      function () {\n        console.log(this.name + " Say Hello!");\n      }.bind(this),\n      1000\n    );\n  },\n};\n\nperson1.sayHello(); //dog Say Hello!\n\n'),k=t('\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayHello = function () {\n    console.log(this.name + " Say hello!");\n  };\n}\n\nfunction Student(name, age, grade) {\n  Person.apply(this, arguments);\n  this.grade = grade;\n}\n\nvar s = new Student("Barry", 18, "middle school");\nconsole.log(s.name); // Barry\nconsole.log(s.age); // 18\nconsole.log(s.grade); //middle school\ns.sayHello(); // Barry Say hello!\n'),_=t("\n// 面试题解析\nvar x = 20;\nvar a = {\n  x: 15,\n  fn: function () {\n    var x = 30;\n    return function () {\n      return this.x;\n    };\n  },\n};\n\nconsole.log(a.fn()); // Function ƒ(){return this.x}\nconsole.log((a.fn())()); // 20 a.fn()返回的是一个函数，()()这是自执行表达式。this -> window\nconsole.log(a.fn()()); // 20 a.fn()相当于在全局定义了一个函数，然后再自己调用执行。this -> window\nconsole.log(a.fn()() == (a.fn())()); //true\nconsole.log(a.fn().call(this)); // 20 这段代码在全局环境中执行，this -> window\nconsole.log(a.fn().call(a)); // 15, 更改this指向为 a，a的x为15\n\n");return(e,n)=>{const t=Object(c["resolveComponent"])("RouterLink"),A=Object(c["resolveComponent"])("NavigationBlank"),S=Object(c["resolveComponent"])("WebPrismEditor");return Object(c["openBlock"])(),Object(c["createElementBlock"])("div",null,[Object(c["createElementVNode"])("h3",o,[Object(c["createVNode"])(t,{to:"#This",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、This指向 ")]),Object(c["createElementVNode"])("div",l,[Object(c["createElementVNode"])("p",null,[Object(c["createVNode"])(A,{modelValue:g.value,"onUpdate:modelValue":n[0]||(n[0]=e=>g.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("参考资料: MDN中this解析")]),_:1},8,["modelValue"])]),a]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",r,[Object(c["createVNode"])(t,{to:"#GlobalFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、全局函数 ")]),Object(c["createElementVNode"])("section",null,[d,Object(c["createVNode"])(S,{modelValue:Object(c["unref"])(x),"onUpdate:modelValue":n[1]||(n[1]=e=>Object(c["isRef"])(x)?x.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",i,[Object(c["createVNode"])(t,{to:"#ObjectMethod",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、对象方法 ")]),Object(c["createElementVNode"])("section",null,[s,Object(c["createVNode"])(S,{modelValue:Object(c["unref"])(E),"onUpdate:modelValue":n[2]||(n[2]=e=>Object(c["isRef"])(E)?E.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",u,[Object(c["createVNode"])(t,{to:"#Constructor",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、构造函数 ")]),Object(c["createElementVNode"])("section",null,[b,Object(c["createVNode"])(S,{modelValue:Object(c["unref"])(w),"onUpdate:modelValue":n[3]||(n[3]=e=>Object(c["isRef"])(w)?w.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",j,[Object(c["createVNode"])(t,{to:"#SetTimeout",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、定时器、回调函数 ")]),Object(c["createElementVNode"])("section",null,[O,Object(c["createVNode"])(S,{modelValue:Object(c["unref"])(y),"onUpdate:modelValue":n[4]||(n[4]=e=>Object(c["isRef"])(y)?y.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",m,[Object(c["createVNode"])(t,{to:"#EventFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、事件函数 ")]),Object(c["createElementVNode"])("section",null,[V,Object(c["createVNode"])(S,{modelValue:Object(c["unref"])(T),"onUpdate:modelValue":n[5]||(n[5]=e=>Object(c["isRef"])(T)?T.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",N,[Object(c["createVNode"])(t,{to:"#ArrowFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("6、箭头函数 ")]),Object(c["createElementVNode"])("section",null,[f,Object(c["createVNode"])(S,{modelValue:Object(c["unref"])(C),"onUpdate:modelValue":n[6]||(n[6]=e=>Object(c["isRef"])(C)?C.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",p,[Object(c["createVNode"])(t,{to:"#CallApplyBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("7、call、apply、bind ")]),Object(c["createElementVNode"])("section",null,[h,Object(c["createVNode"])(S,{modelValue:Object(c["unref"])(B),"onUpdate:modelValue":n[7]||(n[7]=e=>Object(c["isRef"])(B)?B.value=e:null)},null,8,["modelValue"]),v,Object(c["createVNode"])(S,{modelValue:Object(c["unref"])(k),"onUpdate:modelValue":n[8]||(n[8]=e=>Object(c["isRef"])(k)?k.value=e:null)},null,8,["modelValue"]),Object(c["createVNode"])(S,{modelValue:Object(c["unref"])(_),"onUpdate:modelValue":n[9]||(n[9]=e=>Object(c["isRef"])(_)?_.value=e:null)},null,8,["modelValue"])])])])}}});const x=g;var E=x;const w={id:"ThisBind"},y={id:"DefaultBind"},T=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("非严格模式下，默认绑定指向全局( "),Object(c["createElementVNode"])("code",null,"node"),Object(c["createTextVNode"])("中是 "),Object(c["createElementVNode"])("code",null,"global"),Object(c["createTextVNode"])(" )")],-1),C={id:"ImplicitBind"},B=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("隐式绑定的"),Object(c["createElementVNode"])("code",null,"this"),Object(c["createTextVNode"])("指的是调用堆栈的【上一级】("),Object(c["createElementVNode"])("code",null,"."),Object(c["createTextVNode"])("前的哪一个)")],-1),k={id:"DisplayBind"},_=Object(c["createStaticVNode"])('<p> 显式绑定主要指<code>call\\apply\\bind</code></p><div><ul><li> apply <ul type="cricle"><li><code>func.apply(thisArg,[argsArray])</code>,<code>thisArg</code>为<code>undefined | null</code> 时指向全局; </li><li> 返回调用指定<code>this</code>值和参数函数的结果; </li></ul></li><li> call <ul type="cricle"><li><code>func.call(thisArg,arg1,arg2,....)</code>; </li><li> 返回调用者提供的<code>this</code>值和参数调用该函数的返回值，若该方法没有返回值，则返回 <code>undefined</code>; </li></ul></li><li> bind <ul type="cricle"><li><code>func.bind(thisArg,arg1,arg2,....)</code>; </li><li><code>thisArg</code>: 调用绑定函数时作为<code>this</code>参数传递给目标函数的值。如果使用 <code>new</code>运算符构造绑定函数，则忽略该值。当使用<code>bind</code>在<code>setTimeout</code> 中创建一个函数(作为回调提供)时，作为<code>thisArg</code>传递的任何值都将转换为<code>object</code> 。如果<code>bind</code>函数的参数列表为空，或者<code>thisArg</code>是<code>null | undefined</code> ，执行作用域的<code>this</code>将被视为新函数的<code>thisArg</code>; </li><li> 返回一个原函数的拷贝，并拥有指定<code>this</code>值和初始参数 </li><li> MDN的<code>this</code>实现 </li></ul></li></ul></div>',2),A={id:"NewObject"},S=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("如果函数"),Object(c["createElementVNode"])("code",null,"constructor"),Object(c["createTextVNode"])("里没有返回对象的话，"),Object(c["createElementVNode"])("code",null,"this"),Object(c["createTextVNode"])("指向的是 "),Object(c["createElementVNode"])("code",null,"new"),Object(c["createTextVNode"])("之后得到的实例 ")],-1),F=Object(c["createStaticVNode"])('<p class="c-h6">如何确保你的构造函数只能被new调用，而不能被普通调用？</p><div><ul><li>ES6之前使用：<code>instanceof</code></li><li>ES6之后 <ul type="cricle"><li> 1. new.target 实现：《ECMAScript 6 入门》中讲到: ES6 为 new 命令引入了一个 <code>new.target</code> 属性， 该属性一般用在构造函数之中，返回 <code>new</code> 命令作用于的那个构造函数。 如果构造函数不是通过 <code>new</code> 命令或 <code>Reflect.construct()</code> 调用的，<code>new.target</code> 会返回 <code>undefined</code> ，因此这个属性可以用来确定构造函数是怎么调用的。 </li><li> 2. 使用 Class：<code>ES6</code> 提供 <code>Class</code> 作为构造函数的语法糖， 来实现语义化更好的面向对象编程， 并且对 <code>Class</code> 进行了规定：类的构造器必须使用 <code>new</code> 来调用。 </li></ul></li></ul></div><p>请看下面三种实现示例：</p>',3),I={id:"ThisBindArrowFunction"},P=Object(c["createStaticVNode"])('<p> 编译期间确定的上下文，不会被改变，哪怕你<code>new</code>，指向的就是<span class="red">上一层</span> 的上下文，箭头函数没有自己的<code>this</code>，需要看其外层是否有函数，如果有，外层函数的 <code>this</code>就是内部箭头函数的<code>this</code>，如果没有，则<code>this</code>是<code>window</code></p>',1),R={id:"ThisPriority"},U=Object(c["createElementVNode"])("p",null," 【new 绑定】> 【显式绑定】> 【隐式绑定】> 【默认绑定】 ",-1);var D=Object(c["defineComponent"])({__name:"thisBind",setup(e){const n=Object(c["getCurrentInstance"])(),{$builtIn:t}=null===n||void 0===n?void 0:n.appContext.config.globalProperties,o=t("\n// 1. 非严格模式\nfunction myFunc() {\n  console.log(this);\n}\n\nmyFunc(); // window\n\n// 2. 严格模式\nfunction myFunc2() {\n  \"use strict\";\n  console.log(this);\n}\nmyFunc2(); // undefined\n\n// 面试题1\nvar a = 1;\nfunction fn() {\n  var a = 2;\n  console.log(this.a); // console what ?\n}\nfn(); // 1\n\n// 面试题2\nlet a = 1; //let定义自己的作用域，不挂载至window\nfunction fn2() {\n  var a = 2;\n  console.log(this.a);\n}\nfn2(); //SyntaxError: Identifier 'a' has already been declared\n\n// 面试题3\nvar b = 1;\nfunction fn3(){\n  var b = 2;\n  function fn4(){\n    console.log(this.b);\n  }\n  fn4()\n}\nfn3(); // 1\n\n// 面试题4\nconst obj = {\n  a: 1,\n  fn: function () {\n    console.log(this.a);\n  },\n};\n\nobj.fn(); // console what ? 1 obj.fn()this指向的是obj\nconst f = obj.fn; // 当赋值给时，this丢失\nf(); // undefined\n"),l=t('\nfunction fn() {\n  console.log(this.a);\n}\nconst obj = {\n  a: 1,\n};\nobj.fn = fn;\nobj.fn(); // 1\n\nfunction fn2() {\n  console.log(this.a);\n}\nconst obj1 = {\n  a: 1,\n  fn2,\n};\nconst obj2 = {\n  a: 2,\n  obj1,\n};\nobj2.obj1.fn2(); // 1\n\n// 面试题：隐式绑定失败场景\n// 1. 函数赋值\nconst obj1 = {\n  a: 1,\n  fn: function () {\n    console.log(this.a);\n  },\n};\nconst fn1 = obj1.fn; //将引用给了 fn1，等同于 fn1 = function fn1() { console.log(this.a) }\nfn1(); // undefined\n\n// 2. setTimeout\nsetTimeout(obj1.fn, 1000); // undefined 这里执行的环境同样是全局\n\n// 3. 将函数作为参数传递\nfunction run(fn) {\n  console.log(fn === obj1.fn);\n  fn();\n}\nrun(obj1.fn); //undefined，传进去的是一个引用\n\n//4、一般匿名函数也是会指向全局的\nvar name = "The Window";\nvar obj = {\n  name: "My obj",\n  getName: function () {\n    return function () {\n      // 这是一个匿名函数\n      console.log(this.name);\n    };\n  },\n};\nobj.getName()()(\n  //5、IIFE\n  function () {\n    var a = 1;\n    console.log(this.a);\n  }\n)(); //undefined\n'),a=t('\n// Yes, it does work with \' new (funcA.bind(thisArg, args)) \'\nif (!Function.prototype.bind)\n  (function () {\n    var ArrayPrototypeSlice = Array.prototype.slice; // 为了 this\n    Function.prototype.bind = function (otherThis) {\n      // 调用者必须是函数，这里的 this 指向调用者：fn.bind(ctx, ...args) / fn\n      if (typeof this !== "function") {\n        throw new Error(\n          "Function.prototype.bind-what is trying to be bound is not a callable"\n        );\n      }\n      var baseArgs = ArrayPrototypeSlice.call(arguments, 1), // 取余下参数\n        baseArgsLength = baseArgs.length,\n        fToBind = this,\n        fNOP = function () {}, //寄生组合集成需要一个中间函数，避免两次构造\n        fBound = function () {\n          // const newFn = fn.bind(ctx, 1); newFn(2) -> arguments: [1, 2]\n          baseArgs.length = baseArgsLength; // reset to default base arguments\n          baseArgs.push.aplly(\n            // apply 显示绑定 this\n            // 判断是不是 new 调用的情况，这里也说明了后边要讲的优先级问题\n            fNOP.prototype.isPrototypeOf(this) ? this : otherThis,\n            baseArgs\n          );\n        };\n      // 下边是为了实现原型继承\n      if (this.prototype) {\n        // 函数的原型指向其构造函数，构造函数的原型指向函数\n        // Function.prototype doesn\'t have a prototype property\n        fNOP.prototype = this.prototype;\n      }\n      fBound.prototype = new fNOP(); // 继承中间函数，其实这里也继承了调用者了\n      return fBound; // new fn()\n    };\n  })();\n\nfunction fn() {\n  console.log(this.a);\n}\n\nconst obj = {\n  a: 100,\n};\n\nfn.call(obj);\n\nfunction fn() {\n  console.log(this);\n}\n// 为啥可以绑定基本类型 ?\n// boxing(装箱) -> (1 ----\x3e Number(1))\n// bind 只看第一个 bind（堆栈的上下文，上一个，写的顺序来看就是第一个）\nfn.bind(1).bind(2)(); //1\n'),r=t('\nfunction Foo(n) {\n  this.n = n;\n}\n\nconst f = new Foo("Barry");\nconsole.log(f.n); //"Barry"\n\nfunction Bar(a) {\n  this.a = a;\n  return {\n    a: 100,\n    b: 10,\n  };\n}\nconst b = new Bar(3);\nconsole.log(b); //100\n'),d=t('\n// 第一种 使用 instanceof 实现\nfunction Barry(surname, firstname) {\n  if (!(this instanceof Barry))\n    throw new Error(\'Function constructor A cannot be invoked without "new"\');\n  this.surname = surname;\n  this.firstname = firstname;\n}\nconst b = Barry("CH", "Barry"); // error\nconst b2 = new Barry("CH", "Barry"); // Barry { surname: \'CH\', firstname: \'Barry\' }\n\n// 第二种 使用 new.target 实现\nfunction Barry2(surname, firstname) {\n  if (!new.target)\n    throw new Error(\'Function constructor A cannot be invoked without "new"\');\n  this.surname = surname;\n  this.firstname = firstname;\n}\nconst b3 = Barry2("CH", "Barry2"); // error\nconst b4 = new Barry2("CH", "Barry2"); // Barry2 { surname: \'CH\', firstname: \'Barry2\' }\n\n// 第三种 使用 Class\n// Class 修复了很多 ES5 面向对象编程的缺陷，例如类中的所有方法都是不可枚举的；\n// 类的所有方法都无法被当作构造函数使用等。\n\nclass Barry3 {\n  constructor(surname, firstname) {\n    this.surname = surname;\n    this.firstname = firstname;\n  }\n}\n\n// const b5 = Barry3("CH", "Barry3"); // error\nconst b5 = new Barry3("CH", "Barry3"); // Barry3 { surname: \'CH\', firstname: \'Barry3\' }\n'),i=t("\nvar a = {\n  myFunc: function () {\n    setTimeout(function () {\n      console.log(this); // window\n    }, 0);\n  },\n};\n\na.myFunc();\n\nvar a2 = {\n  myFunc: function () {\n    var _this = this;\n    setTimeout(function () {\n      console.log(_this); // a\n    }, 0);\n  },\n};\na2.myFunc();\n\n// 箭头函数\nvar a3 = {\n  myFunc: function () {\n    setTimeout(() => {\n      console.log(this); // a\n    }, 0);\n  },\n};\na3.myFunc();\n\nfunction fn() {\n  return {\n    b: () => {\n      console.log(this);\n    },\n  };\n}\nfn().b(); // window\nfn().b.bind(1)(); // window\nfn.bind(2)().b.bind(3)(); // [Number: 2]\n"),s=t("\n// 隐式 vs 默认 -> 结论：隐式 > 默认\nfunction fn() {\n  console.log(this);\n}\nconst obj = {\n  fn,\n};\nobj.fn(); // obj { fn: [Function: fn] }\n\n// 显式 vs 隐式 -> 结论：显式 > 隐式\nobj.fn.call(); // window\n\n// new vs 显式 -> 结论：new > 显式\nfunction foo(a) {\n  this.a = a;\n}\nconst obj1 = {};\nvar bar = foo.bind(obj1);\nbar(10);\nconsole.log(obj1.a); // 10\n\n// new\nvar bzz = new foo(3)\nconsole.log(obj1.a); // 10\nconsole.log(bzz.a); // 3\n// 箭头函数没有 this，比较没有意义\n");return(e,n)=>{const t=Object(c["resolveComponent"])("RouterLink"),u=Object(c["resolveComponent"])("WebPrismEditor");return Object(c["openBlock"])(),Object(c["createElementBlock"])(c["Fragment"],null,[Object(c["createElementVNode"])("h3",w,[Object(c["createVNode"])(t,{to:"#ThisBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、This绑定 ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",y,[Object(c["createVNode"])(t,{to:"#DefaultBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、默认绑定(函数直接调用) ")]),Object(c["createElementVNode"])("section",null,[T,Object(c["createVNode"])(u,{modelValue:Object(c["unref"])(o),"onUpdate:modelValue":n[0]||(n[0]=e=>Object(c["isRef"])(o)?o.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",C,[Object(c["createVNode"])(t,{to:"#ImplicitBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、隐式绑定(属性访问调用，函数被别人调用) ")]),Object(c["createElementVNode"])("section",null,[B,Object(c["createVNode"])(u,{modelValue:Object(c["unref"])(l),"onUpdate:modelValue":n[1]||(n[1]=e=>Object(c["isRef"])(l)?l.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",k,[Object(c["createVNode"])(t,{to:"#DisplayBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、显式绑定(call/apply/bind) ")]),Object(c["createElementVNode"])("section",null,[_,Object(c["createVNode"])(u,{modelValue:Object(c["unref"])(a),"onUpdate:modelValue":n[2]||(n[2]=e=>Object(c["isRef"])(a)?a.value=e:null)},null,8,["modelValue"]),Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("span",null,[Object(c["createTextVNode"])(" 面试题资料： "),Object(c["createVNode"])(t,{to:"#CustomCall",class:"a-navigation"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("手写 call\\apply\\bind")]),_:1})])])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",A,[Object(c["createVNode"])(t,{to:"#NewObject",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、new创建对象 ")]),Object(c["createElementVNode"])("section",null,[S,Object(c["createVNode"])(u,{modelValue:Object(c["unref"])(r),"onUpdate:modelValue":n[3]||(n[3]=e=>Object(c["isRef"])(r)?r.value=e:null)},null,8,["modelValue"]),F,Object(c["createVNode"])(u,{modelValue:Object(c["unref"])(d),"onUpdate:modelValue":n[4]||(n[4]=e=>Object(c["isRef"])(d)?d.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",I,[Object(c["createVNode"])(t,{to:"#ThisBindArrowFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、箭头函数 ")]),Object(c["createElementVNode"])("section",null,[P,Object(c["createVNode"])(u,{modelValue:Object(c["unref"])(i),"onUpdate:modelValue":n[5]||(n[5]=e=>Object(c["isRef"])(i)?i.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",R,[Object(c["createVNode"])(t,{to:"#ThisPriority",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("6、优先级 ")]),Object(c["createElementVNode"])("section",null,[U,Object(c["createVNode"])(u,{modelValue:Object(c["unref"])(s),"onUpdate:modelValue":n[6]||(n[6]=e=>Object(c["isRef"])(s)?s.value=e:null)},null,8,["modelValue"])])])],64)}}});const H=D;var L=H;const M={id:"ActionScope"},W={id:"DataStorage"},z=Object(c["createElementVNode"])("section",null,[Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("ul",null,[Object(c["createElementVNode"])("li",null," 栈（FIFO先进先出）放置静态内存，编译期分配：全局变量 "),Object(c["createElementVNode"])("li",null," 堆（FILO先进后出）放置动态内存，执行期分配：函数执行上下文 ")])])],-1),G={id:"ExcuteContext"},$={class:"c-h6"},q=Object(c["createElementVNode"])("p",null," 当函数执行时，会创建一个执行上下文的环境，分为创建和执行两个阶段 ",-1),J=Object(c["createElementVNode"])("p",{class:"c-h6"},"1. 创建阶段",-1),Y=Object(c["createElementVNode"])("p",{class:"indent"},"函数被调用未执行任何代码时，创建一个拥有3个属性的对象",-1),K=Object(c["createElementVNode"])("p",{class:"c-h6"},"2. 执行阶段",-1),Q=Object(c["createElementVNode"])("p",{class:"indent"},"分配变量（提升）、函数的引用、赋值，执行代码",-1),X={id:"ExcuteContextStack"},Z=Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("ul",null,[Object(c["createElementVNode"])("li",null,[Object(c["createTextVNode"])(" 浏览器中的"),Object(c["createElementVNode"])("code",null,"js"),Object(c["createTextVNode"])("解释器是单线程的，相对于浏览器中同一时间只能做一个事情 ")]),Object(c["createElementVNode"])("li",null," 代码中只有一个全局执行上下文和无数个函数执行上下文，这些组成了执行上下文(Execution Stack) "),Object(c["createElementVNode"])("li",null," 一个函数的执行上下文，在函数执行完毕后，会被移出执行上下文栈 ")])],-1),ee={id:"ActionScopeChain"},ne=Object(c["createStaticVNode"])('<div><ul><li><span class="red">作用域：</span>全局作用域、函数作用域、ES6块级作用域。作用域最大的用途就是隔离变量或函数，并控制 生命周期。作用域在函数执行上下文创建时定义好的，不是函数执行是定义。 </li><li><span class="red">作用域链：</span>当一个块或函数嵌套在另一个块或函数中时，发生了作用域嵌套。 在当前函数中如果无法找到某个变量，就会往上一级嵌套的作用域中去寻找，直到找到该变量或抵达全局 作用域，这样的链式关系称为 <span class="red">作用域链(Scope Chain)</span><div><ul type="cricle"><li> 代码执行流每进入一个新上下文（全局、函数、跨级作用域），就会创建一个作用域链， 用于搜索变量和函数。 </li><li> 函数或块的局部上下文可以访问自己作用域内的变量，也可以访问任何包含上下文及全局 上下文中的变量。 </li><li> 全局上下文只能访问全局作用域的变量和函数，无法访问局部上下文的任何数据。 </li></ul></div></li></ul></div>',1),te={id:"ActionScopeChainGrow"},ce=Object(c["createElementVNode"])("p",null,"某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。",-1),oe=Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("ul",null,[Object(c["createElementVNode"])("li",null,[Object(c["createElementVNode"])("span",{class:"red"},"try/catch语句中的catch块："),Object(c["createTextVNode"])(" 会创建一个新的变量对象，包含要抛出的错误对象的声明 ")]),Object(c["createElementVNode"])("li",null,[Object(c["createElementVNode"])("span",{class:"red"},"with语句："),Object(c["createTextVNode"])(" 向作用域链前端添加制定的对象 ")])])],-1);var le=Object(c["defineComponent"])({__name:"actionScope",setup(e){const n=Object(c["getCurrentInstance"])(),{$builtIn:t}=null===n||void 0===n?void 0:n.appContext.config.globalProperties,o=Object(c["ref"])("https://juejin.cn/post/6890705692643196935"),l=Object(c["ref"])("https://github.com/mqyqingfeng/Blog/issues/6"),a=t("\nexecutionContext = {\n  scopeChain: {}, // 创建作用域链（scope chain）\n  variableObject: {}, // 初始化变量、函数、形参\n  this: {}, // 指定this\n}; // 初始化 VO -> 建立作用域链 -> 确定 This 上下文\n"),r=t('\nfunction demo(num) {\n  var name = "Barry";\n  var getData = function () {};\n  function c() {}\n}\ndemo(100);\n\n// 创建阶段大致是这样，在这个阶段就出现了【变量提升(hoisting)】\nexecutionContext = {\n  scopeChain: {...},\n  variableObject: {\n    arguments: {\n      // 创建参数对象\n      0: 100,\n      length: 1,\n    },\n    num: 100, // 创建形参名称，赋值/或创建引用拷贝\n    c: pointer to function c(), // 有内部函数生命的话，创建引用指向函数体\n    name: undefined, // 有内部声明变量 a，初始化为 undefined\n    getData: undefined, // 有内部声明变量 getData，初始化为 undefined\n  },\n  this: {...}\n};\n\n// 代码执行阶段，在这个阶段主要是赋值并执行代码\nexecutionContext = {\n  scopeChain: {...},\n  variableObject: {\n    arguments: {\n      0: 100,\n      length: 1,\n    },\n    num: 100,\n    c: pointer to function c(),\n    name: "barry", // 分配变量，赋值\n    getDate: poiter to function getData() // 分配函数的引用，赋值\n  },\n  this: {...}\n}\n'),d=t('\nfunction c() {\n  console.log("Barry");\n}\n\nfunction a() {\n  function b() {\n    c();\n  }\n  b();\n}\na();\n'),i=t('\nfunction a() {\n  return function b() {\n    var name = "Barry";\n    console.log(name); // Barry\n  };\n}\n\nfunction c() {\n  var name = "Fashion Barry";\n  b(); // 访问全局作用域找到 b()\n}\n\nvar b = a(); // 全局作用域\nc();\n\n// 去掉函数b中的 name 声明后\nfunction a2() {\n  return function b2() {\n    // var name = "Barry";\n    console.log(name); // name is not defined\n  };\n}\n\nfunction c2() {\n  var name = "Fashion Barry";\n  b2(); // 访问全局作用域找到 b()\n}\n\nvar b2 = a2(); // 全局作用域\nc2();\n'),s=t("\n// 示例 1\nvar a = 10,\n  b = 10;\nwith ({ a: 10 }) {\n  var a = 20,\n    b = 20;\n  console.log(a); // 20\n  console.log(b); // 20\n}\nconsole.log(a); // 10 原值\nconsole.log(b); // 20 b被更改\n\n// 示例2\nvar a = 15,\n  b = 15;\nwith ({ a: 10 }) {\n  b = 30;\n  console.log(a); // 10，指定对象a的值\n  console.log(b); // 30\n}\nconsole.log(a); // 15\nconsole.log(b); // 30\n");return(e,n)=>{const t=Object(c["resolveComponent"])("RouterLink"),u=Object(c["resolveComponent"])("NavigationBlank"),b=Object(c["resolveComponent"])("WebPrismEditor");return Object(c["openBlock"])(),Object(c["createElementBlock"])(c["Fragment"],null,[Object(c["createElementVNode"])("h3",M,[Object(c["createVNode"])(t,{to:"#ActionScope",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、作用域 ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",W,[Object(c["createVNode"])(t,{to:"#DataStorage",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、数据存储 ")]),z]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",G,[Object(c["createVNode"])(t,{to:"#ExcuteContext",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、执行上下文 ")]),Object(c["createElementVNode"])("section",null,[Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("ul",$,[Object(c["createElementVNode"])("li",null,[Object(c["createVNode"])(u,{modelValue:o.value,"onUpdate:modelValue":n[0]||(n[0]=e=>o.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("一文说透执行上下文")]),_:1},8,["modelValue"])]),Object(c["createElementVNode"])("li",null,[Object(c["createVNode"])(u,{modelValue:l.value,"onUpdate:modelValue":n[1]||(n[1]=e=>l.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("js深入之作用链")]),_:1},8,["modelValue"])])])]),q,Object(c["createElementVNode"])("div",null,[J,Y,Object(c["createVNode"])(b,{modelValue:Object(c["unref"])(a),"onUpdate:modelValue":n[2]||(n[2]=e=>Object(c["isRef"])(a)?a.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[K,Q,Object(c["createVNode"])(b,{modelValue:Object(c["unref"])(r),"onUpdate:modelValue":n[3]||(n[3]=e=>Object(c["isRef"])(r)?r.value=e:null)},null,8,["modelValue"])])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",X,[Object(c["createVNode"])(t,{to:"#ExcuteContextStack",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、执行上下文栈 ")]),Object(c["createElementVNode"])("section",null,[Z,Object(c["createVNode"])(b,{modelValue:Object(c["unref"])(d),"onUpdate:modelValue":n[4]||(n[4]=e=>Object(c["isRef"])(d)?d.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",ee,[Object(c["createVNode"])(t,{to:"#ActionScopeChain",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、作用域与作用域链 ")]),Object(c["createElementVNode"])("section",null,[ne,Object(c["createVNode"])(b,{modelValue:Object(c["unref"])(i),"onUpdate:modelValue":n[5]||(n[5]=e=>Object(c["isRef"])(i)?i.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",te,[Object(c["createVNode"])(t,{to:"#ActionScopeChainGrow",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、作用域链增强 ")]),Object(c["createElementVNode"])("section",null,[ce,oe,Object(c["createVNode"])(b,{modelValue:Object(c["unref"])(s),"onUpdate:modelValue":n[6]||(n[6]=e=>Object(c["isRef"])(s)?s.value=e:null)},null,8,["modelValue"])])])],64)}}});const ae=le;var re=ae;const de={id:"DeepClone"},ie=Object(c["createElementVNode"])("p",null,"浅拷贝只复制一层对象的属性，而深拷贝则递归复制了所有层级。",-1),se={class:"indent"},ue={class:"indent"};var be=Object(c["defineComponent"])({__name:"deepClone",setup(e){const n=Object(c["ref"])("https://blog.csdn.net/weixin_56650035/article/details/123973205"),t=Object(c["ref"])("https://github.com/lodash/lodash/blob/master/cloneDeep.js");return(e,o)=>{const l=Object(c["resolveComponent"])("RouterLink"),a=Object(c["resolveComponent"])("NavigationBlank");return Object(c["openBlock"])(),Object(c["createElementBlock"])("div",null,[Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h3",de,[Object(c["createVNode"])(l,{to:"#DeepClone",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 4、深拷贝和浅拷贝 ")]),Object(c["createElementVNode"])("section",null,[ie,Object(c["createElementVNode"])("div",null,[Object(c["createTextVNode"])(" 参考资料： "),Object(c["createElementVNode"])("div",se,[Object(c["createVNode"])(a,{modelValue:n.value,"onUpdate:modelValue":o[0]||(o[0]=e=>n.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("1. JS 你最少用几行代码实现深拷贝？")]),_:1},8,["modelValue"])]),Object(c["createElementVNode"])("div",ue,[Object(c["createVNode"])(a,{modelValue:t.value,"onUpdate:modelValue":o[1]||(o[1]=e=>t.value=e)},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("2. Lodash源码")]),_:1},8,["modelValue"])])])])])])}}});const je=be;var Oe=je;const me={id:"ClosePackage"},Ve=Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("section",null,[Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("span",{class:"red"},"高级程序设计："),Object(c["createTextVNode"])(" 闭包指有权访问另一个函数作用域中的变量的函数，可以理解为那些引用了另一个函数作用域变量的函数， 通常是在嵌套函数中实现的。 ")])])],-1),Ne={id:"PrivateVariable"},fe={id:"StorageVariable"};var pe=Object(c["defineComponent"])({__name:"closePackage",setup(e){const n=Object(c["getCurrentInstance"])(),{$builtIn:t}=null===n||void 0===n?void 0:n.appContext.config.globalProperties,o=t("\n// 普通定义类\nfunction Person() {\n  this.age = 10;\n}\nPerson.prototype = {\n  addAge() {\n    this.age += 1;\n  },\n};\n\nvar person = new Person();\nconsole.log(person.age);\n\n// 工厂方法\nfunction Person2() {\n  var age = 10;\n  return {\n    addAge() {\n      this.age += 1;\n    },\n  };\n}\nvar person2 = new Person2();\nconsole.log(person2.age);\n"),l=t('\nfunction getList() {\n  let loaclData = null;\n  return {\n    getData() {\n      if (loaclData) {\n        return Promise.resolve(loaclData);\n      }\n      return fetch("xxx").then((res) => {\n        loaclData = res.json();\n      });\n    },\n  };\n}\n\nconst listDataManager = getList();\nconst result = listDataManager.getData(); // 如果有数据就是取缓存的数据\n');return(e,n)=>{const t=Object(c["resolveComponent"])("RouterLink"),a=Object(c["resolveComponent"])("WebPrismEditor");return Object(c["openBlock"])(),Object(c["createElementBlock"])(c["Fragment"],null,[Object(c["createElementVNode"])("h3",me,[Object(c["createVNode"])(t,{to:"#ClosePackage",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、闭包 ")]),Ve,Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Ne,[Object(c["createVNode"])(t,{to:"#PrivateVariable",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、封装私有变量（AMD的框架等都使用） ")]),Object(c["createElementVNode"])("section",null,[Object(c["createVNode"])(a,{modelValue:Object(c["unref"])(o),"onUpdate:modelValue":n[0]||(n[0]=e=>Object(c["isRef"])(o)?o.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",fe,[Object(c["createVNode"])(t,{to:"#StorageVariable",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、存储变量 ")]),Object(c["createElementVNode"])("section",null,[Object(c["createVNode"])(a,{modelValue:Object(c["unref"])(l),"onUpdate:modelValue":n[1]||(n[1]=e=>Object(c["isRef"])(l)?l.value=e:null)},null,8,["modelValue"])])])],64)}}});const he=pe;var ve=he;const ge={id:"Interview"},xe={id:"InterviewThis"},Ee={id:"InterviewActionScopeChain"},we={id:"InterviewOrientObject"},ye={id:"CustomCall"},Te={id:"CustomApply"},Ce={id:"CustomBind"},Be={id:"InterviewIntergrated"};function ke(e,n){const t=Object(c["resolveComponent"])("RouterLink");return Object(c["openBlock"])(),Object(c["createElementBlock"])(c["Fragment"],null,[Object(c["createElementVNode"])("h3",ge,[Object(c["createVNode"])(t,{to:"#Interview",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、面试 ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",xe,[Object(c["createVNode"])(t,{to:"#InterviewThis",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、this指向 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Ee,[Object(c["createVNode"])(t,{to:"#InterviewActionScopeChain",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、作用域链 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",we,[Object(c["createVNode"])(t,{to:"#InterviewOrientObject",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、面向对象 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",ye,[Object(c["createVNode"])(t,{to:"#CustomCall",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、call 函数的实现步骤 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Te,[Object(c["createVNode"])(t,{to:"#CustomApply",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、apply 函数的实现步骤 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Ce,[Object(c["createVNode"])(t,{to:"#CustomBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("6、bind 函数的实现步骤 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Be,[Object(c["createVNode"])(t,{to:"#InterviewIntergrated",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、综合题 ")])])],64)}var _e=t("6b0d"),Ae=t.n(_e);const Se={},Fe=Ae()(Se,[["render",ke]]);var Ie=Fe;const Pe={class:"main"},Re=Object(c["createElementVNode"])("h2",{id:"javascript"},"javascript基础问题梳理",-1);var Ue=Object(c["defineComponent"])({__name:"index",setup(e){const n=Object(c["getCurrentInstance"])(),{$builtIn:t}=null===n||void 0===n?void 0:n.appContext.config.globalProperties;return(e,n)=>(Object(c["openBlock"])(),Object(c["createElementBlock"])("div",Pe,[Re,Object(c["createVNode"])(E),Object(c["createVNode"])(L),Object(c["createVNode"])(re),Object(c["createVNode"])(Oe),Object(c["createVNode"])(ve),Object(c["createVNode"])(Ie)]))}});const De=Ue;n["default"]=De}}]);