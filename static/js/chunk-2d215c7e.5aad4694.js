(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d215c7e"],{c050:function(e,o,c){"use strict";c.r(o);var t=c("7a23");const d={id:"ReferenceInformation"},l=Object(t["createStaticVNode"])('<section><div><span>1.</span><a target="_blank" rel="help" href="http://liubin.org/promises-book/" class="a-navigation">JavaScript Promise迷你书(中文版)</a></div><div><span>2.</span><a target="_blank" href="https://juejin.cn/post/6844903455962693640" class="a-navigation">深入理解Promise(上)</a></div><div><span>3.</span><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903667494027278">从手写一个符合Promise/A+规范Promise来深入学习Promise</a></div><div><span>4.</span><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903550288412679">Promise深度学习---我のPromise/A+实现 </a></div><div><span>5.</span><a target="_blank" class="a-navigation" href="https://mp.weixin.qq.com/s/Yrwe2x6HukfqJZM6HkmRcw">【第1738期】100 行代码实现 Promises/A+ 规范</a></div><div><span>6.</span><a target="_blank" class="a-navigation" href="https://zhuanlan.zhihu.com/p/144058361">从零开始手写Promise </a></div><div><span>7.</span><a target="_blank" class="a-navigation" href="https://blog.csdn.net/weixin_56650035/article/details/121070438?spm=1001.2014.3001.5502">PromiseA+规范之手写Promise </a></div><div><span>8.</span><a target="_blank" class="a-navigation" href="https://promisesaplus.com/"> promise A plus规范 </a></div><div><span>9.</span><a target="_blank" class="a-navigation" href="https://mp.weixin.qq.com/s/Yrwe2x6HukfqJZM6HkmRcw"> 【第1738期】100 行代码实现 Promises/A+ 规范 </a></div><div><span>10.</span><a target="_blank" class="a-navigation" href="https://www.cnblogs.com/sugar-tomato/p/11353546.html"> 史上最最最详细的手写Promise教程 </a></div></section>',1);function i(e,o){const c=Object(t["resolveComponent"])("RouterLink");return Object(t["openBlock"])(),Object(t["createElementBlock"])("div",null,[Object(t["createElementVNode"])("h3",d,[Object(t["createVNode"])(c,{to:"#ReferenceInformation",class:"a-link"},{default:Object(t["withCtx"])(()=>[Object(t["createTextVNode"])("#")]),_:1}),Object(t["createTextVNode"])("1、参考资料 ")]),l])}var n=c("6b0d"),a=c.n(n);const s={},r=a()(s,[["render",i]]);var p=r;const m={id:"PromiseStandard"},u={id:"PromiseTerm"},j=Object(t["createStaticVNode"])("<section><div><ul><li><code>Promise</code>是一个具有<code>then</code>方法的对象或者函数，行为遵守本规范 </li><li><code>thenable</code>是一个具有<code>then</code>方法的对象或者是函数 </li><li><code>value</code>是<code>promise</code>状态成功时的值，也就是<code>resolve</code>的参数， 指各种<code>js</code>值，包括：<code>undefined、thenable、promise</code></li><li><code>reason</code>是<code>promise</code>状态失败时的值，也就是<code>reject</code> 的参数，表示拒绝的原因 </li><li><code>exception</code>是一个使用<code>throw</code>抛出的异常值 </li></ul></div></section>",1),b={id:"PromiseStates"},v=Object(t["createStaticVNode"])('<section><p><code>promise</code>有三种状态，注意它们之间的流转关系 </p><div><p class="c-h6">1. pending</p><div><ul><li>初始状态，可以改变</li><li> 一个<code>promise</code>在<code>resolve</code>或者<code>reject</code>之前都处于这个状态 </li><li> 可通过<code>resolve</code>转变为<code>fulfilled</code>状态 </li><li>可通过<code>reject</code>转变为<code>rejected</code></li></ul></div></div><div><p class="c-h6">2. fulfilled</p><div><ul><li> 最终态，不可变 </li><li> 一个<code>promise</code>被<code>resolve</code>后会变为这个状态 </li><li> 必须拥有一个<code>value</code>值 </li></ul></div></div><div><p class="c-h6">3. rejected</p><div><ul><li> 最终态，不可变 </li><li> 一个<code>promise</code>被<code>reject</code>后会变为这个状态 </li><li> 必须拥有一个<code>reason</code></li></ul></div></div><p class="c-h6">状态流转如下：</p><div class="indent"><p><code>pending</code> -&gt; <code>resolve(value)</code> -&gt; <code>fulfilled</code></p><p><code>pending</code> -&gt; <code>reject(reason)</code> -&gt; <code>rejected</code></p></div></section>',1),O={id:"PromiseThen"},h=Object(t["createElementVNode"])("p",null,[Object(t["createElementVNode"])("code",null,"promise"),Object(t["createTextVNode"])("应该有个"),Object(t["createElementVNode"])("code",null,"then"),Object(t["createTextVNode"])("方法，用来访问最终的结果，无论是 "),Object(t["createElementVNode"])("code",null,"value"),Object(t["createTextVNode"])("还是"),Object(t["createElementVNode"])("code",null,"reason")],-1),f=Object(t["createStaticVNode"])('<div><p class="c-h6">1. 参数要求</p><section><ul><li><code>onFulfilled</code>必须是函数类型，可选，如果不是函数，应该被忽略 </li><li><code>onRejected</code>必须是函数类型，可选，如果不是函数，应该被忽略 </li></ul><p><span class="red">注意：</span>这里的忽略是指给一个默认值,并不是真正意义上的忽略</p></section></div><div><p class="c-h6">2. onFulfilled特性</p><section><ul><li> 在<code>promise</code>变为<code>fulfilled</code>时，应该调用<code>onFulfilled</code> ，参数是<code>value</code></li><li> 在<code>promise</code>变成<code>fulfilled</code>之前，不应该被调用 </li><li> 只能被调用一次(实现时需使用变量来限制执行次数)， 可以注册若干个回调函数(<code>promise.then().then().then()....</code> ) </li></ul></section></div><div><p class="c-h6">3. onRejected特性</p><section><ul><li> 在<code>promise</code>变成<code>rejected</code>时，应该调用<code>onRejected</code> ，参数是<code>reason</code></li><li> 在<code>promise</code>变成<code>rejected</code>之前，不应该被调用 </li><li> 只能被调用一次 </li></ul></section></div><div><p class="c-h6">4. onFulfilled和onRejected应该是微任务</p><section><p> 在执行上下文堆栈仅包含平台代码之前，不得调用<code>onFulfilled</code>或 <code>onRejected</code>函数，<code>onFulfilled</code>和<code>onRejected</code> 必须被作为普通函数调用(即非实例化调用，这样函数内部 <code>this</code>非严格模式下 指向<code>window</code> )，使用<code>queueMicrotask</code>或者 <code>setTimeout</code>来实现微任务的调用。 </p></section></div><div><p class="c-h6">5. then方法可以被调用多次</p><section><ul><li><code>promise</code>状态变成<code>fulfilled</code>状态后，所有的<code>onFulfilled</code> 回调都需要按照<code>then</code>的顺序执行，也就是按照注册顺序执行(实现时用数组存储多个 <code>onFulfilled</code>的回调 ) </li><li><code>promise</code>状态变成<code>rejected</code>后，所有的<code>onRejected</code> 回调都需要按照<code>then</code>的顺序执行，也就是按照注册顺序执行(实现时用数组存储多个 <code>onRejected</code>的回调 ) </li></ul></section></div>',5),V=Object(t["createElementVNode"])("p",{class:"c-h6"},"6. then必须返回一个promise",-1),N=Object(t["createElementVNode"])("p",null,[Object(t["createElementVNode"])("code",null,"then"),Object(t["createTextVNode"])("必须返回一个"),Object(t["createElementVNode"])("code",null,"promise")],-1),g=Object(t["createStaticVNode"])("<div><ul><li><code>onFulfilled</code>或者<code>onRejected</code>执行的结果是 X， 调用<code>resolvePromise</code></li><li> 如果<code>onFulfilled</code>或者<code>onRejected</code>执行时抛出异常e， <code>promise2</code>需要被<code>reject</code>，其<code>reason</code>为e </li><li> 如果<code>onFulfilled</code>不是一个函数且<code>promise1</code>已经 <code>fulfilled</code>，<code>promise2</code>以<code>promise1</code> 的<code>value</code>触发<code>onFulfilled</code></li><li> 如果<code>onRejected</code>不是一个函数且<code>promise1</code>已经 <code>rejected</code>，<code>promise2</code>以<code>promise1</code> 的<code>reason</code>触发<code>onRejected</code></li></ul></div>",1),P=Object(t["createElementVNode"])("div",null,[Object(t["createElementVNode"])("p",{class:"c-h6"},"7. Promise的解决过程resolvePromise"),Object(t["createElementVNode"])("section")],-1);var k=Object(t["defineComponent"])({__name:"promiseStandard",setup(e){const o=Object(t["getCurrentInstance"])(),{$builtIn:c}=null===o||void 0===o?void 0:o.appContext.config.globalProperties,d=c("\npromise.then(onFulfilled, onRejected);\n"),l=c("\npromise2 = promise1.then(onFulfilled, onRejected)\n");return(e,o)=>{const c=Object(t["resolveComponent"])("RouterLink"),i=Object(t["resolveComponent"])("WebPrismEditor");return Object(t["openBlock"])(),Object(t["createElementBlock"])("div",null,[Object(t["createElementVNode"])("h3",m,[Object(t["createVNode"])(c,{to:"#PromiseStandard",class:"a-link"},{default:Object(t["withCtx"])(()=>[Object(t["createTextVNode"])("#")]),_:1}),Object(t["createTextVNode"])("2、PromiseA+ 规范 ")]),Object(t["createElementVNode"])("div",null,[Object(t["createElementVNode"])("h4",u,[Object(t["createVNode"])(c,{to:"#PromiseTerm",class:"a-link"},{default:Object(t["withCtx"])(()=>[Object(t["createTextVNode"])("#")]),_:1}),Object(t["createTextVNode"])("1、Promise术语 ")]),j]),Object(t["createElementVNode"])("div",null,[Object(t["createElementVNode"])("h4",b,[Object(t["createVNode"])(c,{to:"#PromiseStates",class:"a-link"},{default:Object(t["withCtx"])(()=>[Object(t["createTextVNode"])("#")]),_:1}),Object(t["createTextVNode"])("2、Promise状态 ")]),v]),Object(t["createElementVNode"])("div",null,[Object(t["createElementVNode"])("h4",O,[Object(t["createVNode"])(c,{to:"#PromiseThen",class:"a-link"},{default:Object(t["withCtx"])(()=>[Object(t["createTextVNode"])("#")]),_:1}),Object(t["createTextVNode"])("3、Promise then 方法 ")]),Object(t["createElementVNode"])("section",null,[h,Object(t["createVNode"])(i,{modelValue:Object(t["unref"])(d),"onUpdate:modelValue":o[0]||(o[0]=e=>Object(t["isRef"])(d)?d.value=e:null)},null,8,["modelValue"]),f,Object(t["createElementVNode"])("div",null,[V,Object(t["createElementVNode"])("section",null,[N,Object(t["createVNode"])(i,{modelValue:Object(t["unref"])(l),"onUpdate:modelValue":o[1]||(o[1]=e=>Object(t["isRef"])(l)?l.value=e:null)},null,8,["modelValue"]),g])]),P])])])}}});const x=k;var E=x;const w={class:"main"},R=Object(t["createElementVNode"])("h2",null,"Promise规范和应用",-1);var _=Object(t["defineComponent"])({__name:"index",setup(e){const o=Object(t["getCurrentInstance"])(),{$builtIn:c}=null===o||void 0===o?void 0:o.appContext.config.globalProperties;return(e,o)=>(Object(t["openBlock"])(),Object(t["createElementBlock"])("div",w,[R,Object(t["createVNode"])(p),Object(t["createVNode"])(E)]))}});const T=_;o["default"]=T}}]);