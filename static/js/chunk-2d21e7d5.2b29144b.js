(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d21e7d5"],{d67d:function(e,t,c){"use strict";c.r(t);var n=c("7a23");const o={id:"ReactOverview"},l={id:"ReactVersion"},d=Object(n["createElementVNode"])("div",{style:{width:"80%"}},[Object(n["createElementVNode"])("p",null,"用于构建用户界面的 JavaScript 库,是一个将数据渲染为 HTML 视图的开源 JavaScript 库。"),Object(n["createElementVNode"])("p",{class:"right"},"--- 摘自React官网")],-1),a={class:"mt-15"},i={id:"ReactEcology"},r=Object(n["createStaticVNode"])('<section><div><ul><li> 脚手架/框架 <div><ul type="cricle"><li> umi：可插拔的企业级 react 应用框架 </li><li> create react app：官方支持的创建 react 单页应用程序的方法 </li><li> Nextjs：SSR框架 </li><li> React-vr：vr框架，适用于展厅、房屋设计 </li><li> Reactxp：多端框架 </li></ul></div></li><li> 组件库 <div><ul type="cricle"><li> ant Design系列：pc、mobile，引入Ant Design设计概念 </li><li> Material-UI：实现了谷歌Material Design设计规范，世界流行界面 </li></ul></div></li><li> 工具类 <div><ul type="cricle"><li> Redux：遵循函数式编程思想的状态管理插件 </li><li> Mobx：面向对象变迁和响应式编程的状态管理插件 </li><li> Immutable-js：解决javasript Immutable Data的问题 </li></ul></div></li><li> 跨端类 <div><ul type="cricle"><li> Remax：阿里的React跨端框架，目前支持支付宝、微信、字节小程序 </li><li> Taro：类React跨端框架，支持主流小程序及React Native </li><li> React Native：js编写原生的React框架 </li></ul></div></li><li> 其他 <div><ul type="cricle"><li> react-window和react-virtualized：虚拟滚动库，提供可服用组件， 用于展示列表、网络和表格数据。 </li></ul></div></li></ul></div></section>',1);var s=Object(n["defineComponent"])({__name:"overview",setup(e){const t=Object(n["getCurrentInstance"])(),{$builtIn:c}=null===t||void 0===t?void 0:t.appContext.config.globalProperties;return(e,t)=>{const c=Object(n["resolveComponent"])("RouterLink"),s=Object(n["resolveComponent"])("el-timeline-item"),u=Object(n["resolveComponent"])("el-timeline");return Object(n["openBlock"])(),Object(n["createElementBlock"])(n["Fragment"],null,[Object(n["createElementVNode"])("h3",o,[Object(n["createVNode"])(c,{to:"#ReactOverview",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 1、综述 ")]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",l,[Object(n["createVNode"])(c,{to:"#ReactVersion",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])("1、react 简史及版本 ")]),Object(n["createElementVNode"])("section",null,[d,Object(n["createElementVNode"])("p",a,[Object(n["createVNode"])(u,null,{default:Object(n["withCtx"])(()=>[Object(n["createVNode"])(s,{timestamp:"2011",placement:"top"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" 起初由 Facebook 软件工程师 Jordan Wakke 创建。于 2011 年部署于 Facebook 的 newsfeed。 ")]),_:1}),Object(n["createVNode"])(s,{timestamp:"2012",placement:"top"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" 随后在 2012 年部署于 Instagram ")]),_:1}),Object(n["createVNode"])(s,{timestamp:"2013",placement:"top"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" 然后于 2013 年 5 月宣布开源 ")]),_:1}),Object(n["createVNode"])(s,{timestamp:"2015",placement:"top"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" 2015年发布v0.14.0版本：拆分react package into two，react and react-dom ")]),_:1}),Object(n["createVNode"])(s,{timestamp:"2016",placement:"top"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" 2016年发布v15.0版本：虚拟dom的diff操作同步执行 ")]),_:1}),Object(n["createVNode"])(s,{timestamp:"2017",placement:"top"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" 2017年发布React v16.0版本：使用fiber架构(分片)，小于ie11需使用polyfill ")]),_:1}),Object(n["createVNode"])(s,{timestamp:"2017-react v16.2.0",placement:"top"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" react v16.2.0（2017年）：增加Fragment组件 ")]),_:1}),Object(n["createVNode"])(s,{timestamp:"2018-react V16.3.0",placement:"top"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" react V16.3.0（2018年）：增加主要的api，React.createRef()、React.forwardRef() ")]),_:1}),Object(n["createVNode"])(s,{timestamp:"2018-V16.6.0",placement:"top"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" react V16.6.0（2018年）：增加主要的api，React.memo()、React.lazy() ")]),_:1}),Object(n["createVNode"])(s,{timestamp:"2018-V16.8.0",placement:"top"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" react V16.8.0（2019年）：增加React Hooks，用来解决状态逻辑复用问题，且不会产生 JSX 嵌套地狱 ")]),_:1}),Object(n["createVNode"])(s,{timestamp:"2020-V17.0.0",placement:"top"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" 2020年发布React v17.0版本：引入渐进式升级 ")]),_:1}),Object(n["createVNode"])(s,{timestamp:"2022-V18.0.0",placement:"top"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" 2022年发布React v18.0版本：引入useId 、useTransition 、useDeferredValue 、useSyncExternalStore 、useInsertionEffect 等 ")]),_:1})]),_:1})])])]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",i,[Object(n["createVNode"])(c,{to:"#ReactEcology",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])("2、react 生态 ")]),r])],64)}}});const u=s;var p=u;const O={id:"ReactVirtualDOM"},b={id:"CreateVirtualDOM"},m=Object(n["createElementVNode"])("p",{class:"c-h6"},"第一种：JS 的方式创建虚拟DOM(几乎不用,了解即可)",-1),j=Object(n["createElementVNode"])("p",{class:"c-h6"},"第二种：JSX 的方式创建虚拟DOM",-1),V=Object(n["createElementVNode"])("p",null,[Object(n["createElementVNode"])("code",null,"JSX"),Object(n["createTextVNode"])("可以使我们更便捷的去创建虚拟DOM，也可以说"),Object(n["createElementVNode"])("code",null,"JSX"),Object(n["createTextVNode"])("创建虚拟DOM是原生 "),Object(n["createElementVNode"])("code",null,"JS"),Object(n["createTextVNode"])("创建虚拟"),Object(n["createElementVNode"])("code",null,"DOM"),Object(n["createTextVNode"])("的语法糖。 ")],-1),v={id:"VirtualDOMUnderstand"},N=Object(n["createStaticVNode"])('<section><div><p class="indent"> 从本质上说，<code>Virtual DOM</code>是一个<code>JavaScript</code>对象，通过对象的方式来表现 <code>DOM</code>结构。将页面的状态抽象为<code>JS</code>对象的形式，配合不同的渲染工具，是跨平台渲染 成为可能。通过事务处理机制，将多次<code>DOM</code>修改的结果一次性的更新到页面上，从而有效的减少页面 渲染的次数，减少修改<code>DOM</code>的重排重绘次数，提高渲染性能。 </p><p class="indent"> 虚拟<code>DOM</code>就是对<code>DOM</code>的抽象，这个对象是更加轻量级的对<code>DOM</code>的描述。 它设计的最初目的，就是更好的跨平台，比如<code>node.js</code>就没有<code>DOM</code>。如果想实现 <code>SSR</code>，那么一个方式就是借助虚拟<code>DOM</code>，因为虚拟<code>DOM</code>本身是<code>js</code> 对象。在代码渲染到页面之前，<code>Vue</code>或<code>React</code>会把代码转换成一个对象（虚拟DOM）。以 对象的形式来描述真实的<code>DOM</code>结构，最终渲染到页面。在每次数据发生变化前，虚拟<code>DOM</code>都 会缓存一份，变化之时，现在的虚拟<code>DOM</code>会与缓存的虚拟<code>DOM</code>进行比较。在<code>Vue</code> 或者<code>React</code>内部封装了<code>Diff</code>算法，通过这个算法来进行比较，渲染时只针对有变化的 <code>DOM</code>进行修改，原先没有发生改变的通过原先的数据进行渲染。 </p><p class="indent"> 另外现在前端框架的一个基本要求就是无需手动操作<code>DOM</code>，一方面是因为手动操作<code>DOM</code>无法 保证性能，多人协同的项目中如果<code>review</code>不严格，可能会有开发者写出性能较低的代码，另一方面 更重要的是省略手动<code>DOM</code>操作可以大大提高效率。 </p></div><div><p class="c-h6"> 为什么要用 Virtual DOM： </p><div><p class="s-indent c-h6">(1) 保证性能下限，在不进行手动优化的情况下，提供过得去的性能</p><p> 下面对比一下修改<code>DOM</code>时真实<code>DOM</code>操作和<code>Virtual DOM</code>操作的 过程，来看一下它们重排重绘的性能消耗： </p><div><ul><li><span class="c-h7">真实DOM：</span> 生成 <code>HTML</code> 字符串 -&gt; 重建所有的 <code>DOM</code> 元素 </li><li><span class="c-h7">Virtual DOM：</span> 生成<code>vNode</code> -&gt; <code>DOM diff</code> -&gt; 必要的<code>DOM</code>更新 </li></ul></div></div><div><p class="s-indent c-h6"> (2) 跨平台 </p><p><code>Virtual DOM</code>本质上是<code>JavaScript</code>的对象，它可以很方便的跨平台操作， 比如服务器端渲染、uniapp等。 </p></div></div></section>',1),h={id:"ReactDiff"},f=Object(n["createStaticVNode"])('<section><p> 实际上，<code>diff</code> 算法探讨的就是虚拟 <code>DOM</code> 树发生变化后，生成 <code>DOM</code> 树更新补丁的方式。它通过对比新旧两株虚拟 <code>DOM</code> 树的变更差异， 将更新补丁作用于真实 <code>DOM</code> ，以最小成本完成视图更新。 </p><p class="c-h7">具体流程如下：</p><div><ul><li>真实的 <code>DOM</code> 首先会映射为虚拟 <code>DOM</code></li><li> 当虚拟<code>DOM</code>发生变化后，就会根据差异计算生成生成<code>patch</code>，这个 <code>patch</code>是一个结构化数据，内容包含了增加、更新、移除。 </li><li> 根据<code>patch</code>去更新真实的<code>DOM</code>，反馈到用户界面上。 </li></ul></div><p class="c-h6">待完善,请等候.....</p></section>',1),x={id:"ReactKey"},R=Object(n["createStaticVNode"])('<section><p class="indent"><code>keys</code>是<code>React</code>用于追踪那些列表中元素被修改、被添加或者被移除的辅助标识。 在开发过程中，我们需要保证某个元素的<code>key</code>在同级元素中具有唯一性。 </p><p class="indent"> 在<code>React Diff</code>算法中<code>React</code>会借助元素的<code>key</code>值来判断该元素是新 创建的还是被移动而来的元素，从而减少不必要的元素重新渲染。此外，<code>React</code>还需要借助 <code>key</code>值来判断元素与本地状态的关联关系。 </p><p class="c-h7">注意事项：</p><div><ul><li><code>key</code>值一定要和具体的元素--对应 </li><li> 尽量不要用数组的<code>index</code>去作为<code>key</code></li><li> 不要在<code>render</code>的时候，用随机数或者其他操作给元素加上不稳定的<code>key</code>， 这样造成的性能开销比不加<code>key</code>的情况下更糟糕。 </li></ul></div></section>',1),D={id:"ActualDOM"},E=Object(n["createStaticVNode"])('<section><p class="indent"> 虚拟<code>DOM</code>相对原生的<code>DOM</code>不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 <code>DOM</code>的操作无论如何都不可能比真实的<code>DOM</code>操作更快。在首次渲染大量<code>DOM</code> 时，由于多了一层虚拟<code>DOM</code>的计算，虚拟<code>DOM</code>也会比<code>innerHTML</code>插入慢。 它能保证性能下限，在真实<code>DOM</code>操作的时候进行针对性优化时，还是更快的。所以要根据具体的场景 进行探讨，不能以偏概全。 </p><p class="indent"> 在整个<code>DOM</code>操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写的爽不爽，在于 <span class="c-h7">研发体验/研发效率</span>。虚拟<code>DOM</code>不是别的，正是前端开发们为了 更好的研发体验和研发效率而创建出来的高阶产物。虚拟<code>DOM</code>并不一定能带来更好的性能， <code>React</code>官方也从来没有把虚拟<code>DOM</code>作为性能层面的卖点对外输出过。 </p><p class="red"> 虚拟<code>DOM</code>的优越之处在于，它能够提供更爽、更高效的研发模式(也就是函数式的 UI 编程方式)的同时， 仍然保持一个还不错的性能。 </p></section>',1),C={id:"ReactDiffAndVueDiff"},M=Object(n["createStaticVNode"])('<section><p class="indent"><code>Diff</code>算法是指生成更新补丁的方式，主要应用于虚拟<code>DOM</code>树变化后，更新真实<code>DOM</code>。 所以<code>diff</code>算法一定存在这样一个过程：<span class="c-h7"> 触发更新 --&gt; 生成补丁 --&gt; 应用补丁 </span></p><p class="indent"><code>React</code>的<code>diff</code>算法，触发更新的时机主要在<code>state</code>变化与<code>hooks</code> 调用之后。此时触发虚拟<code>DOM</code>树变更差异，采用了深度优先遍历算法。但传统的的遍历方式，效率更低。 为了优化效率，采用了分治的方式。将单一节点的对比转换为了3种类型节点的对比，分别是树、组件及元素，以此提高效率。 </p><div><ul><li><span class="c-h7">树对比：</span> 由于网页视图中较少有跨层级节点移动，两株虚拟<code>DOM</code>树只对同一层级的节点进行比较。 </li><li><span class="c-h7">组件对比：</span> 如果组件是同一类型，则进行树对比，如果不是则直接放入到补丁中。 </li><li><span class="c-h7">元素对比：</span> 主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实<code>DOM</code>的裁剪操作。 </li></ul></div><p class="indent"> 以上是经典的<code>React Diff</code>算法内容。自 <code>React 16</code>起，引入了<code>Fiber</code>架构。 为了使整个更新过程可随时暂停恢复，节点和树分别采用了<code>FiberNode</code>和<code>FiberTree</code>进行了 重构。<code>FiberNode</code>使用了双链表的结构，可以直接找到兄弟节点与子节点。整个更新过程由 <code>current</code>与<code>workInProgress</code>两株树双缓冲完成。<code>workInProgress</code>更新 完成后，再通过修改<code>current</code>相关指针指向新节点。 </p><p class="indent c-h7"><code>Vue</code>的整体<code>diff</code>策略与<code>React</code>对齐，虽然缺乏时间切片能力，但这并不意味着 <code>Vue</code>的性能更差，因为在<code>Vue3</code>初期引入过后期因为收益不高移除掉了。除了高帧率动画， 在<code>Vue</code>中其他的场景几乎都可以使用防抖和节流去提高响应性能。 </p></section>',1);var T=Object(n["defineComponent"])({__name:"virtualDOM",setup(e){const t=Object(n["getCurrentInstance"])(),{$builtIn:c}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,o=c('\n<div id="container2"></div>\n\n\x3c!-- 使用 js 创建虚拟 DOM --\x3e\n// 1.create virtual DOM\nconst virtualDOM2 = React.createElement(\n  "h1",\n  {},\n  React.createElement("span", { id: "title" }, "Hello world!")\n);\n// 2.render virtual DOM\nReactDOM.render(virtualDOM2, document.getElementById("container2"));\n'),l=c('\n<div id="container"></div>\n\n\x3c!-- 使用jsx 创建虚拟 DOM ( script 需要加上 type="text/babel")--\x3e\n// 1.create virtual DOM\nconst virtualDOM = (\n  <h1>\n    <span id="title">Hello world!</span>\n  </h1>\n);\n// 2.render virtual DOM\nReactDOM.render(virtualDOM, document.getElementById("container"));\n');return(e,t)=>{const c=Object(n["resolveComponent"])("RouterLink"),d=Object(n["resolveComponent"])("WebPrismEditor");return Object(n["openBlock"])(),Object(n["createElementBlock"])(n["Fragment"],null,[Object(n["createElementVNode"])("h3",O,[Object(n["createVNode"])(c,{to:"#ReactVirtualDOM",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 2、虚拟 DOM ")]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",b,[Object(n["createVNode"])(c,{to:"#CreateVirtualDOM",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 1、虚拟DOM的两种创建方式 ")]),Object(n["createElementVNode"])("section",null,[Object(n["createElementVNode"])("div",null,[m,Object(n["createVNode"])(d,{modelValue:Object(n["unref"])(o),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(n["isRef"])(o)?o.value=e:null)},null,8,["modelValue"])]),Object(n["createElementVNode"])("div",null,[j,V,Object(n["createVNode"])(d,{modelValue:Object(n["unref"])(l),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(n["isRef"])(l)?l.value=e:null)},null,8,["modelValue"])])])]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",v,[Object(n["createVNode"])(c,{to:"#VirtualDOMUnderstand",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 2、对虚拟DOM的理解？虚拟DOM主要做了什么？虚拟DOM本身是什么？ ")]),N]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",h,[Object(n["createVNode"])(c,{to:"#ReactDiff",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 3、React diff算法的原理是什么？ ")]),f]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",x,[Object(n["createVNode"])(c,{to:"#ReactKey",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 4、React key是干嘛用的，为什么要加？key主要是解决哪一类问题的 ")]),R]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",D,[Object(n["createVNode"])(c,{to:"#ActualDOM",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 5、虚拟DOM的引入与直接操作原生DOM相比，哪一个效率更高，为什么 ")]),E]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",C,[Object(n["createVNode"])(c,{to:"#ReactDiffAndVueDiff",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 6、React与Vue的diff算法有何不同？ ")]),M])],64)}}});const y=T;var k=y;const g={id:"ReactGrammar"},w={id:"ReactJSX"},S=Object(n["createStaticVNode"])('<p class="c-h5">1. JSX语法规则</p><div><ul><li> 定义虚拟DOM时，不能写引号</li><li> 标签中混入Js表达式时要用{ }</li><li> 样式类名要用className</li><li> 内联样式，要用<code>双花括号</code>的形式</li><li> 只有一个根标签，所有标签必须闭合</li><li> 标签首字母： <div><ul type="cricle"><li>小写开头，则将改标签转为html中同名元素</li><li>大写开头，react 则去渲染对应组件</li></ul></div></li><li> 注释：{/* xxx */}</li><li> props默认值为true</li></ul></div>',2),_=Object(n["createStaticVNode"])('<p class="c-h5">2. 合法的JSX元素</p><div><ul><li>普通的DOM元素，如<code>div/span/p</code>等</li><li> 申明的react组件，例如通过<code>class</code>或者函数创建的<code>jsx</code>组件 ，用户定义的组件必须以大写字母开头 </li><li><code>false、null、undefined、true</code> 为合法元素，但是不会渲染 </li><li> 字符串最终会渲染一个<code>text节点</code></li><li> 数字类型，最终会渲染出来 </li></ul></div>',2),U={id:"FunctionComponent"},P=Object(n["createElementVNode"])("p",null,[Object(n["createTextVNode"])("在"),Object(n["createElementVNode"])("code",null,"react"),Object(n["createTextVNode"])("中可以使用【 函数 】的形式来创建一个组件：")],-1),I={id:"ClassComponent"},B=Object(n["createElementVNode"])("p",null,[Object(n["createTextVNode"])("在"),Object(n["createElementVNode"])("code",null,"react"),Object(n["createTextVNode"])("中可以使用【 类 】的形式来创建一个组件：")],-1),F=Object(n["createStaticVNode"])('<p class="c-h7">两种组件的区别：</p><div><ul><li> 加载<code>props</code>方式不同，【函数式】定义组件从组件函数加载;【类式】的组件通过 <code>this.props</code>获取传入的参数 </li><li> 【函数式】组件比较简单，内部无法维护状态(因为没有 this,新版本的hook解决了这个问题); 【类式】内部可以通过<code>this.state</code>和<code>this.setState</code>方法定义 和更新内部的<code>state</code>，同时更新<code>header</code>里面函数的渲染结果 </li><li> 【类式】组件内部可以定义更多的方法在实例上，但是【函数式】组件无法定义 </li><li> 【类式】组件需要使用<code>new</code>实例化，函数式组件直接使用 </li></ul></div>',2),L={id:"StateAndSetState"},J=Object(n["createStaticVNode"])('<div><p class="c-h7">理解:</p><ul><li><code>state</code>是组件对象最重要的属性，值是对象(可以包含多个<code>key-value</code>的组合)</li><li> 组件被称为【状态机】，通过更新组件的<code>state</code>来更新对应的页面显示(重新渲染组件) </li></ul><p class="c-h7">注意:</p><ul><li> 组件中<code>render</code>方法的<code>this</code>为组件实例对象 </li><li> 组件自定义方法中<code>this</code>为<code>undefined</code>，如何解决？ <div><ul type="cricle"><li> 强制绑定<code>this</code>：通过函数对象的<code>bind()</code></li><li> 箭头函数 </li></ul></div></li><li> 状态数据，不能直接修改或更新 </li></ul></div>',1),H=Object(n["createElementVNode"])("p",{class:"c-h7"},[Object(n["createTextVNode"])("强制绑定"),Object(n["createElementVNode"])("code",null,"this"),Object(n["createTextVNode"])("：通过函数对象的"),Object(n["createElementVNode"])("code",null,"bind()")],-1),A=Object(n["createElementVNode"])("p",{class:"c-h7"},"箭头函数",-1),W={id:"ReactProps"},q={class:"overview"},X=Object(n["createStaticVNode"])('<p class="c-h7">理解：</p><div><ul><li>每个组件对象都会有<code>props( prototies 的简写 )</code>属性</li><li>组件标签的所有属性，都保存在<code>props</code>中</li></ul></div><p class="c-h7">作用：</p><div><ul><li>通过标签属性从【组件外】向【组件内】传递变化的数据</li><li>注意：组件内部不要修改<code>props</code>数据</li></ul></div><blockquote class="be-careful"><p class="title">注意：</p><div> 自 <code>React v15.5</code> 起，<code>React.PropTypes</code> 已移入另一个包中。请使用 <code>prop-types</code> 库 代替。我们提供了一个 <code>codemod</code> 脚本来做自动转换。 </div></blockquote><p class="c-h6">类式组件使用 props</p>',6),z=Object(n["createElementVNode"])("p",{class:"c-h6"},"函数式组件使用 props",-1),$={id:"ReactRef"},G=Object(n["createElementVNode"])("p",{class:"c-h6"},"写法1：字符串写法(不推荐--效率不高且可能会在未来版本移除)",-1),K=Object(n["createElementVNode"])("p",{class:"c-h6"},"写法2：回调函数写法",-1),Q=Object(n["createStaticVNode"])('<blockquote class="be-careful"><p class="title">注意：关于回调 refs 的说明</p><div> 如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 <code>null</code> ，然后第二次会传入参数 <code>DOM</code> 元素。 这是因为在每次渲染时会创建一个新的函数实例， 所以 <code>React</code> 清空旧的 <code>ref</code> 并且设置新的。 通过将 <code>ref</code> 的回调函数定义成 <code>class</code> 的绑定函数的 方式可以避免上述问题，但是大多数情况下它是无关紧要的。 </div></blockquote><p class="c-h7">将 <code>ref</code> 的回调函数定义成 <code>class</code> 的绑定函数</p>',2),Y=Object(n["createElementVNode"])("p",{class:"c-h6"},"写法3：createRef 写法(最新)",-1),Z=Object(n["createElementVNode"])("p",null,[Object(n["createTextVNode"])("调用后可以返回一个容器，该容器可以存储被 "),Object(n["createElementVNode"])("code",null,"ref"),Object(n["createTextVNode"])(" 所标识的节点, 该容器是【专人专用】，后声明的 "),Object(n["createElementVNode"])("code",null,"ref"),Object(n["createTextVNode"])(" 会覆盖前一个")],-1),ee={id:"HasStateComponent"},te=Object(n["createStaticVNode"])('<section><div><p class="c-h6">1. 有状态组件</p><div><ul><li> 特点 <div><ul type="cricle"><li> 是类组件 </li><li> 有继承 </li><li> 可以使用<code>this</code></li><li> 使用较多，容易频繁触发生命周期钩子函数，影响性能 </li><li> 内部使用<code>state</code>，维护自身状态的变化，有状态组件根据外部组件传入 的<code>props</code>和自身的<code>state</code>进行渲染 </li></ul></div></li><li> 使用场景 <div><ul type="cricle"><li>需要使用到状态的</li><li> 需要使用状态操作组件的(无状态的组件也可以实现， 通过新版本的<code>React hooks</code>实现 ) </li></ul></div></li><li> 总结 <div><ul type="cricle"><li> 类组件可以维护自身的状态变量，即组件的<code>state</code>，类组件还有不同 的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载）对组件 做更多的控制。类组件既可以充当无状态组件，也可以充当有状态组件。当一个类 组件不需要管理自身状态时，也可以称为【无状态组件】 </li></ul></div></li></ul></div></div><div><p class="c-h6">2. 无状态组件</p><div><ul><li> 特点 <div><ul type="cricle"><li> 不依赖自身的状态<code>state</code></li><li> 可以是类组件或者函数组件 </li><li> 可以完全避免使用<code>this</code>关键字(由于使用的是箭头函数事件无需绑定) </li><li> 有更高的性能，当不需要使用生命周期钩子时，应该首先使用无状态函数组件 </li><li> 组件内部不维护<code>state</code>，只根据外部组件传入的<code>props</code> 进行渲染的组件，当<code>props</code>改变时，组件重新渲染。 </li></ul></div></li><li> 使用场景 <div><ul type="cricle"><li> 组件不需要管理<code>state</code>，纯展示 </li></ul></div></li><li> 优点 <div><ul type="cricle"><li> 简化代码，专注于<code>render</code></li><li> 组件不需要被实例化，无生命周期，提升性能。 输出(渲染)只取决于输入(属性)，无副作用 </li><li> 视图和数据的解耦分离 </li></ul></div></li><li> 缺点 <div><ul type="cricle"><li> 无法使用<code>ref</code></li><li> 无生命周期方法 </li><li> 无法控制组件的重新渲染，因为无法使用 <code>shouldComponentUpdate</code>方法，当组件接受到新的属性时则会重新渲染 </li></ul></div></li><li> 总结 <div><ul type="cricle"><li> 组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态数就不会过于复杂，易于理解和管理。 当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件，比如自定义的 <code>Button、Input</code>等组件 </li></ul></div></li></ul></div></div></section>',1),ce={id:"ControlComponent"},ne=Object(n["createElementVNode"])("p",null,[Object(n["createTextVNode"])("受控组件：表单数据是由"),Object(n["createElementVNode"])("code",null,"React"),Object(n["createTextVNode"])("组件来管理的，推荐使用。(类似于 vue 的双向绑定)")],-1),oe=Object(n["createElementVNode"])("p",null,[Object(n["createTextVNode"])("非受控组件：表单数据将交由"),Object(n["createElementVNode"])("code",null,"DOM"),Object(n["createTextVNode"])("节点来处理，可以通过"),Object(n["createElementVNode"])("code",null,"ref"),Object(n["createTextVNode"])(" 获取表单数据，不推荐使用")],-1),le={id:"EventBind"},de=Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("ul",null,[Object(n["createElementVNode"])("li",null,[Object(n["createTextVNode"])("通过 "),Object(n["createElementVNode"])("code",null,"onXxx"),Object(n["createTextVNode"])(" 属性指定事件处理函数（注意大小写） "),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("ul",{type:"cricle"},[Object(n["createElementVNode"])("li",null,"React 使用的是自定义（合成）事件，而不是使用原生的 DOM 事件 ———— 为了更好的兼容性"),Object(n["createElementVNode"])("li",null,"React 中的事件是通过【事件委托(事件代理)】方式处理的（委托给组件最外层的元素）———— 为了跨端、兼容性和性能提升")])])]),Object(n["createElementVNode"])("li",null,"通过 event.target 得到发生事件的 DOM 元素对象")])],-1),ae=Object(n["createElementVNode"])("blockquote",{class:"be-careful"},[Object(n["createElementVNode"])("p",{class:"title"},"注意"),Object(n["createElementVNode"])("div",null,[Object(n["createTextVNode"])(" 异步操作最好将对象内部需要的值进行拷贝，否则会导致 "),Object(n["createElementVNode"])("code",null,"this"),Object(n["createTextVNode"])(" 指向问题。 ")])],-1);var ie=Object(n["defineComponent"])({__name:"grammar",setup(e){const t=Object(n["getCurrentInstance"])(),{$builtIn:c}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,o=Object(n["ref"])("https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html#gatsby-focus-wrapper"),l=c('const arr = ["Vue", "React", "Angular"];\nconst virtualDOM = (\n  <div>\n    <h2 className="title">前端 JS 框架</h2>\n    <ul>\n      {arr.map((t, i) => {\n        return (\n          <li className="sub-title" style={{ color: "#F0F" }} key={i}>\n            {t}\n          </li>\n        );\n      })}\n    </ul>\n  </div>\n);\nReactDOM.render(virtualDOM, document.getElementById("container"));'),d=c("<div>\n    <p>{false && <p>test</p>}{/* 渲染空元素 */}</p>\n    <p>{0 && <p>true</p>}{/* 与门如果出现非布尔值，渲染与预期有出入，渲染出0 */}</p>\n    <p>{0 ? null : <p>true</p>} {/* 建议使用三目运算符 */}</p>\n</div>"),a=c("\nfunction Demo(props) {\n    return <h2>{props.text || 'My name is Function Component'}</h2>;\n}\nReactDOM.render(<Demo />, document.getElementById(\"container\"));"),i=c("\nclass Demo extends React.Component {\n    render() {\n      // render是放在哪里的？—— Demo的原型对象上，供实例使用\n      // render中this是谁？—— Demo组件的实例对象\n      return <h2>{ this.props.text || 'My name is Class Component'}</h2>;\n    }\n}\nReactDOM.render(<Demo />, document.getElementById(\"container\"));"),r=c('\nclass Weather extends React.Component {\n    // constructor 调用几次？—— 1次\n    constructor(props) {\n      super(props);\n      this.state = {\n        isHot: false,\n      };\n      //解决 handleClick 中的 this 问题\n      this.handleClick = this.handleClick.bind(this);\n    }\n    handleClick() {\n      //handleClick 放在哪里？——放在 Weather 的原型对象上，供实例使用\n      //由于handleClick 是作为 onClick 的回调，所以不是通过实例调用的，属于直接调用\n      //    严格模式下 this 为 undefined(类中的所有方法都默认开启了局部严格模式)\n      //所以 handleClick 中的 this 为undefined\n\n      //注意：state 不可直接更改，必须通过 setState 进行更新\n      //且，更新是一种合并，不是替换\n      //   this.setState((state) => (state.isHot = !state.isHot));\n      this.setState({ isHot: !this.state.isHot });\n    }\n    // render 调用几次？—— 1 + n次，1：初始化，n：状态更新次数\n    render() {\n      return (\n        <h2 onClick={this.handleClick}>\n          今天天气很：{this.state.isHot ? "炎热" : "凉爽"}\n        </h2>\n      );\n    }\n}'),s=c('\nclass Weather extends React.Component {\n    state = {\n      isHot: false,\n      wind: "微风",\n    };\n    handleClick = () => {\n      this.setState({\n        isHot: !this.state.isHot,\n        wind: this.state.isHot ? "无风" : "微风",\n      });\n    };\n    render() {\n      const { isHot, wind } = this.state;\n      return (\n        <h2 onClick={this.handleClick}>\n          今天天气很：{isHot ? "炎热" : "凉爽"} - {wind}\n        </h2>\n      );\n    }\n}'),u=c('\nclass Person extends React.Component {\n  // 开发过程中可以忽略，基本上不需要写\n  // constructor(props) {\n  //   // 构造器是否接收props，是否传递给super，\n  //   // 取决于：是否希望在构造器中通过 this 访问 props\n  //   super(props);\n  // }\n\n  // 如何限制 props 数据类型\n  // React 16 之前,React 15.5开始已弃用\n  // static propTypes = {\n  // name: React.PropTypes.string.isRequired,\n  // sex: React.PropTypes.string,\n  // age: React.PropTypes.number,\n  // speak: React.PropTypes.func,\n  // };\n  /**\n   * 使用 prop-types 库进行限制\n   * 需要引入 prop-types 库\n   */\n  static propTypes = {\n    name: PropTypes.string.isRequired,\n    sex: PropTypes.string,\n    age: PropTypes.number,\n    speak: PropTypes.func,\n  };\n  // 指定默认标签属性值\n  static defaultProps = {\n    sex: "未知",\n    age: 6,\n  };\n\n  render() {\n    // props 是只读的\n    console.log("props", this.props);\n    const { name, age, sex } = this.props;\n    const speak = this.props.speak\n      ? this.props.speak.bind(this)\n      : () => console.log("请添加方法");\n    return (\n      <div>\n        <ul>\n          <li>姓名：{name}</li>\n          <li>年龄：{age}</li>\n          <li>性别：{sex}</li>\n          <li>\n            <button onClick={speak}>说话</button>\n          </li>\n        </ul>\n      </div>\n    );\n  }\n}\nfunction speak() {\n  console.log(this.props.name + \'：说话了\');\n}\n//方法传递\nReactDOM.render(\n  <Person name="Barry" age={20} speak={speak} />,\n  document.getElementById("container")\n);\n\n// 批量传递 props\nconst personInformation = { name: "Lishen", age: 22, sex: "男" };\n// 扩展属性：将对象所有的属性通过 props 传递\nReactDOM.render(\n  <Person {...personInformation} />,\n  document.getElementById("container2")\n);'),p=c('\nfunction Person(props) {\n    console.log("props", props);\n    const { name, sex, age } = props;\n    return (\n      <ul>\n        <li>姓名：{name}</li>\n        <li>性别：{sex}</li>\n        <li>年龄：{age}</li>\n      </ul>\n    );\n}\n// 如何限制 props 数据类型\n// React 16 之前,React 15.5开始弃用\n//   Person.propTypes = {\n//    name: React.PropTypes.string.isRequired,\n//    sex: React.PropTypes.string,\n//    age: React.PropTypes.number,\n//   };\n/**\n  * 使用 prop-types 库进行限制\n  * 需要引入 prop-types 库\n */\nPerson.propTypes = {\n  name: PropTypes.string.isRequired,\n  sex: PropTypes.string,\n  age: PropTypes.number,\n};\n// 指定默认标签属性值\nPerson.defaultProps = {\n  sex: "未知",\n  age: 6,\n};\nReactDOM.render(\n  <Person name="Barry" age={18} />,\n  document.getElementById("container")\n);'),O=c('\nclass Demo extends React.Component {\n  handleLeftClick = () => {\n    alert(this.refs.leftInput.value);\n  };\n  render() {\n    return (\n      <div>\n        <input ref="leftInput" type="text" placeholder="请输入数据" />\n        &nbsp;\n        <button onClick={this.handleLeftClick}>点击提示左侧数据</button>\n      </div>\n    );\n  }\n}\nReactDOM.render(<Demo />, document.getElementById("container"));'),b=c('\nclass Demo2 extends React.Component {\n  handleLeftClick = () => {\n    alert(this.leftInput2.value);\n  };\n  render() {\n    return (\n      <div>\n        <input\n          ref={(currentNode) => (this.leftInput2 = currentNode)}\n          type="text"\n          placeholder="请输入数据"\n        />\n        &nbsp;\n        <button onClick={this.handleLeftClick}>点击提示左侧数据</button>\n      </div>\n    );\n  }\n}\nReactDOM.render(<Demo2 />, document.getElementById("container2"));'),m=c('\nclass Demo3 extends React.Component {\n  // 通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免更新过程中它会被执行两次\n  saveRef = (currentNode) => {\n    this.rightInput2 = currentNode;\n  };\n  render() {\n    return (\n      <div>\n        <input ref={this.saveRef} type="text" placeholder="请输入数据" />\n      </div>\n    );\n  }\n}\nReactDOM.render(<Demo3 />, document.getElementById("container2"));'),j=c('\nclass Demo3 extends React.Component {\n  /**\n   * React.createRef()\n   * 调用后可以返回一个容器，该容器可以存储被ref所标识的节点\n   * 该容器是【专人专用】，后声明的ref会覆盖前一个\n   */\n  myRef = React.createRef();\n\n  handleClick = () => {\n    console.log(this.myRef.current.value);\n  };\n  render() {\n    return (\n      <div>\n        <input ref={this.myRef} type="text" placeholder="请输入数据" />\n        &nbsp;\n        <button onClick={this.handleClick}>点击提示左侧数据</button>\n      </div>\n    );\n  }\n}'),V=c('\nclass Demo extends React.Component {\n    myRef = React.createRef();\n    handleClick = () => {\n      console.log(this.myRef.current.value);\n    };\n    handleBlur = (event) => {\n      console.log(event.target.value);\n    };\n    render() {\n      return (\n        <div>\n          <input ref={this.myRef} type="text" placeholder="请输入数据" />\n          &nbsp;\n          <button onClick={this.handleClick}>点击提示左侧数据</button>\n          <input\n            onBlur={this.handleBlur}\n            type="text"\n            placeholder="失去焦点提示数据"\n          />\n        </div>\n      );\n   }\n}'),v=c("\nclass Demo extends React.Component {\n    handleAsyncClick = (event) => {\n      // 直接使用会报错\n      setTimeout(() => {\n        console.log(event.target.innerText);\n      }, 1000);\n\n      // 解决办法\n      let text = event.target.innerText;\n      setTimeout(() => {\n        console.log(text);\n      }, 1000);\n    };\n    render() {\n      return (\n        <div>\n          <button onClick={this.handleAsyncClick}>异步展示</button>\n        </div>\n      );\n   }\n}"),N=c('\nclass Demo extends React.Component {\n  state = {\n    username: "",\n    password: "",\n  };\n  handleSubmit = () => {\n    event.preventDefault();\n    alert(\n      "用户名：" + this.state.username + "  密码：" + this.state.password\n    );\n  };\n  saveFormData = (type) => {\n    return (event) => {\n      this.setState({ [type]: event.target.value });\n    };\n  };\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        用户名：\n        <input\n          onChange={this.saveFormData("username")}\n          type="text"\n          name="username"\n        />\n        <br />\n        密码：\n        <input\n          onChange={this.saveFormData("password")}\n          type="password"\n          name="password"\n        />\n        <br />\n        <button>提交</button>\n      </form>\n    );\n  }\n}'),h=c('\nclass Demo extends React.Component {\n    handleSubmit = (event) => {\n      event.preventDefault();\n      const { username, password } = this;\n      alert(\'用户名：\' + username.value + \' 密码：\' + password.value);\n    };\n    render() {\n      return (\n        <div>\n          <form onSubmit={this.handleSubmit}>\n            用户名：\n            <input\n              ref={(node) => (this.username = node)}\n              type="text"\n              name="username"\n            />\n            <br />\n            密 码：\n            <input\n              ref={(node) => (this.password = node)}\n              type="password"\n              name="password"\n            />\n            <br />\n            <button>登录</button>\n          </form>\n        </div>\n      );\n    }\n}');return(e,t)=>{const c=Object(n["resolveComponent"])("RouterLink"),f=Object(n["resolveComponent"])("WebPrismEditor"),x=Object(n["resolveComponent"])("NavigationBlank");return Object(n["openBlock"])(),Object(n["createElementBlock"])(n["Fragment"],null,[Object(n["createElementVNode"])("h3",g,[Object(n["createVNode"])(c,{to:"#ReactGrammar",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 3、React 基础 ")]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",w,[Object(n["createVNode"])(c,{to:"#ReactJSX",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 1、JSX ")]),Object(n["createElementVNode"])("section",null,[Object(n["createElementVNode"])("div",null,[S,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(l),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(n["isRef"])(l)?l.value=e:null)},null,8,["modelValue"])]),Object(n["createElementVNode"])("div",null,[_,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(d),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(n["isRef"])(d)?d.value=e:null)},null,8,["modelValue"])])])]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",U,[Object(n["createVNode"])(c,{to:"#FunctionComponent",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 2、函数式组件 ")]),Object(n["createElementVNode"])("section",null,[P,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(a),"onUpdate:modelValue":t[2]||(t[2]=e=>Object(n["isRef"])(a)?a.value=e:null)},null,8,["modelValue"])])]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",I,[Object(n["createVNode"])(c,{to:"#ClassComponent",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 3、类式组件 ")]),Object(n["createElementVNode"])("section",null,[B,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(i),"onUpdate:modelValue":t[3]||(t[3]=e=>Object(n["isRef"])(i)?i.value=e:null)},null,8,["modelValue"]),F])]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",L,[Object(n["createVNode"])(c,{to:"#StateAndSetState",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 4、state与setState的理解使用 ")]),Object(n["createElementVNode"])("section",null,[J,Object(n["createElementVNode"])("div",null,[H,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(r),"onUpdate:modelValue":t[4]||(t[4]=e=>Object(n["isRef"])(r)?r.value=e:null)},null,8,["modelValue"])]),Object(n["createElementVNode"])("div",null,[A,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(s),"onUpdate:modelValue":t[5]||(t[5]=e=>Object(n["isRef"])(s)?s.value=e:null)},null,8,["modelValue"])])])]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",W,[Object(n["createVNode"])(c,{to:"#ReactProps",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 5、props的理解与使用 ")]),Object(n["createElementVNode"])("section",null,[Object(n["createElementVNode"])("div",q,[Object(n["createVNode"])(x,{modelValue:o.value,"onUpdate:modelValue":t[6]||(t[6]=e=>o.value=e)},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("使用 PropTypes 进行类型检查")]),_:1},8,["modelValue"])]),X,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(u),"onUpdate:modelValue":t[7]||(t[7]=e=>Object(n["isRef"])(u)?u.value=e:null)},null,8,["modelValue"]),z,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(p),"onUpdate:modelValue":t[8]||(t[8]=e=>Object(n["isRef"])(p)?p.value=e:null)},null,8,["modelValue"])])]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",$,[Object(n["createVNode"])(c,{to:"#ReactRef",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 6、ref的理解与使用 ")]),Object(n["createElementVNode"])("section",null,[G,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(O),"onUpdate:modelValue":t[9]||(t[9]=e=>Object(n["isRef"])(O)?O.value=e:null)},null,8,["modelValue"]),K,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(b),"onUpdate:modelValue":t[10]||(t[10]=e=>Object(n["isRef"])(b)?b.value=e:null)},null,8,["modelValue"]),Q,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(m),"onUpdate:modelValue":t[11]||(t[11]=e=>Object(n["isRef"])(m)?m.value=e:null)},null,8,["modelValue"]),Y,Z,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(j),"onUpdate:modelValue":t[12]||(t[12]=e=>Object(n["isRef"])(j)?j.value=e:null)},null,8,["modelValue"])])]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",ee,[Object(n["createVNode"])(c,{to:"#HasStateComponent",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 7、有无状态组件 ")]),te]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",ce,[Object(n["createVNode"])(c,{to:"#ControlComponent",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 8、受控组件和非受控组件 ")]),Object(n["createElementVNode"])("section",null,[Object(n["createElementVNode"])("div",null,[ne,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(N),"onUpdate:modelValue":t[13]||(t[13]=e=>Object(n["isRef"])(N)?N.value=e:null)},null,8,["modelValue"])]),Object(n["createElementVNode"])("div",null,[oe,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(h),"onUpdate:modelValue":t[14]||(t[14]=e=>Object(n["isRef"])(h)?h.value=e:null)},null,8,["modelValue"])])])]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",le,[Object(n["createVNode"])(c,{to:"#EventBind",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 9、事件代理 ")]),Object(n["createElementVNode"])("section",null,[de,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(V),"onUpdate:modelValue":t[15]||(t[15]=e=>Object(n["isRef"])(V)?V.value=e:null)},null,8,["modelValue"]),ae,Object(n["createVNode"])(f,{modelValue:Object(n["unref"])(v),"onUpdate:modelValue":t[16]||(t[16]=e=>Object(n["isRef"])(v)?v.value=e:null)},null,8,["modelValue"])])])],64)}}});const re=ie;var se=re;const ue={id:"ReactLifeCycle"},pe=Object(n["createStaticVNode"])('<div><section><div><p class="c-h6">生命周期的三个阶段( <span class="red">旧</span> )</p><div><ul><li> 1. 初始化阶段：由ReactDOM.render()触发 --- 初次渲染 <div type="cricle"><ul><li><code>constructor()</code></li><li><code>componentWillMount()</code><div><ul type="square"><li><code>componentWillMount</code> ：React16之前写法 </li><li><code>UNSAFE_componentWillMount</code> ：React16 之后的写法，因为即将废弃 </li></ul></div></li><li><code>render()</code></li><li><code>componentDidMount()</code> =====&gt; 常用</li></ul></div></li><li> 2. 更新阶段：由组件内部this.setState() | 父组件render触发 | this.forceUpdate()触发 <div type="cricle"><ul><li><code>componentWillReceiveProps()</code><div><ul type="square"><li><code>componentWillReceiveProps</code> ：React16之前写法 </li><li><code>UNSAFE_componentWillReceiveProps</code> ：React16 之后的写法，因为即将废弃 </li></ul></div></li><li><code>shouldComponentUpdate()</code></li><li><code>componentWillUpdate()</code><div><ul type="square"><li><code>componentWillUpdate</code> ：React16之前写法 </li><li><code>UNSAFE_componentWillUpdate</code> ：React16 之后的写法，因为即将废弃 </li></ul></div></li><li><code>render()</code></li><li><code>componentDidUpdate()</code></li></ul></div></li><li> 3. 卸载阶段：由ReactDOM.unmountComponentAtNode()触发 <div type="cricle"><ul><li><code>componentWillUnmount</code> =====&gt; 常用</li></ul></div></li></ul></div></div><div><p class="c-h6">生命周期的三个阶段( <span class="red">新</span> )</p><div><ul><li> 1. 初始化阶段：由ReactDOM.render()触发 --- 初次渲染 <div type="cricle"><ul><li><code>constructor()</code></li><li><code class="red">getDerivedStateFromProps()</code></li><li><code>render()</code></li><li><code>componentDidMount()</code> =====&gt; 常用</li></ul></div></li><li> 2. 更新阶段：由组件内部this.setState() | 父组件render触发 | this.forceUpdate()触发 <div type="cricle"><ul><li><code class="red">getDerivedStateFromProps()</code></li><li><code>shouldComponentUpdate()</code></li><li><code>render()</code></li><li><code class="red">getSnapshotBeforeUpdate()</code></li><li><code>componentDidUpdate()</code></li></ul></div></li><li> 3. 卸载阶段：由ReactDOM.unmountComponentAtNode()触发 <div type="cricle"><ul><li><code>componentWillUnmount</code> =====&gt; 常用</li></ul></div></li></ul></div></div></section></div>',1),Oe={id:"ReactThouseLifeCycle"},be=Object(n["createStaticVNode"])('<section><blockquote class="be-careful"><p class="title">注意：</p><div> 此处只讲述 React 版本 &gt;= 16.4版本的生命周期，下一节会讲述到 React 曾废弃了那些声明周期 ，以及废弃原因。 </div></blockquote><div><div><p class="c-h5">1. 组件挂载阶段</p><div><p class="c-h6">1) constructor</p></div><div><p class="c-h6">2) getDerivedStateFromProps</p></div><div><p class="c-h6">3) render</p></div><div><p class="c-h6">4) componentDidMount</p></div></div><div><p class="c-h5">2. 组件更新阶段</p><div><p class="c-h6">1) shouldComponentUpdate</p></div><div><p class="c-h6">2) getSnapShotBeforeUpdate</p></div><div><p class="c-h6">3) componentDidUpdate</p></div></div><div><p class="c-h5">3. 组件卸载阶段</p></div><div><p class="c-h5">4. 错误处理阶段</p></div></div></section>',1),me={id:"ReactDiscardLifeCycle"},je={id:"ReactNewLifeCycle"},Ve={id:"ReactNewLifeAndOldLife"},ve={id:"ReactPerformanceOptimize"};var Ne=Object(n["defineComponent"])({__name:"componentLifeCycle",setup(e){const t=Object(n["getCurrentInstance"])(),{$builtIn:c}=null===t||void 0===t?void 0:t.appContext.config.globalProperties;return(e,t)=>{const c=Object(n["resolveComponent"])("RouterLink");return Object(n["openBlock"])(),Object(n["createElementBlock"])(n["Fragment"],null,[Object(n["createElementVNode"])("h3",ue,[Object(n["createVNode"])(c,{to:"#ReactLifeCycle",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 4、React 生命周期 ")]),pe,Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",Oe,[Object(n["createVNode"])(c,{to:"#ReactThouseLifeCycle",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 1、React 组件生命周期有哪些？ ")]),be]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",me,[Object(n["createVNode"])(c,{to:"#ReactDiscardLifeCycle",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 2、React废弃的生命周期 ")])]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",je,[Object(n["createVNode"])(c,{to:"#ReactNewLifeCycle",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 3、React新增的生命周期 ")])]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",Ve,[Object(n["createVNode"])(c,{to:"#ReactNewLifeAndOldLife",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 4、对比新旧生命周期 ")])]),Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("h4",ve,[Object(n["createVNode"])(c,{to:"#ReactPerformanceOptimize",class:"a-link"},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])("#")]),_:1}),Object(n["createTextVNode"])(" 5、React 性能优化在哪个生命周期？它优化的原理是什么？ ")])])],64)}}});const he=Ne;var fe=he;const xe={class:"main"},Re=Object(n["createElementVNode"])("h2",null,"react 基础",-1),De={class:"overview"},Ee=Object(n["createElementVNode"])("span",{class:"serial-no"},"1.",-1),Ce=Object(n["createElementVNode"])("span",{class:"serial-no"},"2.",-1),Me=Object(n["createElementVNode"])("span",{class:"serial-no"},"3.",-1),Te=Object(n["createElementVNode"])("span",{class:"serial-no"},"4.",-1);var ye=Object(n["defineComponent"])({__name:"index",setup(e){const t=Object(n["getCurrentInstance"])(),{$builtIn:c}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,o=Object(n["ref"])("https://react.docschina.org/docs/hello-world.html"),l=Object(n["ref"])("https://www.jianshu.com/p/37d7de212df1"),d=Object(n["ref"])("https://goshacmd.com/controlled-vs-uncontrolled-inputs-react/"),a=Object(n["ref"])("https://www.jianshu.com/p/021736302706");return(e,t)=>{const c=Object(n["resolveComponent"])("navigationBlank");return Object(n["openBlock"])(),Object(n["createElementBlock"])("div",xe,[Re,Object(n["createElementVNode"])("div",De,[Object(n["createElementVNode"])("div",null,[Ee,Object(n["createVNode"])(c,{modelValue:o.value,"onUpdate:modelValue":t[0]||(t[0]=e=>o.value=e)},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" react官网资料 ")]),_:1},8,["modelValue"])]),Object(n["createElementVNode"])("div",null,[Ce,Object(n["createVNode"])(c,{modelValue:l.value,"onUpdate:modelValue":t[1]||(t[1]=e=>l.value=e)},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" 由浅入深快速掌握React Fiber ")]),_:1},8,["modelValue"])]),Object(n["createElementVNode"])("div",null,[Me,Object(n["createVNode"])(c,{modelValue:d.value,"onUpdate:modelValue":t[2]||(t[2]=e=>d.value=e)},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" 受控组件和非受控组件 ")]),_:1},8,["modelValue"])]),Object(n["createElementVNode"])("div",null,[Te,Object(n["createVNode"])(c,{modelValue:a.value,"onUpdate:modelValue":t[3]||(t[3]=e=>a.value=e)},{default:Object(n["withCtx"])(()=>[Object(n["createTextVNode"])(" React 生命周期&执行顺序 ")]),_:1},8,["modelValue"])])]),Object(n["createVNode"])(p),Object(n["createVNode"])(k),Object(n["createVNode"])(se),Object(n["createVNode"])(fe)])}}});const ke=ye;t["default"]=ke}}]);