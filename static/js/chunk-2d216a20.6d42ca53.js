(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d216a20"],{c2fa:function(e,t,n){"use strict";n.r(t);var l=n("7a23");const c={class:"main"},o=Object(l["createElementVNode"])("h2",{id:"javascript"},"javascript基础问题梳理",-1),a={id:"This"},r={id:"GlobalFunction"},d=Object(l["createElementVNode"])("p",null,[Object(l["createTextVNode"])("this指向全局对象window，"),Object(l["createElementVNode"])("span",{class:"red"},"注意严格模式下"),Object(l["createTextVNode"])("，this为undefined")],-1),s={id:"ObjectMethod"},i=Object(l["createElementVNode"])("p",null,"this指向调用该方法的对象",-1),u={id:"Constructor"},b=Object(l["createElementVNode"])("p",null,[Object(l["createTextVNode"])("this指向 "),Object(l["createElementVNode"])("span",{class:"red"},"new 关键字 "),Object(l["createTextVNode"])("创建出的实例")],-1),m={id:"SetTimeout"},j=Object(l["createElementVNode"])("p",null,[Object(l["createTextVNode"])("定时器 setTimeout 或 setInterval，以及回调函数或匿名函数自调用，"),Object(l["createElementVNode"])("span",{class:"red"},"this指向全局对象window")],-1),O={id:"EventFunction"},V=Object(l["createElementVNode"])("p",null,"元素绑定事件，事件触发后执行函数，this指向的是当前元素",-1),N={id:"ArrowFunction"},h=Object(l["createElementVNode"])("p",null,"this指向箭头函数定义时所处的对象",-1),p={id:"CallApplyBind"},v=Object(l["createStaticVNode"])('<section><ul type="square"><li> call和apply：<span class="red">改变 this 指向后</span>执行函数。 <ul style="margin-left:1rem;" type="circle"><li>call(thisScope,arg1,arg2,arg...);<span class="red"> 多个参数，第一个参数为null、undefined时，默认指向Window</span></li><li>apply(thisScope,[arg1,arg2,arg...]);<span class="red"> 两个参数</span></li></ul></li></ul><ul type="square"><li>bind: 改变 this 指向后，返回函数，不执行。</li><p>bind(thisScopr,arg1,arg2,arg...) 多个参数</p></ul></section>',1),f=Object(l["createElementVNode"])("div",null,[Object(l["createElementVNode"])("div",{class:"c-h5"},"apply的使用方法(函数劫持、对象复制)"),Object(l["createElementVNode"])("div",{class:"indent"},[Object(l["createElementVNode"])("span",null,[Object(l["createTextVNode"])("可以看到 Student 不具备任何方法，但是在 "),Object(l["createElementVNode"])("span",{class:"red"},"Person.apply(this,arguments)"),Object(l["createTextVNode"])("之后，他就具备了Person类的方法及属性")])]),Object(l["createElementVNode"])("div",null,"由此得出结论： Function.apply() 能“劫持”另外一个对象， 继承另外一个对象的属性")],-1),E={id:"Promise"},x={id:"Reference"},g=Object(l["createStaticVNode"])('<section><div><span>1.</span><a target="_blank" rel="help" href="http://liubin.org/promises-book/" class="a-navigation">JavaScript Promise迷你书(中文版)</a></div><div><span>2.</span><a target="_blank" href="https://juejin.cn/post/6844903455962693640" class="a-navigation">深入理解Promise(上)</a></div><div><span>3.</span><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903667494027278">从手写一个符合Promise/A+规范Promise来深入学习Promise</a></div><div><span>4.</span><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903550288412679">Promise深度学习---我のPromise/A+实现 </a></div><div><span>5.</span><a target="_blank" class="a-navigation" href="https://mp.weixin.qq.com/s/Yrwe2x6HukfqJZM6HkmRcw">【第1738期】100 行代码实现 Promises/A+ 规范</a></div><div><span>6.</span><a target="_blank" class="a-navigation" href="https://zhuanlan.zhihu.com/p/144058361">从零开始手写Promise </a></div><div><span>7.</span><a target="_blank" class="a-navigation" href="https://blog.csdn.net/weixin_56650035/article/details/121070438?spm=1001.2014.3001.5502">PromiseA+规范之手写Promise </a></div></section>',1),P={id:"ConstructorStatus"},y=Object(l["createElementVNode"])("div",{class:"c-h5"},"1. 构造函数",-1),T=Object(l["createStaticVNode"])('<section><div class="c-h5">2. 状态</div><section><ul><li>初始状态 -&gt; pending <ul type="cricle" class="ml-15"><li>初始状态可以改变</li><li>在resolve 或者 reject 调用之前都处于这个状态</li></ul></li><li>最终成功状态 -&gt; fulfilled <ul type="cricle" class="ml-15"><li>执行 resolve 函数，状态改变为 fulfilled</li><li>执行 onFulfilled 函数</li></ul></li><li>最终失败状态 -&gt; rejected <ul type="cricle" class="ml-15"><li>执行 reject 函数，状态改变为 rejected</li><li>执行 onRejected 函数</li></ul></li><li>then 方法 <ul type="cricle" class="ml-15"><li>then 方法为 Promise 对象注册了 onFulfilled 和 onRejected 函数</li></ul></li><li>catch 方法 <ul type="cricle" class="ml-15"><li>catch 方法为Promise 对象注册了 onRejected 函数</li></ul></li></ul></section></section>',1),w={id:"EightMethods"},k=Object(l["createElementVNode"])("div",{class:"c-h5"},"1. Promise.resolve",-1),C=Object(l["createElementVNode"])("p",{class:"indent"},[Object(l["createTextVNode"])("静态方法"),Object(l["createElementVNode"])("code",null,"Promise.resolve(value)"),Object(l["createTextVNode"])("可以认为是"),Object(l["createElementVNode"])("code",null,"new Promise"),Object(l["createTextVNode"])("方法的语法糖,比如"),Object(l["createElementVNode"])("code",null,"Promise.resolve(42)"),Object(l["createTextVNode"])(" 可以认为是以下代码的语法糖 ")],-1),R={class:"indent"},B=Object(l["createElementVNode"])("code",null,"Promise",-1),_=Object(l["createElementVNode"])("code",null,"onFulfilled",-1),S=Object(l["createElementVNode"])("code",null,"new Promise",-1),A=Object(l["createElementVNode"])("code",null,"Promise",-1),F=Object(l["createElementVNode"])("p",{class:"indent"},[Object(l["createTextVNode"])(" 简单总结一下 "),Object(l["createElementVNode"])("code",null,"Promise.resolve"),Object(l["createTextVNode"])("方法的话，它的作用就是将传递给它的参数填充 "),Object(l["createElementVNode"])("code",null,"Fulfilled"),Object(l["createTextVNode"])(" 到 "),Object(l["createElementVNode"])("code",null,"Promise"),Object(l["createTextVNode"])(" 对象后并返回这个 "),Object(l["createElementVNode"])("code",null,"Promise"),Object(l["createTextVNode"])(" 对象。 ")],-1),U=Object(l["createElementVNode"])("div",{class:"c-h5"},"2. Promise.reject",-1),H=Object(l["createElementVNode"])("p",{class:"indent"},[Object(l["createElementVNode"])("code",null,"Promise.reject(error)"),Object(l["createTextVNode"])("是和"),Object(l["createElementVNode"])("code",null,"Promise.resolve(value)"),Object(l["createTextVNode"])("类似的静态方法，是 "),Object(l["createElementVNode"])("code",null,"new Promise"),Object(l["createTextVNode"])(" 方法的快捷方式。比如 "),Object(l["createElementVNode"])("code",null,'Promise.reject(new Error("Promise reject error"))'),Object(l["createTextVNode"])(" 就是下面代码的语法糖形式 ")],-1),G=Object(l["createElementVNode"])("p",{class:"indent"},[Object(l["createTextVNode"])(" 简单总结一下 "),Object(l["createElementVNode"])("code",null,"Promise.reject"),Object(l["createTextVNode"])("方法的话：它的功能是调用该 "),Object(l["createElementVNode"])("code",null,"Promise"),Object(l["createTextVNode"])("对象通过then指定的 "),Object(l["createElementVNode"])("code",null,"onRejected"),Object(l["createTextVNode"])("函数，并讲错误（Error）对象传递给这个"),Object(l["createElementVNode"])("code",null,"onRejected"),Object(l["createTextVNode"])("函数 ")],-1),I=Object(l["createElementVNode"])("div",{class:"c-h5"},"3. Promise.then",-1),M=Object(l["createElementVNode"])("p",null,[Object(l["createElementVNode"])("code",null,"Promise.then(onFulfilled, onRejected)")],-1),q=Object(l["createElementVNode"])("div",{class:"c-h6"},"① 函调函数异步执行",-1),W=Object(l["createElementVNode"])("p",null,[Object(l["createElementVNode"])("code",null,"Promise/A+规范"),Object(l["createTextVNode"])("统一规定：Promise 只能使用异步调用方式 ")],-1),z=Object(l["createStaticVNode"])('<div class="c-h6">② 返回值</div><p class="indent">不管你在回调函数 <code>onFulfilled</code>中会返回一个什么样的值，或者不返回值，该值都会由 <code>Promis.resolve(return 的返回值)</code> 进行响应的包装处理。因此，最终 <code>then</code>的结果都是返回一个新创建的 <code>Promise</code>对象。 </p><p class="indent"> 也就是说，<code>Promis.then</code>不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个<code>Promise</code> 对象。正是 <code>then</code>函数中有了这样返回值的机制，才能使得在整个<code>Promise</code>链式结构当中，每个<code>then</code>方法都能给 下一个<code>then</code>方法传递参数。现在我们知道怎么返回的<code>Promise</code>是之前的还是新的？另外该<code>Promise</code>的状态又是如何？ </p>',3),J=Object(l["createElementVNode"])("p",null,[Object(l["createTextVNode"])("从上面结果来看，实际上不管是调用 "),Object(l["createElementVNode"])("code",null,"then"),Object(l["createTextVNode"])("还是"),Object(l["createElementVNode"])("code",null,"catch"),Object(l["createTextVNode"])("方法， 都返回了一个新的"),Object(l["createElementVNode"])("code",null,"Promise"),Object(l["createTextVNode"])("对象")],-1),D=Object(l["createElementVNode"])("div",{class:"c-h6"},"③ promise穿透",-1),L=Object(l["createElementVNode"])("p",null,"我们先来举个例子：",-1),Y=Object(l["createElementVNode"])("p",null,"如果你认为输出的是【 Barry Promise 】，那么你就错了，实际上他输出的是 【 Barry 】",-1),Z=Object(l["createElementVNode"])("p",null,[Object(l["createTextVNode"])("产生这么的输出是因为你给"),Object(l["createElementVNode"])("code",null,"then"),Object(l["createTextVNode"])("方法传递了一个非函数(比如"),Object(l["createElementVNode"])("code",null,"promise"),Object(l["createTextVNode"])("对象)的值，代码会这样理解 : "),Object(l["createElementVNode"])("code",null,"then(null)"),Object(l["createTextVNode"])(",因此导致了前一个"),Object(l["createElementVNode"])("code",null,"promise"),Object(l["createTextVNode"])("的结果产生了坠落的效果，也就是和下面代码是一样的， 代码直接穿透了"),Object(l["createElementVNode"])("code",null,"then(null)"),Object(l["createTextVNode"])("进入了下一层链： ")],-1),$=Object(l["createElementVNode"])("p",null,[Object(l["createTextVNode"])("随意添加多个"),Object(l["createElementVNode"])("code",null,"then(null)"),Object(l["createTextVNode"])("结果都是一样的")],-1),K=Object(l["createStaticVNode"])('<section><div class="c-h5">4. Promise.catch</div></section><section><div class="c-h5">5. Promise.finally</div></section><section><div class="c-h5">6. Promise.all</div></section><section><div class="c-h5">7. Promise.allSettled</div></section><section><div class="c-h5">8. Promise.race</div></section>',5),Q={id:"ErrorCapture"},X={id:"ReturnValue"},ee={id:"WritePromise"},te={id:"AsyncAwait"},ne=Object(l["createStaticVNode"])('<div><h3 id="Generator">3、Generator</h3><h4 id="Iterator">1、迭代器Iterator</h4><h4 id="SubGenerator">2、生成器Generator</h4><h4 id="AutoGenerator">3、Generator自动执行</h4></div><h3 id="DeepClone">4、深拷贝和浅拷贝</h3>',2);var le=Object(l["defineComponent"])({__name:"index",setup(e){const t=Object(l["getCurrentInstance"])(),{$builtIn:n}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,le=n("\n// 'not strict' 【window】\nconsole.log(this);\nfunction funs(){\n    console.log(this); \n};\nfuns();\n\n// 'use stract' 【undefined】\nfunction stractDemo(){\n    'use strict'\n    console.log(this);\n};\nstractDemo();\n"),ce=n("\nlet name = 'Global Barry';\nlet obj = {\n    name: 'Obj Barry',\n    getName: function(){\n        console.log(this.name)\n    },\n};\nobj.getName(); // 'Obj Barry'\n\nlet funs = obj.getName;\nfuns(); // 'Global Barry'\n"),oe=n('\nfunction Barry(){\n    this.name = "Fashion pro Barry";\n    console.log(this);\n}\n\nlet n = new Barry();\nconsole.log(n)\n'),ae=n('\n// setTimeout\nsetTimeout(function () {\n    console.log(this)\n}, 0)\n\nvar name = "my name is window"; // 注意var 和 const 输出是不一样的\nvar obj = {\n    name: "my name is obj",\n    funs: function () {\n        let timer = null;\n        clearInterval(timer);\n        timer = setInterval(function () {\n            console.log(this.name); // "my name is window"\n        }, 100);\n    },\n};\nobj.funs();\n\n\n// 回调函数\nvar o = {\n    age: 18,\n    say: function () {\n        function callback() {\n            return this.age;\n        }\n        func(callback);\n    },\n};\nfunction func(callback) {\n    var name = "Fashion Barry";\n    console.log(name, " is", callback() + " years"); \n}\no.say(); // Fashion Barry  is undefined years\n/**\n * 【解析】：\n * 函数内部的【this】指向于此函数的调用者（拥有者）\n * 但在上面这个例子中，为什么会输出unidentified\n * 虽然【callback】定义在对象【o】的【say】方法中，但实际上由于【callback】是在【func】函数中被普通调用的\n * 那么【func】中的【callback】的调用对象我们可以理解为【window】对象\n * 当使用一个对象未定义的属性时不会报错，会返回undefined，而直接使用一个未定义的变量便会报错\n*/\n\n'),re=n('\n<button id="btn">click me</button>\n\nwindow.onload = function () {\n    var btn = document.getElementById("btn");\n    btn.onclick = function () {\n        console.log(this);\n    };\n};\n'),de=n('\nvar name = "my name is window";\nvar obj = {\n    name: "my name is obj",\n    func: function () {\n        return (() => {\n            console.log(this.name); // my name is obj\n        })();\n    },\n};\nobj.func()\n'),se=n('\n// 对象方法:this指向方法前的对象\nvar person = {\n  name: "dog",\n  say: function (language) {\n    console.log(this.name + " say " + language);\n  },\n};\nperson.say("Hello world!");\n\n//call  改变this指向，传入多个参数\nvar name = "duck";\nperson.say.call(window, "Helo Window!");\n\n//apply 改变this指向，两个参数\n// person.say.apply(this, "Hello Apply!"); // 会报错TypeError: CreateListFromArrayLike called on non-object\n\nperson.say.apply(window, { name: "Hello Apply!" }); // nduck say undefined\n// apply 的第二个参数必须为数组\nperson.say.apply(this, ["Hello Apply!"]); // duck say Hello Apply\n\nvar arr = [1, 2, 3, 4];\nMath.max.apply(null, arr); //4, null表示不改变this指向\n\n// bind:改变this指向，不立即调用，而是返回该函数\nfunction multiply(x, y, z) {\n  return x * y * z;\n}\n\nvar double = multiply.bind(null, 2);\nconsole.log(double(3, 4)); // 24\n\nvar person1 = {\n  name: "dog",\n  sayHello: function () {\n    setTimeout(\n      function () {\n        console.log(this.name + " Say Hello!");\n      }.bind(this),\n      1000\n    );\n  },\n};\n\nperson1.sayHello(); //dog Say Hello!\n\n'),ie=n('\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayHello = function () {\n    console.log(this.name + " Say hello!");\n  };\n}\n\nfunction Student(name, age, grade) {\n  Person.apply(this, arguments);\n  this.grade = grade;\n}\n\nvar s = new Student("Barry", 18, "middle school");\nconsole.log(s.name); // Barry\nconsole.log(s.age); // 18\nconsole.log(s.grade); //middle school\ns.sayHello(); // Barry Say hello!\n'),ue=n("\n// 面试题解析\nvar x = 20;\nvar a = {\n  x: 15,\n  fn: function () {\n    var x = 30;\n    return function () {\n      return this.x;\n    };\n  },\n};\n\nconsole.log(a.fn()); // Function ƒ(){return this.x}\nconsole.log((a.fn())()); // 20 a.fn()返回的是一个函数，()()这是自执行表达式。this -> window\nconsole.log(a.fn()()); // 20 a.fn()相当于在全局定义了一个函数，然后再自己调用执行。this -> window\nconsole.log(a.fn()() == (a.fn())()); //true\nconsole.log(a.fn().call(this)); // 20 这段代码在全局环境中执行，this -> window\nconsole.log(a.fn().call(a)); // 15, 更改this指向为 a，a的x为15\n\n"),be=n("\nvar promise = new Promise(function (resolve, reject) {\n  // 异步处理\n  // 处理结果成功调用 resolve\n  // 失败调用 reject\n});\n"),me=n("\nnew Promise(function (resolve) {\n    resolve(42)\n})\n"),je=n('\nnew Promise(function (reject) {\n    reject(new Error("Promise reject error"))\n})\n'),Oe=n('\nvar promise = new Promise((resolve, reject) => {\n  console.log("inner Promise"); // 1\n  setTimeout(() => {\n    resolve("Fashion Barry"); // 3\n  }, 1000);\n});\n\npromise.then((res) => {\n  console.log("res", res);\n});\nconsole.log("outer promise"); // 2\n// Promise 实际是一个同步函数，then 方法才是异步\n// 所以输出顺序如上\n'),Ve=n('\nvar aPromise = new Promise((resolve, reject) => {\n  resolve("aPromise");\n});\nvar thenPromise = aPromise.then((res) => {\n  console.log("thenPromise: ", res);\n});\nvar catchPromise = aPromise.catch((err) => {\n  console.error("catchPromise: ", err);\n});\n\nconsole.log(aPromise !== thenPromise); // true\nconsole.log(thenPromise !== catchPromise); // true\nconsole.log(aPromise, thenPromise, catchPromise); // Promise { "aPromise" }, Promise { <pending> }, Promise { <pending> }\n'),Ne=n('\nPromise.resolve("Barry")\n.then(Promise.resolve("Barry Promise"))\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),he=n('\nPromise.resolve("Barry")\n.then(null)\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),pe=n('\nPromise.resolve("Barry")\n.then(null)\n.then({ name: "My name is Barry" })\n.then(null)\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n');return(e,t)=>{const n=Object(l["resolveComponent"])("RouterLink"),ve=Object(l["resolveComponent"])("WebPrismEditor"),fe=Object(l["resolveComponent"])("cod");return Object(l["openBlock"])(),Object(l["createElementBlock"])("div",c,[o,Object(l["createElementVNode"])("div",null,[Object(l["createElementVNode"])("h3",a,[Object(l["createVNode"])(n,{to:"#This",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])(" 1、This指向 ")]),Object(l["createElementVNode"])("div",null,[Object(l["createElementVNode"])("h4",r,[Object(l["createVNode"])(n,{to:"#GlobalFunction",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("1、全局函数 ")]),Object(l["createElementVNode"])("section",null,[d,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(le),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(l["isRef"])(le)?le.value=e:null)},null,8,["modelValue"])])]),Object(l["createElementVNode"])("div",null,[Object(l["createElementVNode"])("h4",s,[Object(l["createVNode"])(n,{to:"#ObjectMethod",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("2、对象方法 ")]),Object(l["createElementVNode"])("section",null,[i,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(ce),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(l["isRef"])(ce)?ce.value=e:null)},null,8,["modelValue"])])]),Object(l["createElementVNode"])("div",null,[Object(l["createElementVNode"])("h4",u,[Object(l["createVNode"])(n,{to:"#Constructor",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("3、构造函数 ")]),Object(l["createElementVNode"])("section",null,[b,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(oe),"onUpdate:modelValue":t[2]||(t[2]=e=>Object(l["isRef"])(oe)?oe.value=e:null)},null,8,["modelValue"])])]),Object(l["createElementVNode"])("div",null,[Object(l["createElementVNode"])("h4",m,[Object(l["createVNode"])(n,{to:"#SetTimeout",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("4、定时器、回调函数 ")]),Object(l["createElementVNode"])("section",null,[j,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(ae),"onUpdate:modelValue":t[3]||(t[3]=e=>Object(l["isRef"])(ae)?ae.value=e:null)},null,8,["modelValue"])])]),Object(l["createElementVNode"])("div",null,[Object(l["createElementVNode"])("h4",O,[Object(l["createVNode"])(n,{to:"#EventFunction",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("5、事件函数 ")]),Object(l["createElementVNode"])("section",null,[V,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(re),"onUpdate:modelValue":t[4]||(t[4]=e=>Object(l["isRef"])(re)?re.value=e:null)},null,8,["modelValue"])])]),Object(l["createElementVNode"])("div",null,[Object(l["createElementVNode"])("h4",N,[Object(l["createVNode"])(n,{to:"#ArrowFunction",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("6、箭头函数 ")]),Object(l["createElementVNode"])("section",null,[h,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(de),"onUpdate:modelValue":t[5]||(t[5]=e=>Object(l["isRef"])(de)?de.value=e:null)},null,8,["modelValue"])])]),Object(l["createElementVNode"])("div",null,[Object(l["createElementVNode"])("h4",p,[Object(l["createVNode"])(n,{to:"#CallApplyBind",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("7、call、apply、bind ")]),Object(l["createElementVNode"])("section",null,[v,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(se),"onUpdate:modelValue":t[6]||(t[6]=e=>Object(l["isRef"])(se)?se.value=e:null)},null,8,["modelValue"]),f,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(ie),"onUpdate:modelValue":t[7]||(t[7]=e=>Object(l["isRef"])(ie)?ie.value=e:null)},null,8,["modelValue"]),Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(ue),"onUpdate:modelValue":t[8]||(t[8]=e=>Object(l["isRef"])(ue)?ue.value=e:null)},null,8,["modelValue"])])])]),Object(l["createElementVNode"])("div",null,[Object(l["createElementVNode"])("h3",E,[Object(l["createVNode"])(n,{to:"#Promise",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("2、Promise(异步编程) ")]),Object(l["createElementVNode"])("div",null,[Object(l["createElementVNode"])("h4",x,[Object(l["createVNode"])(n,{to:"#Reference",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("1、参考资料 ")]),g]),Object(l["createElementVNode"])("div",null,[Object(l["createElementVNode"])("h4",P,[Object(l["createVNode"])(n,{to:"#ConstructorStatus",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("2、构造函数和状态 ")]),Object(l["createElementVNode"])("section",null,[y,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(be),"onUpdate:modelValue":t[9]||(t[9]=e=>Object(l["isRef"])(be)?be.value=e:null)},null,8,["modelValue"])]),T]),Object(l["createElementVNode"])("div",null,[Object(l["createElementVNode"])("h4",w,[Object(l["createVNode"])(n,{to:"#EightMethods",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("3、八大方法 ")]),Object(l["createElementVNode"])("section",null,[k,C,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(me),"onUpdate:modelValue":t[10]||(t[10]=e=>Object(l["isRef"])(me)?me.value=e:null)},null,8,["modelValue"]),Object(l["createElementVNode"])("p",R,[Object(l["createTextVNode"])("这个静态方法会让"),B,Object(l["createTextVNode"])("对象立即进入确定(即resolved) 状态，并将42传递给后面 "),Object(l["createVNode"])(fe,null,{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("then")]),_:1}),Object(l["createTextVNode"])(" 里所指定的 "),_,Object(l["createTextVNode"])("函数。作为 "),S,Object(l["createTextVNode"])("的快捷方式，在进行 "),A,Object(l["createTextVNode"])(" 对象的初始化或者编写测试代码的时候都非常方便。 ")]),F]),Object(l["createElementVNode"])("section",null,[U,H,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(je),"onUpdate:modelValue":t[11]||(t[11]=e=>Object(l["isRef"])(je)?je.value=e:null)},null,8,["modelValue"]),G]),Object(l["createElementVNode"])("section",null,[I,M,Object(l["createElementVNode"])("div",null,[q,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(Oe),"onUpdate:modelValue":t[12]||(t[12]=e=>Object(l["isRef"])(Oe)?Oe.value=e:null)},null,8,["modelValue"]),W]),Object(l["createElementVNode"])("div",null,[z,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(Ve),"onUpdate:modelValue":t[13]||(t[13]=e=>Object(l["isRef"])(Ve)?Ve.value=e:null)},null,8,["modelValue"]),J]),Object(l["createElementVNode"])("div",null,[D,L,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(Ne),"onUpdate:modelValue":t[14]||(t[14]=e=>Object(l["isRef"])(Ne)?Ne.value=e:null)},null,8,["modelValue"]),Y,Z,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(he),"onUpdate:modelValue":t[15]||(t[15]=e=>Object(l["isRef"])(he)?he.value=e:null)},null,8,["modelValue"]),$,Object(l["createVNode"])(ve,{modelValue:Object(l["unref"])(pe),"onUpdate:modelValue":t[16]||(t[16]=e=>Object(l["isRef"])(pe)?pe.value=e:null)},null,8,["modelValue"])])]),K]),Object(l["createElementVNode"])("h4",Q,[Object(l["createVNode"])(n,{to:"#ErrorCapture",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("4、错误捕获 ")]),Object(l["createElementVNode"])("h4",X,[Object(l["createVNode"])(n,{to:"#ReturnValue",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("5、返回值 ")]),Object(l["createElementVNode"])("h4",ee,[Object(l["createVNode"])(n,{to:"#WritePromise",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("6、手写Promise ")]),Object(l["createElementVNode"])("h4",te,[Object(l["createVNode"])(n,{to:"#AsyncAwait",class:"a-link"},{default:Object(l["withCtx"])(()=>[Object(l["createTextVNode"])("#")]),_:1}),Object(l["createTextVNode"])("7、async和await ")])]),ne])}}});const ce=le;t["default"]=ce}}]);