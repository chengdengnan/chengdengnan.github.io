(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d216a20"],{c2fa:function(e,t,o){"use strict";o.r(t);var c=o("7a23");const n={class:"main"},l=Object(c["createElementVNode"])("h2",{id:"javascript"},"javascript基础问题梳理",-1),r={id:"This"},d={id:"GlobalFunction"},a=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("this指向全局对象window，"),Object(c["createElementVNode"])("span",{class:"red"},"注意严格模式下"),Object(c["createTextVNode"])("，this为undefined")],-1),i={id:"ObjectMethod"},s=Object(c["createElementVNode"])("p",null,"this指向调用该方法的对象",-1),m={id:"Constructor"},u=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("this指向 "),Object(c["createElementVNode"])("span",{class:"red"},"new 关键字 "),Object(c["createTextVNode"])("创建出的实例")],-1),j={id:"SetTimeout"},b=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("定时器 setTimeout 或 setInterval，以及回调函数或匿名函数自调用，"),Object(c["createElementVNode"])("span",{class:"red"},"this指向全局对象window")],-1),V={id:"EventFunction"},O=Object(c["createElementVNode"])("p",null,"元素绑定事件，事件触发后执行函数，this指向的是当前元素",-1),p={id:"ArrowFunction"},N=Object(c["createElementVNode"])("p",null,"this指向箭头函数定义时所处的对象",-1),h={id:"CallApplyBind"},v=Object(c["createStaticVNode"])('<section><ul type="square"><li> call和apply：<span class="red">改变 this 指向后</span>执行函数。 <ul style="margin-left:1rem;" type="circle"><li>call(thisScope,arg1,arg2,arg...);<span class="red"> 多个参数，第一个参数为null、undefined时，默认指向Window</span></li><li>apply(thisScope,[arg1,arg2,arg...]);<span class="red"> 两个参数</span></li></ul></li></ul><ul type="square"><li>bind: 改变 this 指向后，返回函数，不执行。</li><p>bind(thisScopr,arg1,arg2,arg...) 多个参数</p></ul></section>',1),P=Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("div",{class:"c-h5"},"apply的使用方法(函数劫持、对象复制)"),Object(c["createElementVNode"])("div",{class:"indent"},[Object(c["createElementVNode"])("span",null,[Object(c["createTextVNode"])("可以看到 Student 不具备任何方法，但是在 "),Object(c["createElementVNode"])("span",{class:"red"},"Person.apply(this,arguments)"),Object(c["createTextVNode"])("之后，他就具备了Person类的方法及属性")])]),Object(c["createElementVNode"])("div",null,"由此得出结论： Function.apply() 能“劫持”另外一个对象， 继承另外一个对象的属性")],-1),f={id:"Promise"},E={id:"Reference"},x=Object(c["createStaticVNode"])('<section><div><span>1.</span><a target="_blank" rel="help" href="http://liubin.org/promises-book/" class="a-navigation">JavaScript Promise迷你书(中文版)</a></div><div><span>2.</span><a target="_blank" href="https://juejin.cn/post/6844903455962693640" class="a-navigation">深入理解Promise(上)</a></div><div><span>3.</span><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903667494027278">从手写一个符合Promise/A+规范Promise来深入学习Promise</a></div><div><span>4.</span><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903550288412679">Promise深度学习---我のPromise/A+实现 </a></div><div><span>5.</span><a target="_blank" class="a-navigation" href="https://mp.weixin.qq.com/s/Yrwe2x6HukfqJZM6HkmRcw">【第1738期】100 行代码实现 Promises/A+ 规范</a></div><div><span>6.</span><a target="_blank" class="a-navigation" href="https://zhuanlan.zhihu.com/p/144058361">从零开始手写Promise </a></div><div><span>7.</span><a target="_blank" class="a-navigation" href="https://blog.csdn.net/weixin_56650035/article/details/121070438?spm=1001.2014.3001.5502">PromiseA+规范之手写Promise </a></div></section>',1),T={id:"ConstructorStatus"},g=Object(c["createElementVNode"])("div",{class:"c-h5"},"1. 构造函数",-1),y=Object(c["createStaticVNode"])('<section><div class="c-h5">2. 状态</div><section><ul><li>初始状态 -&gt; pending <ul type="cricle" class="ml-15"><li>初始状态可以改变</li><li>在resolve 或者 reject 调用之前都处于这个状态</li></ul></li><li>最终成功状态 -&gt; fulfilled <ul type="cricle" class="ml-15"><li>执行 resolve 函数，状态改变为 fulfilled</li><li>执行 onFulfilled 函数</li></ul></li><li>最终失败状态 -&gt; rejected <ul type="cricle" class="ml-15"><li>执行 reject 函数，状态改变为 rejected</li><li>执行 onRejected 函数</li></ul></li><li>then 方法 <ul type="cricle" class="ml-15"><li>then 方法为 Promise 对象注册了 onFulfilled 和 onRejected 函数</li></ul></li><li>catch 方法 <ul type="cricle" class="ml-15"><li>catch 方法为Promise 对象注册了 onRejected 函数</li></ul></li></ul></section></section>',1),w={id:"NineMethods"},R=Object(c["createElementVNode"])("div",{class:"c-h5"}," 1. Promise.resolve",-1),k=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])("静态方法"),Object(c["createElementVNode"])("code",null,"Promise.resolve(value)"),Object(c["createTextVNode"])("可以认为是"),Object(c["createElementVNode"])("code",null,"new Promise"),Object(c["createTextVNode"])("方法的语法糖,比如"),Object(c["createElementVNode"])("code",null,"Promise.resolve(42)"),Object(c["createTextVNode"])(" 可以认为是以下代码的语法糖 ")],-1),S={class:"indent"},A=Object(c["createElementVNode"])("code",null,"Promise",-1),C=Object(c["createElementVNode"])("code",null,"onFulfilled",-1),B=Object(c["createElementVNode"])("code",null,"new Promise",-1),F=Object(c["createElementVNode"])("code",null,"Promise",-1),U=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])(" 简单总结一下 "),Object(c["createElementVNode"])("code",null,"Promise.resolve"),Object(c["createTextVNode"])("方法的话，它的作用就是将传递给它的参数填充 "),Object(c["createElementVNode"])("code",null,"Fulfilled"),Object(c["createTextVNode"])(" 到 "),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])(" 对象后并返回这个 "),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])(" 对象。 ")],-1),_=Object(c["createElementVNode"])("div",{class:"c-h5"},"2. Promise.reject",-1),H=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createElementVNode"])("code",null,"Promise.reject(error)"),Object(c["createTextVNode"])("是和"),Object(c["createElementVNode"])("code",null,"Promise.resolve(value)"),Object(c["createTextVNode"])("类似的静态方法，是 "),Object(c["createElementVNode"])("code",null,"new Promise"),Object(c["createTextVNode"])(" 方法的快捷方式。比如 "),Object(c["createElementVNode"])("code",null,'Promise.reject(new Error("Promise reject error"))'),Object(c["createTextVNode"])(" 就是下面代码的语法糖形式 ")],-1),G=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])(" 简单总结一下 "),Object(c["createElementVNode"])("code",null,"Promise.reject"),Object(c["createTextVNode"])("方法的话：它的功能是调用该 "),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象通过then指定的 "),Object(c["createElementVNode"])("code",null,"onRejected"),Object(c["createTextVNode"])("函数，并讲错误（Error）对象传递给这个"),Object(c["createElementVNode"])("code",null,"onRejected"),Object(c["createTextVNode"])("函数 ")],-1),I=Object(c["createElementVNode"])("div",{class:"c-h5"},"3. Promise.then",-1),M=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"Promise.then(onFulfilled, onRejected)")],-1),q=Object(c["createElementVNode"])("div",{class:"c-h6"},"① 函调函数异步执行",-1),W=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"Promise/A+规范"),Object(c["createTextVNode"])("统一规定：Promise 只能使用异步调用方式 ")],-1),z=Object(c["createStaticVNode"])('<div class="c-h6">② 返回值</div><p class="indent">不管你在回调函数 <code>onFulfilled</code>中会返回一个什么样的值，或者不返回值，该值都会由 <code>Promis.resolve(return 的返回值)</code> 进行响应的包装处理。因此，最终 <code>then</code>的结果都是返回一个新创建的 <code>Promise</code>对象。 </p><p class="indent"> 也就是说，<code>Promis.then</code>不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个<code>Promise</code> 对象。正是 <code>then</code>函数中有了这样返回值的机制，才能使得在整个<code>Promise</code>链式结构当中，每个<code>then</code>方法都能给 下一个<code>then</code>方法传递参数。现在我们知道怎么返回的<code>Promise</code>是之前的还是新的？另外该<code>Promise</code>的状态又是如何？ </p>',3),J=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("从上面结果来看，实际上不管是调用 "),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("还是"),Object(c["createElementVNode"])("code",null,"catch"),Object(c["createTextVNode"])("方法， 都返回了一个新的"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象")],-1),D=Object(c["createElementVNode"])("div",{class:"c-h6"},"③ promise穿透",-1),L=Object(c["createElementVNode"])("p",null,"我们先来举个例子：",-1),Y=Object(c["createElementVNode"])("p",null,"如果你认为输出的是【 Barry Promise 】，那么你就错了，实际上他输出的是 【 Barry 】",-1),Z=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("产生这么的输出是因为你给"),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("方法传递了一个非函数(比如"),Object(c["createElementVNode"])("code",null,"promise"),Object(c["createTextVNode"])("对象)的值，代码会这样理解 : "),Object(c["createElementVNode"])("code",null,"then(null)"),Object(c["createTextVNode"])(",因此导致了前一个"),Object(c["createElementVNode"])("code",null,"promise"),Object(c["createTextVNode"])("的结果产生了坠落的效果，也就是和下面代码是一样的， 代码直接穿透了"),Object(c["createElementVNode"])("code",null,"then(null)"),Object(c["createTextVNode"])("进入了下一层链： ")],-1),$=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("随意添加多个"),Object(c["createElementVNode"])("code",null,"then(null)"),Object(c["createTextVNode"])("结果都是一样的")],-1),K=Object(c["createElementVNode"])("div",{class:"c-h5"},"4. Promise.catch",-1),Q=Object(c["createElementVNode"])("div",{class:"c-h6"},"① 语法糖的本质",-1),X=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])(" 这里我们再说一遍，实际上"),Object(c["createElementVNode"])("code",null,"Promise.catch"),Object(c["createTextVNode"])("只是"),Object(c["createElementVNode"])("code",null,"promise.then(undefined, onRejected)"),Object(c["createTextVNode"])(" 方法的一个别名而已。也就是说，这个方法用来注册当"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象状态变为 "),Object(c["createElementVNode"])("code",null,"Rejected"),Object(c["createTextVNode"])("时 的回调函数。可以看下面代码，两者写法是等价的，但是很明显 "),Object(c["createElementVNode"])("code",null,"Promise.catch"),Object(c["createTextVNode"])("会让人第一眼看上去不会眼花缭乱: ")],-1),ee=Object(c["createStaticVNode"])("<p>那么我们现在来说说为什么推荐使用第二种方法，而不是第一种:</p><div><ul><li>使用<code>promise.then(onFulfilled, onRejected)</code> 的话，在<code>onFulfilled</code>中发生异常的话，<code>onRejected</code> 中是捕获不到这个异常的。而且如果链式很长，每一条链上都要这么写。 </li><li> 在<code>promise.then(onFulfilled).catch(onRejected)</code> 的情况下<code>.then</code>中产生异常能在<code>.catch</code> 中捕获。<code>.then</code>和<code>.catch</code>本质上是没有区别的， 需要分场合使用 </li></ul></div>",2),te=Object(c["createStaticVNode"])('<div class="c-h6">② 只有一个主人</div><p class="indent">我们上面已经说过了，在书写很长的<code>Promise</code>链式，从代码清晰度和简易程度来讲，在最后添加 <code>catch</code>是远远在每一层链上写<code>onRejected</code>回调函数是要好的，因为<code>catch</code>可以捕获 <code>Promise</code>链中每一层节点的错误，这句话本身没有错，但从这句话延伸出一种错误的理解：<code>catch</code> 同时监控着所有节点。实际上<code>catch</code>函数在同一个时间点只属于某一个<code>Promise</code>，因为它的主人是随着程序 的执行而不断变化的，我们来举个例子： </p>',2),oe=Object(c["createStaticVNode"])("<p>在上述例子中，如果整个程序每一步都正确执行，那么会顺序产生三个<code>Promise</code>对象，分别是 <code>Promise(1)</code>,<code>Promise(2)</code>,<code>Promise(3)</code>: </p><ul><li>可是如果在第一层具体执行逻辑出错了后，那实际上后面的两个<code>then</code> 中的回调函数压根不会被异步执行，所以会直接异步触发<code>catch</code>中的回调函数执行， 所以这种情况下<code>catch</code>是<code>Promise(1)</code>对象的<code>catch</code>。 </li><li> 如果第一层具体执行逻辑正确执行，就会异步触发第二个<code>then</code>中的回调函数执行，那么同理 ，在第二次具体执行逻辑抛出错误，会导致<code>Promise(2)</code>的状态变化，所以这种情况下<code>catch</code> 是<code>Promise(2)</code>对象的<code>catch</code>。 </li><li>同理<code>Promise(3)</code>也是如此</li></ul><p>总结下来就是：整个<code>Promise</code>链中，<code>catch</code>只属于异步触发它当中回调函数 执行的那个<code>Promise</code>，并不属于所有 <code>Promise</code></p>",3),ce=Object(c["createStaticVNode"])('<div class="c-h5">5. Promise.finally</div><p class="indent"><code>promise.finally</code>方法的回调函数不接受任何参数，这意味着<code>finally</code>没有办法 知道，前面的<code>Promise</code>状态到底是<code>fulfilled</code>还是<code>rejected</code> 。这表明，<code>finally</code>方法里面的操作，应该是与<code>Promise</code>状态无关的，不依赖于 <code>Promise</code>的执行结果。我们来看下面代码： </p>',2),ne=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"finally"),Object(c["createTextVNode"])("本质上是"),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("方法的特例。我们来看下面伪代码：")],-1),le=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("上面代码中，如果不使用"),Object(c["createElementVNode"])("code",null,"finally"),Object(c["createTextVNode"])("方法，同样的语句需要为成功和失败的状态各写一次。 有了"),Object(c["createElementVNode"])("code",null,"finally"),Object(c["createTextVNode"])("方法，则只需要写一次。那么它是如何实现的呢？ ")],-1),re=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("上述代码中，不管前面的"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("是"),Object(c["createElementVNode"])("code",null,"fulfilled"),Object(c["createTextVNode"])("还是"),Object(c["createElementVNode"])("code",null,"rejected"),Object(c["createTextVNode"])(" ，都会执行回调函数"),Object(c["createElementVNode"])("code",null,"callback")],-1),de=Object(c["createStaticVNode"])('<div class="c-h5">6. Promise.all</div><p class="indent"><code>Promise.all</code>接受一个<code>promise</code>对象的数组作为参数，当这个数组里的所有 <code>Promise</code> 对象 全部变为<code>resolve</code>或者<code>reject</code>状态的时候，它才会去调用<code>.then</code>方法。 </p><p class="indent"> 传递给<code>Promise.all</code>的 <code>promise</code>并不是一个个的顺序执行的，而是同时开始、并行执行的，我们可以看下面例子 </p>',3),ae=Object(c["createStaticVNode"])('<p>为什么这个例子可以看出来<code>Promise.all()</code>是并行的呢？因为所有<code>Promise</code>执行完只用了5秒，如果3个 <code>Promise</code>是按照顺序执行的，那么应该是9秒或者，在5-9之间，因为4个<code>Promise</code>并不是同时执行的，同时执行的 话总时间就是那个花费时间最长的<code>Promise</code></p><p><code>Promise.all()</code>重要细节点 <span class="red">（面试常考）</span>：</p><div><ul><li> 如果所有的<code>Promise</code>中只有一个执行错误，那么整个<code>Promise.all</code>不会走<code>Promise.all().then()</code> 而是走<code>Promise.all().catch()</code>这个流程了。但是要注意的是虽然走到了<code>Promise.all().catch()</code>这个流程 ，<span class="red">但是其他<code>Promise</code>还是会正常执行，但不会返回结果</span></li><li> 要注意<code>Promise.all()</code>的返回值顺序，<code>Promise.all().then()</code>的返回值顺序和传入的顺序是一致的，笔试时 遇到手写<code>Promise.all()</code>时要注意 </li></ul></div>',3),ie=Object(c["createStaticVNode"])('<div class="c-h5">7. Promise.allSettled</div><p><code>Promise.allSettled()</code>的入参和<code>Promise.all、Promise.race</code>一样，接受一个<code>promise</code> 对象的数组作为参数,也是同时开始、并行执行的。但是<code>Promise.allSettled</code>的返回值需要注意以下几点： </p><p><code>Promise.allSettled</code>不会走进catch，当所有输入<code>Promise</code>都被履行或者拒绝时，<code> statusesPromise </code>会解析一个具有具体完成状态的数组 </p><div><ul><li><code>{ status: &#39;fulfilled&#39;, value:value } </code>：如果相应的<code>promise</code>被履行</li><li><code>{ status: &#39;rejected&#39;, reason: reason }</code>：如果相应的<code>promise</code>被拒绝</li></ul></div><p>我们看下面示例:</p>',5),se=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("总结一下："),Object(c["createElementVNode"])("code",null,"Promise.allSettled()"),Object(c["createTextVNode"])("在你需要执行平行和独立的异步操作并收集所有结果时非常有效， 即使某些异步操作可能失败。")],-1),me=Object(c["createStaticVNode"])('<div class="c-h5">8. Promise.race</div><p class="indent"><code>Promise.rece()</code>的使用方法和 <code>Promise.all</code>一样，接收一个<code>promise</code> 对象的数组为参数，<code>Promise.race</code>是要有一个promise对象进入<code>Fulfilled</code>或者 <code>Rejected</code>状态的话，就会继续进行后面的处理。这里依旧有两个点要注意： </p><div><ul><li>和<code>Promise.all</code>一样是所有数组当中的<code>Promise</code>同时并行的</li><li><code>Promise.race</code> 在第一个<code>Promise</code>对象变为<code>Fulfilled</code>之后，并不会 取消其他<code>promise</code>对象的执行。</li><li><code>Promise.race</code>接受的是一个<code>Promise</code>对象数组，但是返回的确实最先完成<code>Fulfilled</code> 或者最先被<code>Rejected</code>的一个Promise的结果 </li></ul></div><p>下面我们来举个例子：</p>',4),ue=Object(c["createStaticVNode"])("<p>这里我们再复习一下<code>Node</code>当中事件循环的知识：</p><div><ul><li>第一层循环：i为0时，异步触发了<code>Promise.race().catch()</code>，这里面的回调代码被放在了微任务队列中， 后面的3个<code>setTimeout</code>宏任务的回调函数代码被放进了<code>timer</code>阶段中的队列当中(其实并不是这样，因为 三个定时器都有延迟，都是在后面的事件循环中添加进来的) </li><li>第二层循环：清空微任务对列，所以控制台打印出了错误，然后清空宏任务，分别打印出<code>3000/5000/7000</code></li></ul></div>",2),je=Object(c["createStaticVNode"])('<div class="c-h5">9. Promise.any</div><p><code>Promise.any</code>的入参和<code>Promise.all、Promise.race、Promise.allSettled</code>一样， 接收一个<code>promise</code>对象的数组作为参数。 </p><div><ul><li>只要其中有一个<code>Promise</code>成功执行，就会返回已经成功执行的<code>Promise</code>的结果</li><li>如果这个<code>promise</code>对象的数组中没有一个<code>promise</code> 可以成功执行（即所有的 <code>promise</code>都失败 ），就返回一个失败的<code>promise</code> 和<code>AggregateError</code>类型的实例，它是<code>Error</code>的一个子类，用于把单一的错误集合 在一起 </li></ul></div>',3),be=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])(" 总计一下"),Object(c["createElementVNode"])("code",null,"Promisea.any"),Object(c["createTextVNode"])("的应用场景：如果我们现在有多台服务器，则尽量使用响应速度最快的服务器，在这种情况下， 可以使用"),Object(c["createElementVNode"])("code",null,"Promise.any()"),Object(c["createTextVNode"])("方法从最快的服务器接收响应。 ")],-1),Ve={id:"ErrorCapture"},Oe=Object(c["createStaticVNode"])('<div class="c-h5">1. 使用reject而不是throw</div><p class="indent"> 在最开始我们先来一句比较重要的话：<code>Promise</code>的构造函数，以及被<code>then</code>调用执行的函数基本上都可以认为是 在<code>try...catch</code>代码块中执行的，所以在这些代码中即使使用<code>throw</code>，程序本身也不会异常而终止。 </p><p class="indent"> 所以其实如果在<code>Promise</code>中使用<code>throw</code>语句的话，会被<code>try...catch</code>住，最终<code>Promise</code> 对象也会变为<code>Rejected</code>状态。但是我们为什么还是推荐使用<code>Promise.reject</code>呢？有下面两个原因： </p><div><ul><li>我们很难区分<code>throw</code>是我们主动抛出来的，还是因为真正的其他异常导致的，无法主动决定，属于被动。</li><li><code>Promise</code>构造函数当中通过<code>throw</code>抛出来的错误未必会被<code>Promise.catch</code> 捕获到 </li></ul></div><p>下面我们就说说什么时候通过<code>throw</code>抛出的错误未必会被<code>Promise.catch</code>捕获到：</p>',5),pe=Object(c["createStaticVNode"])("<p>这个例子非常典型，想知道为什么错误没有被<code>catch</code>住，我们要到推出原因：</p><div><ul><li>首先我们要明确的是，不论是<code>then</code>还是<code>catch</code>中注册的回调函数，都是由<code>Promise</code> 状态的变化触发的，现在也就说<code>Promise</code>状态始终在<code>pending</code>状态。 </li><li> 其次，前面不是说<code>reject</code>和<code>throw</code>都能最终让<code>Promise</code>进入<code>onReject</code> 状态，这里的<code>throw</code>为什么没有改变<code>Promise</code>的状态。 </li><li> 原因还是要从事件循环来说，我们好好想想，这段代码在第一轮的事件循环当中<code>setTimeout</code>的回调函数被放在了 <code>timer</code>阶段的队列当中，但是它没有执行啊，所以第一轮的<code>Promise</code>状态一直处于<code>pending</code> ，所以<code>then</code>和<code>catch</code>部分的代码全部没有触发，也就在第一轮事件循环当中跳过了。然后在第二轮 循环当中才执行了<code>throw</code>语句，把错误直接抛到了全局，就直接报错。所以上面的代码和下面效果一样，catch怎么可能 捕获到在它后面执行的代码呢？ </li></ul></div>",2),Ne=Object(c["createStaticVNode"])('<section><div class="c-h5">2. 在then中进行reject</div><p class="indent">如果我们想在<code>then</code>当中使用<code>reject</code>，首先我们要懂两个知识点：</p><div><ul><li><code>then</code>中的回调函数中，<code>return</code>的返回值类型不光是简单的字面值，还可以是复杂的对象类型， 比如<code>Promise</code>对象等。 </li><li> 只要修改这个返回的<code>Promise</code>的状态，在下一个<code>then</code>中注册的回调函数中的<code>onFulfilled</code> 和<code>onRejected</code>的哪一个会被调用也是能确定的 </li></ul></div><p>所以我们可以这样写代码就能在<code>then</code>当中使用<code>reject</code>:</p></section>',1),he={id:"ReturnValue"},ve={id:"WritePromise"},Pe={id:"AsyncAwait"},fe=Object(c["createStaticVNode"])('<div><h3 id="Generator">3、Generator</h3><h4 id="Iterator">1、迭代器Iterator</h4><h4 id="SubGenerator">2、生成器Generator</h4><h4 id="AutoGenerator">3、Generator自动执行</h4></div><h3 id="DeepClone">4、深拷贝和浅拷贝</h3>',2);var Ee=Object(c["defineComponent"])({__name:"index",setup(e){const t=Object(c["getCurrentInstance"])(),{$builtIn:o}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,Ee=o("\n// 'not strict' 【window】\nconsole.log(this);\nfunction funs(){\n    console.log(this); \n};\nfuns();\n\n// 'use strict' 【undefined】\nfunction stractDemo(){\n    'use strict'\n    console.log(this);\n};\nstractDemo();\n"),xe=o("\nlet name = 'Global Barry';\nlet obj = {\n    name: 'Obj Barry',\n    getName: function(){\n        console.log(this.name)\n    },\n};\nobj.getName(); // 'Obj Barry'\n\nlet funs = obj.getName;\nfuns(); // 'Global Barry'\n"),Te=o('\nfunction Barry(){\n    this.name = "Fashion pro Barry";\n    console.log(this);\n}\n\nlet n = new Barry();\nconsole.log(n)\n'),ge=o('\n// setTimeout\nsetTimeout(function () {\n    console.log(this)\n}, 0)\n\nvar name = "my name is window"; // 注意var 和 const 输出是不一样的\nvar obj = {\n    name: "my name is obj",\n    funs: function () {\n        let timer = null;\n        clearInterval(timer);\n        timer = setInterval(function () {\n            console.log(this.name); // "my name is window"\n        }, 100);\n    },\n};\nobj.funs();\n\n\n// 回调函数\nvar o = {\n    age: 18,\n    say: function () {\n        function callback() {\n            return this.age;\n        }\n        func(callback);\n    },\n};\nfunction func(callback) {\n    var name = "Fashion Barry";\n    console.log(name, " is", callback() + " years"); \n}\no.say(); // Fashion Barry  is undefined years\n/**\n * 【解析】：\n * 函数内部的【this】指向于此函数的调用者（拥有者）\n * 但在上面这个例子中，为什么会输出unidentified\n * 虽然【callback】定义在对象【o】的【say】方法中，但实际上由于【callback】是在【func】函数中被普通调用的\n * 那么【func】中的【callback】的调用对象我们可以理解为【window】对象\n * 当使用一个对象未定义的属性时不会报错，会返回undefined，而直接使用一个未定义的变量便会报错\n*/\n\n'),ye=o('\n<button id="btn">click me</button>\n\nwindow.onload = function () {\n    var btn = document.getElementById("btn");\n    btn.onclick = function () {\n        console.log(this);\n    };\n};\n'),we=o('\nvar name = "my name is window";\nvar obj = {\n    name: "my name is obj",\n    func: function () {\n        return (() => {\n            console.log(this.name); // my name is obj\n        })();\n    },\n};\nobj.func()\n'),Re=o('\n// 对象方法:this指向方法前的对象\nvar person = {\n  name: "dog",\n  say: function (language) {\n    console.log(this.name + " say " + language);\n  },\n};\nperson.say("Hello world!");\n\n//call  改变this指向，传入多个参数\nvar name = "duck";\nperson.say.call(window, "Helo Window!");\n\n//apply 改变this指向，两个参数\n// person.say.apply(this, "Hello Apply!"); // 会报错TypeError: CreateListFromArrayLike called on non-object\n\nperson.say.apply(window, { name: "Hello Apply!" }); // nduck say undefined\n// apply 的第二个参数必须为数组\nperson.say.apply(this, ["Hello Apply!"]); // duck say Hello Apply\n\nvar arr = [1, 2, 3, 4];\nMath.max.apply(null, arr); //4, null表示不改变this指向\n\n// bind:改变this指向，不立即调用，而是返回该函数\nfunction multiply(x, y, z) {\n  return x * y * z;\n}\n\nvar double = multiply.bind(null, 2);\nconsole.log(double(3, 4)); // 24\n\nvar person1 = {\n  name: "dog",\n  sayHello: function () {\n    setTimeout(\n      function () {\n        console.log(this.name + " Say Hello!");\n      }.bind(this),\n      1000\n    );\n  },\n};\n\nperson1.sayHello(); //dog Say Hello!\n\n'),ke=o('\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayHello = function () {\n    console.log(this.name + " Say hello!");\n  };\n}\n\nfunction Student(name, age, grade) {\n  Person.apply(this, arguments);\n  this.grade = grade;\n}\n\nvar s = new Student("Barry", 18, "middle school");\nconsole.log(s.name); // Barry\nconsole.log(s.age); // 18\nconsole.log(s.grade); //middle school\ns.sayHello(); // Barry Say hello!\n'),Se=o("\n// 面试题解析\nvar x = 20;\nvar a = {\n  x: 15,\n  fn: function () {\n    var x = 30;\n    return function () {\n      return this.x;\n    };\n  },\n};\n\nconsole.log(a.fn()); // Function ƒ(){return this.x}\nconsole.log((a.fn())()); // 20 a.fn()返回的是一个函数，()()这是自执行表达式。this -> window\nconsole.log(a.fn()()); // 20 a.fn()相当于在全局定义了一个函数，然后再自己调用执行。this -> window\nconsole.log(a.fn()() == (a.fn())()); //true\nconsole.log(a.fn().call(this)); // 20 这段代码在全局环境中执行，this -> window\nconsole.log(a.fn().call(a)); // 15, 更改this指向为 a，a的x为15\n\n"),Ae=o("\nvar promise = new Promise(function (resolve, reject) {\n  // 异步处理\n  // 处理结果成功调用 resolve\n  // 失败调用 reject\n});\n"),Ce=o("\nnew Promise(function (resolve) {\n    resolve(42)\n})\n"),Be=o('\nnew Promise(function (reject) {\n    reject(new Error("Promise reject error"))\n})\n'),Fe=o('\nvar promise = new Promise((resolve, reject) => {\n  console.log("inner Promise"); // 1\n  setTimeout(() => {\n    resolve("Fashion Barry"); // 3\n  }, 1000);\n});\n\npromise.then((res) => {\n  console.log("res", res);\n});\nconsole.log("outer promise"); // 2\n// Promise 实际是一个同步函数，then 方法才是异步\n// 所以输出顺序如上\n'),Ue=o('\nvar aPromise = new Promise((resolve, reject) => {\n  resolve("aPromise");\n});\nvar thenPromise = aPromise.then((res) => {\n  console.log("thenPromise: ", res);\n});\nvar catchPromise = aPromise.catch((err) => {\n  console.error("catchPromise: ", err);\n});\n\nconsole.log(aPromise !== thenPromise); // true\nconsole.log(thenPromise !== catchPromise); // true\nconsole.log(aPromise, thenPromise, catchPromise); // Promise { "aPromise" }, Promise { <pending> }, Promise { <pending> }\n'),_e=o('\nPromise.resolve("Barry")\n.then(Promise.resolve("Barry Promise"))\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),He=o('\nPromise.resolve("Barry")\n.then(null)\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),Ge=o('\nPromise.resolve("Barry")\n.then(null)\n.then({ name: "My name is Barry" })\n.then(null)\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),Ie=o("\n// 第一种写法\nPromise.resolve()\n  .then((data) => console.log(data))\n  .then(undefined, (err) => console.log(err));\n\n// 第二种写法\nPromise.resolve()\n  .then((data) => console.log(data))\n  .catch((err) => console.log(err));\n"),Me=o('\nlet p1 = new Promise((resolve, reject) => {\n  // 第一层执行逻辑\n  resolve("first promise"); // Promise(1)\n})\n  .then((res) => {\n    // 第二层执行逻辑\n    return "second promise"; // Promise(2)\n  })\n  .then((res) => {\n    // 第三层执行逻辑\n    return "third promise"; // Promise(3)\n  })\n  .catch((err) => {\n    console.log("err", err);\n  });\n'),qe=o('\nvar p1 = new Promise((resolve, rejevt) => {\n  setTimeout(() => {\n    resolve;\n  }, 1000);\n});\n\np1.then((res) => console.log(res))\n  .catch((err) => console.log(err))\n  .finally(() => console.log("finally"));\n'),We=o("\npromise.finally(() => {\n  // 执行逻辑\n});\n// 上面代码等同于下面\npromise.then(\n  (onFulilled) => {\n    // 语句\n    return onFulilled;\n  },\n  (onRejected) => {\n    // 语句\n    throw onRejected;\n  }\n);\n"),ze=o('\nPromise.prototype.finally = function (callback) {\n  let p = this.constructor;\n  return this.then(\n    (value) => p.resolve(callback()).then(() => value),\n    (reason) =>\n      p.reject(callback()).then(() => {\n        throw reason;\n      })\n  );\n};\n\nvar p = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    reject("Promise err");\n  }, 1000);\n});\np.catch((err) => console.log("err", err)).finally(() => {\n  console.log("finally");\n});'),Je=o('\nvar promise1 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise1--3000");\n  }, 3000);\n});\nvar promise2 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise2--1000");\n  }, 1000);\n});\nvar promise3 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise3--5000");\n  }, 5000);\n});\n\nvar promiseArr = [promise1, promise2, promise3];\nconsole.time("promiseArr");\nPromise.all(promiseArr)\n  .then((res) => {\n    console.log("res", res); // [\'promise1--3000\', \'promise1--1000\', \'promise1--5000\']\n    console.timeEnd("promiseArr"); // 5523.29296875 ms\n  })\n  .catch((err) => console.log(err));\n'),De=o('\nlet arr = [1000, 3000, 5000, 7000];\nlet promiseArr = [];\n\nfor (let i = 0; i < arr.length; i++) {\n  let newPromise = new Promise((resolve, reject) => {\n    if (i === 0) {\n      reject(new Error("第二个错误"));\n    } else {\n      setTimeout(() => {\n        console.log(arr[i]);\n        resolve(arr[i]);\n      }, arr[i]);\n    }\n  });\n  promiseArr.push(newPromise);\n}\n\nPromise.race(promiseArr)\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n\n// 控制台报错\n// 3000\n// 5000\n// 7000\n'),Le=o('\nvar promise1 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    reject(new Error("promise1--3000"));\n    // resoleve("promise1--3000");\n  }, 3000);\n});\nvar promise2 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // reject(new Error("promise1--1000"))\n    resoleve("promise2--1000");\n  }, 1000);\n});\nvar promise3 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise3--5000");\n    // reject(new Error("promise1--5000"))\n  }, 5000);\n});\nvar promiseArr = [promise1, promise2, promise3];\nconsole.time("promiseArr");\nPromise.allSettled(promiseArr)\n  .then((res) => {\n    console.log("res", res);\n    console.timeEnd("promiseArr");\n  })\n  .catch((err) => console.error(err))\n  .finally(() => console.log("finally"));\n'),Ye=o('\nvar promise1 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // reject(new Error("promise1--3000"));\n    resoleve("promise1--3000");\n  }, 3000);\n});\nvar promise2 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // reject(new Error("promise2--1000"))\n    resoleve("promise1--1000");\n  }, 1000);\n});\nvar promise3 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // resoleve("promise3--5000");\n    reject(new Error("promise1--5000"))\n  }, 5000);\n});\nvar promiseArr = [promise1, promise2, promise3];\nconsole.time("promiseArr");\nPromise.any(promiseArr)\n  .then((res) => {\n    console.log("res", res); // res promise1--1000\n    console.timeEnd("promiseArr");\n  })\n  .catch((err) => console.error(err)); \n  //所有的Promise都失败， AggregateError: All promises were rejected\n'),Ze=o('\nvar p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    throw new Error("async error");\n  }, 500);\n});\n\np1.then((res) => {\n  console.log("res--", res);\n}).catch((err) => {\n  console.error("err--", err);\n});\n// 会直接报错，不会走到 catch\n'),$e=o("\nvar p1 = new Promise(function(resolve, reject) {\n})\n.then(res => {\n})\n.catch(err => {\n})\nthrow Error('async error')   ");return(e,t)=>{const o=Object(c["resolveComponent"])("RouterLink"),Ke=Object(c["resolveComponent"])("WebPrismEditor"),Qe=Object(c["resolveComponent"])("cod");return Object(c["openBlock"])(),Object(c["createElementBlock"])("div",n,[l,Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h3",r,[Object(c["createVNode"])(o,{to:"#This",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、This指向 ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",d,[Object(c["createVNode"])(o,{to:"#GlobalFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、全局函数 ")]),Object(c["createElementVNode"])("section",null,[a,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Ee),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(c["isRef"])(Ee)?Ee.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",i,[Object(c["createVNode"])(o,{to:"#ObjectMethod",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、对象方法 ")]),Object(c["createElementVNode"])("section",null,[s,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(xe),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(c["isRef"])(xe)?xe.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",m,[Object(c["createVNode"])(o,{to:"#Constructor",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、构造函数 ")]),Object(c["createElementVNode"])("section",null,[u,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Te),"onUpdate:modelValue":t[2]||(t[2]=e=>Object(c["isRef"])(Te)?Te.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",j,[Object(c["createVNode"])(o,{to:"#SetTimeout",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、定时器、回调函数 ")]),Object(c["createElementVNode"])("section",null,[b,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(ge),"onUpdate:modelValue":t[3]||(t[3]=e=>Object(c["isRef"])(ge)?ge.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",V,[Object(c["createVNode"])(o,{to:"#EventFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、事件函数 ")]),Object(c["createElementVNode"])("section",null,[O,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(ye),"onUpdate:modelValue":t[4]||(t[4]=e=>Object(c["isRef"])(ye)?ye.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",p,[Object(c["createVNode"])(o,{to:"#ArrowFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("6、箭头函数 ")]),Object(c["createElementVNode"])("section",null,[N,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(we),"onUpdate:modelValue":t[5]||(t[5]=e=>Object(c["isRef"])(we)?we.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",h,[Object(c["createVNode"])(o,{to:"#CallApplyBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("7、call、apply、bind ")]),Object(c["createElementVNode"])("section",null,[v,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Re),"onUpdate:modelValue":t[6]||(t[6]=e=>Object(c["isRef"])(Re)?Re.value=e:null)},null,8,["modelValue"]),P,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(ke),"onUpdate:modelValue":t[7]||(t[7]=e=>Object(c["isRef"])(ke)?ke.value=e:null)},null,8,["modelValue"]),Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Se),"onUpdate:modelValue":t[8]||(t[8]=e=>Object(c["isRef"])(Se)?Se.value=e:null)},null,8,["modelValue"])])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h3",f,[Object(c["createVNode"])(o,{to:"#Promise",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、Promise(异步编程) ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",E,[Object(c["createVNode"])(o,{to:"#Reference",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、参考资料 ")]),x]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",T,[Object(c["createVNode"])(o,{to:"#ConstructorStatus",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、构造函数和状态 ")]),Object(c["createElementVNode"])("section",null,[g,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Ae),"onUpdate:modelValue":t[9]||(t[9]=e=>Object(c["isRef"])(Ae)?Ae.value=e:null)},null,8,["modelValue"])]),y]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",w,[Object(c["createVNode"])(o,{to:"#NineMethods",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、九大方法 ")]),Object(c["createElementVNode"])("section",null,[R,k,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Ce),"onUpdate:modelValue":t[10]||(t[10]=e=>Object(c["isRef"])(Ce)?Ce.value=e:null)},null,8,["modelValue"]),Object(c["createElementVNode"])("p",S,[Object(c["createTextVNode"])("这个静态方法会让"),A,Object(c["createTextVNode"])("对象立即进入确定(即resolved) 状态，并将42传递给后面 "),Object(c["createVNode"])(Qe,null,{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("then")]),_:1}),Object(c["createTextVNode"])(" 里所指定的 "),C,Object(c["createTextVNode"])("函数。作为 "),B,Object(c["createTextVNode"])("的快捷方式，在进行 "),F,Object(c["createTextVNode"])(" 对象的初始化或者编写测试代码的时候都非常方便。 ")]),U]),Object(c["createElementVNode"])("section",null,[_,H,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Be),"onUpdate:modelValue":t[11]||(t[11]=e=>Object(c["isRef"])(Be)?Be.value=e:null)},null,8,["modelValue"]),G]),Object(c["createElementVNode"])("section",null,[I,M,Object(c["createElementVNode"])("div",null,[q,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Fe),"onUpdate:modelValue":t[12]||(t[12]=e=>Object(c["isRef"])(Fe)?Fe.value=e:null)},null,8,["modelValue"]),W]),Object(c["createElementVNode"])("div",null,[z,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Ue),"onUpdate:modelValue":t[13]||(t[13]=e=>Object(c["isRef"])(Ue)?Ue.value=e:null)},null,8,["modelValue"]),J]),Object(c["createElementVNode"])("div",null,[D,L,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(_e),"onUpdate:modelValue":t[14]||(t[14]=e=>Object(c["isRef"])(_e)?_e.value=e:null)},null,8,["modelValue"]),Y,Z,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(He),"onUpdate:modelValue":t[15]||(t[15]=e=>Object(c["isRef"])(He)?He.value=e:null)},null,8,["modelValue"]),$,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Ge),"onUpdate:modelValue":t[16]||(t[16]=e=>Object(c["isRef"])(Ge)?Ge.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("section",null,[K,Object(c["createElementVNode"])("div",null,[Q,X,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Ie),"onUpdate:modelValue":t[17]||(t[17]=e=>Object(c["isRef"])(Ie)?Ie.value=e:null)},null,8,["modelValue"]),ee]),Object(c["createElementVNode"])("div",null,[te,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Me),"onUpdate:modelValue":t[18]||(t[18]=e=>Object(c["isRef"])(Me)?Me.value=e:null)},null,8,["modelValue"]),oe])]),Object(c["createElementVNode"])("section",null,[ce,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(qe),"onUpdate:modelValue":t[19]||(t[19]=e=>Object(c["isRef"])(qe)?qe.value=e:null)},null,8,["modelValue"]),ne,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(We),"onUpdate:modelValue":t[20]||(t[20]=e=>Object(c["isRef"])(We)?We.value=e:null)},null,8,["modelValue"]),le,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(ze),"onUpdate:modelValue":t[21]||(t[21]=e=>Object(c["isRef"])(ze)?ze.value=e:null)},null,8,["modelValue"]),re]),Object(c["createElementVNode"])("section",null,[de,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Je),"onUpdate:modelValue":t[22]||(t[22]=e=>Object(c["isRef"])(Je)?Je.value=e:null)},null,8,["modelValue"]),ae]),Object(c["createElementVNode"])("section",null,[ie,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Le),"onUpdate:modelValue":t[23]||(t[23]=e=>Object(c["isRef"])(Le)?Le.value=e:null)},null,8,["modelValue"]),se]),Object(c["createElementVNode"])("section",null,[me,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(De),"onUpdate:modelValue":t[24]||(t[24]=e=>Object(c["isRef"])(De)?De.value=e:null)},null,8,["modelValue"]),ue]),Object(c["createElementVNode"])("section",null,[je,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Ye),"onUpdate:modelValue":t[25]||(t[25]=e=>Object(c["isRef"])(Ye)?Ye.value=e:null)},null,8,["modelValue"]),be])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Ve,[Object(c["createVNode"])(o,{to:"#ErrorCapture",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、错误捕获 ")]),Object(c["createElementVNode"])("section",null,[Oe,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])(Ze),"onUpdate:modelValue":t[26]||(t[26]=e=>Object(c["isRef"])(Ze)?Ze.value=e:null)},null,8,["modelValue"]),pe,Object(c["createVNode"])(Ke,{modelValue:Object(c["unref"])($e),"onUpdate:modelValue":t[27]||(t[27]=e=>Object(c["isRef"])($e)?$e.value=e:null)},null,8,["modelValue"])]),Ne]),Object(c["createElementVNode"])("h4",he,[Object(c["createVNode"])(o,{to:"#ReturnValue",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、返回值 ")]),Object(c["createElementVNode"])("h4",ve,[Object(c["createVNode"])(o,{to:"#WritePromise",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("6、手写Promise ")]),Object(c["createElementVNode"])("h4",Pe,[Object(c["createVNode"])(o,{to:"#AsyncAwait",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("7、async和await ")])]),fe])}}});const xe=Ee;t["default"]=xe}}]);