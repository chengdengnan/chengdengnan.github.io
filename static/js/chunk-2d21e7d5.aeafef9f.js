(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d21e7d5"],{d67d:function(e,t,c){"use strict";c.r(t);var a=c("7a23");const o={id:"ReactOverview"},d={id:"ReactVersion"},l=Object(a["createElementVNode"])("div",{style:{width:"80%"}},[Object(a["createElementVNode"])("p",null,"用于构建用户界面的 JavaScript 库,是一个将数据渲染为 HTML 视图的开源 JavaScript 库。"),Object(a["createElementVNode"])("p",{class:"right"},"--- 摘自React官网")],-1),n={class:"mt-15"},i={id:"ReactEcology"},r=Object(a["createStaticVNode"])('<section><div><ul><li> 脚手架/框架 <div><ul type="cricle"><li> umi：可插拔的企业级 react 应用框架 </li><li> create react app：官方支持的创建 react 单页应用程序的方法 </li><li> Nextjs：SSR框架 </li><li> React-vr：vr框架，适用于展厅、房屋设计 </li><li> Reactxp：多端框架 </li></ul></div></li><li> 组件库 <div><ul type="cricle"><li> ant Design系列：pc、mobile，引入Ant Design设计概念 </li><li> Material-UI：实现了谷歌Material Design设计规范，世界流行界面 </li></ul></div></li><li> 工具类 <div><ul type="cricle"><li> Redux：遵循函数式编程思想的状态管理插件 </li><li> Mobx：面向对象变迁和响应式编程的状态管理插件 </li><li> Immutable-js：解决javasript Immutable Data的问题 </li></ul></div></li><li> 跨端类 <div><ul type="cricle"><li> Remax：阿里的React跨端框架，目前支持支付宝、微信、字节小程序 </li><li> Taro：类React跨端框架，支持主流小程序及React Native </li><li> React Native：js编写原生的React框架 </li></ul></div></li><li> 其他 <div><ul type="cricle"><li> react-window和react-virtualized：虚拟滚动库，提供可服用组件， 用于展示列表、网络和表格数据。 </li></ul></div></li></ul></div></section>',1);var O=Object(a["defineComponent"])({__name:"overview",setup(e){const t=Object(a["getCurrentInstance"])(),{$builtIn:c}=null===t||void 0===t?void 0:t.appContext.config.globalProperties;return(e,t)=>{const c=Object(a["resolveComponent"])("RouterLink"),O=Object(a["resolveComponent"])("el-timeline-item"),b=Object(a["resolveComponent"])("el-timeline");return Object(a["openBlock"])(),Object(a["createElementBlock"])(a["Fragment"],null,[Object(a["createElementVNode"])("h3",o,[Object(a["createVNode"])(c,{to:"#ReactOverview",class:"a-link"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])("#")]),_:1}),Object(a["createTextVNode"])(" 1、综述 ")]),Object(a["createElementVNode"])("div",null,[Object(a["createElementVNode"])("h4",d,[Object(a["createVNode"])(c,{to:"#ReactVersion",class:"a-link"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])("#")]),_:1}),Object(a["createTextVNode"])("1、react 简史及版本 ")]),Object(a["createElementVNode"])("section",null,[l,Object(a["createElementVNode"])("p",n,[Object(a["createVNode"])(b,null,{default:Object(a["withCtx"])(()=>[Object(a["createVNode"])(O,{timestamp:"2011",placement:"top"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" 起初由 Facebook 软件工程师 Jordan Wakke 创建。于 2011 年部署于 Facebook 的 newsfeed。 ")]),_:1}),Object(a["createVNode"])(O,{timestamp:"2012",placement:"top"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" 随后在 2012 年部署于 Instagram ")]),_:1}),Object(a["createVNode"])(O,{timestamp:"2013",placement:"top"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" 然后于 2013 年 5 月宣布开源 ")]),_:1}),Object(a["createVNode"])(O,{timestamp:"2015",placement:"top"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" 2015年发布v0.14.0版本：拆分react package into two，react and react-dom ")]),_:1}),Object(a["createVNode"])(O,{timestamp:"2016",placement:"top"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" 2016年发布v15.0版本：虚拟dom的diff操作同步执行 ")]),_:1}),Object(a["createVNode"])(O,{timestamp:"2017",placement:"top"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" 2017年发布React v16.0版本：使用fiber架构(分片)，小于ie11需使用polyfill ")]),_:1}),Object(a["createVNode"])(O,{timestamp:"2017-react v16.2.0",placement:"top"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" react v16.2.0（2017年）：增加Fragment组件 ")]),_:1}),Object(a["createVNode"])(O,{timestamp:"2018-react V16.3.0",placement:"top"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" react V16.3.0（2018年）：增加主要的api，React.createRef()、React.forwardRef() ")]),_:1}),Object(a["createVNode"])(O,{timestamp:"2018-V16.6.0",placement:"top"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" react V16.6.0（2018年）：增加主要的api，React.memo()、React.lazy() ")]),_:1}),Object(a["createVNode"])(O,{timestamp:"2018-V16.8.0",placement:"top"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" react V16.8.0（2019年）：增加React Hooks，用来解决状态逻辑复用问题，且不会产生 JSX 嵌套地狱 ")]),_:1}),Object(a["createVNode"])(O,{timestamp:"2020-V17.0.0",placement:"top"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" 2020年发布React v17.0版本：引入渐进式升级 ")]),_:1}),Object(a["createVNode"])(O,{timestamp:"2022-V18.0.0",placement:"top"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" 2022年发布React v18.0版本：引入useId 、useTransition 、useDeferredValue 、useSyncExternalStore 、useInsertionEffect 等 ")]),_:1})]),_:1})])])]),Object(a["createElementVNode"])("div",null,[Object(a["createElementVNode"])("h4",i,[Object(a["createVNode"])(c,{to:"#ReactEcology",class:"a-link"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])("#")]),_:1}),Object(a["createTextVNode"])("2、react 生态 ")]),r])],64)}}});const b=O;var j=b;const u={id:"ReactVirtualDOM"},s={id:"CreateVirtualDOM"},V=Object(a["createElementVNode"])("p",{class:"c-h6"},"第一种：JS 的方式创建虚拟DOM(几乎不用,了解即可)",-1),m=Object(a["createElementVNode"])("p",{class:"c-h6"},"第二种：JSX 的方式创建虚拟DOM",-1),p=Object(a["createElementVNode"])("p",null,[Object(a["createElementVNode"])("code",null,"JSX"),Object(a["createTextVNode"])("可以使我们更便捷的去创建虚拟DOM，也可以说"),Object(a["createElementVNode"])("code",null,"JSX"),Object(a["createTextVNode"])("创建虚拟DOM是原生 "),Object(a["createElementVNode"])("code",null,"JS"),Object(a["createTextVNode"])("创建虚拟"),Object(a["createElementVNode"])("code",null,"DOM"),Object(a["createTextVNode"])("的语法糖。 ")],-1),N={id:"VirtualDOMUnderstand"},v=Object(a["createStaticVNode"])('<section><div><p class="indent"> 从本质上说，<code>Virtual DOM</code>是一个<code>JavaScript</code>对象，通过对象的方式来表现 <code>DOM</code>结构。将页面的状态抽象为<code>JS</code>对象的形式，配合不同的渲染工具，是跨平台渲染 成为可能。通过事务处理机制，将多次<code>DOM</code>修改的结果一次性的更新到页面上，从而有效的减少页面 渲染的次数，减少修改<code>DOM</code>的重排重绘次数，提高渲染性能。 </p><p class="indent"> 虚拟<code>DOM</code>就是对<code>DOM</code>的抽象，这个对象是更加轻量级的对<code>DOM</code>的描述。 它设计的最初目的，就是更好的跨平台，比如<code>node.js</code>就没有<code>DOM</code>。如果想实现 <code>SSR</code>，那么一个方式就是借助虚拟<code>DOM</code>，因为虚拟<code>DOM</code>本身是<code>js</code> 对象。在代码渲染到页面之前，<code>Vue</code>或<code>React</code>会把代码转换成一个对象（虚拟DOM）。以 对象的形式来描述真实的<code>DOM</code>结构，最终渲染到页面。在每次数据发生变化前，虚拟<code>DOM</code>都 会缓存一份，变化之时，现在的虚拟<code>DOM</code>会与缓存的虚拟<code>DOM</code>进行比较。在<code>Vue</code> 或者<code>React</code>内部封装了<code>Diff</code>算法，通过这个算法来进行比较，渲染时只针对有变化的 <code>DOM</code>进行修改，原先没有发生改变的通过原先的数据进行渲染。 </p><p class="indent"> 另外现在前端框架的一个基本要求就是无需手动操作<code>DOM</code>，一方面是因为手动操作<code>DOM</code>无法 保证性能，多人协同的项目中如果<code>review</code>不严格，可能会有开发者写出性能较低的代码，另一方面 更重要的是省略手动<code>DOM</code>操作可以大大提高效率。 </p></div><div><p class="c-h6"> 为什么要用 Virtual DOM： </p><div><p class="s-indent c-h6">(1) 保证性能下限，在不进行手动优化的情况下，提供过得去的性能</p><p> 下面对比一下修改<code>DOM</code>时真实<code>DOM</code>操作和<code>Virtual DOM</code>操作的 过程，来看一下它们重排重绘的性能消耗： </p><div><ul><li><span class="c-h7">真实DOM：</span> 生成 <code>HTML</code> 字符串 -&gt; 重建所有的 <code>DOM</code> 元素 </li><li><span class="c-h7">Virtual DOM：</span> 生成<code>vNode</code> -&gt; <code>DOM diff</code> -&gt; 必要的<code>DOM</code>更新 </li></ul></div></div><div><p class="s-indent c-h6"> (2) 跨平台 </p><p><code>Virtual DOM</code>本质上是<code>JavaScript</code>的对象，它可以很方便的跨平台操作， 比如服务器端渲染、uniapp等。 </p></div></div></section>',1),x={id:"ReactDiff"},D=Object(a["createStaticVNode"])('<section><p> 实际上，<code>diff</code> 算法探讨的就是虚拟 <code>DOM</code> 树发生变化后，生成 <code>DOM</code> 树更新补丁的方式。它通过对比新旧两株虚拟 <code>DOM</code> 树的变更差异， 将更新补丁作用于真实 <code>DOM</code> ，以最小成本完成视图更新。 </p><p class="c-h7">具体流程如下：</p><div><ul><li>真实的 <code>DOM</code> 首先会映射为虚拟 <code>DOM</code></li><li> 当虚拟<code>DOM</code>发生变化后，就会根据差异计算生成生成<code>patch</code>，这个 <code>patch</code>是一个结构化数据，内容包含了增加、更新、移除。 </li><li> 根据<code>patch</code>去更新真实的<code>DOM</code>，反馈到用户界面上。 </li></ul></div></section>',1),f={id:"ReactKey"},M={id:"ActualDOM"},h={id:"ReactDiffAndVueDiff"};var E=Object(a["defineComponent"])({__name:"virtualDOM",setup(e){const t=Object(a["getCurrentInstance"])(),{$builtIn:c}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,o=c('\n<div id="container2"></div>\n\n\x3c!-- 使用 js 创建虚拟 DOM --\x3e\n// 1.create virtual DOM\nconst virtualDOM2 = React.createElement(\n  "h1",\n  {},\n  React.createElement("span", { id: "title" }, "Hello world!")\n);\n// 2.render virtual DOM\nReactDOM.render(virtualDOM2, document.getElementById("container2"));\n'),d=c('\n<div id="container"></div>\n\n\x3c!-- 使用jsx 创建虚拟 DOM ( script 需要加上 type="text/babel")--\x3e\n// 1.create virtual DOM\nconst virtualDOM = (\n  <h1>\n    <span id="title">Hello world!</span>\n  </h1>\n);\n// 2.render virtual DOM\nReactDOM.render(virtualDOM, document.getElementById("container"));\n');return(e,t)=>{const c=Object(a["resolveComponent"])("RouterLink"),l=Object(a["resolveComponent"])("WebPrismEditor");return Object(a["openBlock"])(),Object(a["createElementBlock"])(a["Fragment"],null,[Object(a["createElementVNode"])("h3",u,[Object(a["createVNode"])(c,{to:"#ReactVirtualDOM",class:"a-link"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])("#")]),_:1}),Object(a["createTextVNode"])(" 2、虚拟 DOM ")]),Object(a["createElementVNode"])("div",null,[Object(a["createElementVNode"])("h4",s,[Object(a["createVNode"])(c,{to:"#CreateVirtualDOM",class:"a-link"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])("#")]),_:1}),Object(a["createTextVNode"])(" 1、虚拟DOM的两种创建方式 ")]),Object(a["createElementVNode"])("section",null,[Object(a["createElementVNode"])("div",null,[V,Object(a["createVNode"])(l,{modelValue:Object(a["unref"])(o),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(a["isRef"])(o)?o.value=e:null)},null,8,["modelValue"])]),Object(a["createElementVNode"])("div",null,[m,p,Object(a["createVNode"])(l,{modelValue:Object(a["unref"])(d),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(a["isRef"])(d)?d.value=e:null)},null,8,["modelValue"])])])]),Object(a["createElementVNode"])("div",null,[Object(a["createElementVNode"])("h4",N,[Object(a["createVNode"])(c,{to:"#VirtualDOMUnderstand",class:"a-link"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])("#")]),_:1}),Object(a["createTextVNode"])(" 2、对虚拟DOM的理解？虚拟DOM主要做了什么？虚拟DOM本身是什么？ ")]),v]),Object(a["createElementVNode"])("div",null,[Object(a["createElementVNode"])("h4",x,[Object(a["createVNode"])(c,{to:"#ReactDiff",class:"a-link"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])("#")]),_:1}),Object(a["createTextVNode"])(" 3、React diff算法的原理是什么？ ")]),D]),Object(a["createElementVNode"])("div",null,[Object(a["createElementVNode"])("h4",f,[Object(a["createVNode"])(c,{to:"#ReactKey",class:"a-link"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])("#")]),_:1}),Object(a["createTextVNode"])(" 4、React key是干嘛用的，为什么要加？key主要是解决哪一类问题的 ")])]),Object(a["createElementVNode"])("div",null,[Object(a["createElementVNode"])("h4",M,[Object(a["createVNode"])(c,{to:"#ActualDOM",class:"a-link"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])("#")]),_:1}),Object(a["createTextVNode"])(" 5、虚拟DOM的引入与直接操作原生DOM相比，哪一个效率更高，为什么 ")])]),Object(a["createElementVNode"])("div",null,[Object(a["createElementVNode"])("h4",h,[Object(a["createVNode"])(c,{to:"#ReactDiffAndVueDiff",class:"a-link"},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])("#")]),_:1}),Object(a["createTextVNode"])(" 6、React与Vue的diff算法有何不同？ ")])])],64)}}});const w=E;var R=w;function C(e,t){return null}var T=c("6b0d"),_=c.n(T);const k={},g=_()(k,[["render",C]]);var S=g,y=Object(a["defineComponent"])({__name:"componentLifeCycle",setup(e){return(e,t)=>null}});const I=y;var J=I;const B={class:"main"},U=Object(a["createElementVNode"])("h2",null,"react 基础",-1),F={class:"overview"},A=Object(a["createElementVNode"])("span",{class:"serial-no"},"1.",-1),H=Object(a["createElementVNode"])("span",{class:"serial-no"},"2.",-1),L=Object(a["createElementVNode"])("span",{class:"serial-no"},"3.",-1),P=Object(a["createElementVNode"])("span",{class:"serial-no"},"4.",-1);var X=Object(a["defineComponent"])({__name:"index",setup(e){const t=Object(a["getCurrentInstance"])(),{$builtIn:c}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,o=Object(a["ref"])("https://react.docschina.org/docs/hello-world.html"),d=Object(a["ref"])("https://www.jianshu.com/p/37d7de212df1"),l=Object(a["ref"])("https://goshacmd.com/controlled-vs-uncontrolled-inputs-react/"),n=Object(a["ref"])("https://www.jianshu.com/p/021736302706");return(e,t)=>{const c=Object(a["resolveComponent"])("navigationBlank");return Object(a["openBlock"])(),Object(a["createElementBlock"])("div",B,[U,Object(a["createElementVNode"])("div",F,[Object(a["createElementVNode"])("div",null,[A,Object(a["createVNode"])(c,{modelValue:o.value,"onUpdate:modelValue":t[0]||(t[0]=e=>o.value=e)},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" react官网资料 ")]),_:1},8,["modelValue"])]),Object(a["createElementVNode"])("div",null,[H,Object(a["createVNode"])(c,{modelValue:d.value,"onUpdate:modelValue":t[1]||(t[1]=e=>d.value=e)},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" 由浅入深快速掌握React Fiber ")]),_:1},8,["modelValue"])]),Object(a["createElementVNode"])("div",null,[L,Object(a["createVNode"])(c,{modelValue:l.value,"onUpdate:modelValue":t[2]||(t[2]=e=>l.value=e)},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" 受控组件和非受控组件 ")]),_:1},8,["modelValue"])]),Object(a["createElementVNode"])("div",null,[P,Object(a["createVNode"])(c,{modelValue:n.value,"onUpdate:modelValue":t[3]||(t[3]=e=>n.value=e)},{default:Object(a["withCtx"])(()=>[Object(a["createTextVNode"])(" React 生命周期&执行顺序 ")]),_:1},8,["modelValue"])])]),Object(a["createVNode"])(j),Object(a["createVNode"])(R),Object(a["createVNode"])(S),Object(a["createVNode"])(J)])}}});const $=X;t["default"]=$}}]);