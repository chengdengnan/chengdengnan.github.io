(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d216a20"],{c2fa:function(e,t,o){"use strict";o.r(t);var c=o("7a23");const n={id:"This"},l={id:"GlobalFunction"},r=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("this指向全局对象window，"),Object(c["createElementVNode"])("span",{class:"red"},"注意严格模式下"),Object(c["createTextVNode"])("，this为undefined")],-1),a={id:"ObjectMethod"},d=Object(c["createElementVNode"])("p",null,"this指向调用该方法的对象",-1),s={id:"Constructor"},i=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("this指向 "),Object(c["createElementVNode"])("span",{class:"red"},"new 关键字 "),Object(c["createTextVNode"])("创建出的实例")],-1),u={id:"SetTimeout"},m=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("定时器 setTimeout 或 setInterval，以及回调函数或匿名函数自调用，"),Object(c["createElementVNode"])("span",{class:"red"},"this指向全局对象window")],-1),j={id:"EventFunction"},b=Object(c["createElementVNode"])("p",null,"元素绑定事件，事件触发后执行函数，this指向的是当前元素",-1),V={id:"ArrowFunction"},O=Object(c["createElementVNode"])("p",null,"this指向箭头函数定义时所处的对象",-1),N={id:"CallApplyBind"},p=Object(c["createStaticVNode"])('<section><ul type="square"><li> call和apply：<span class="red">改变 this 指向后</span>执行函数。 <ul style="margin-left:1rem;" type="circle"><li>call(thisScope,arg1,arg2,arg...);<span class="red"> 多个参数，第一个参数为null、undefined时，默认指向Window</span></li><li>apply(thisScope,[arg1,arg2,arg...]);<span class="red"> 两个参数</span></li></ul></li></ul><ul type="square"><li>bind: 改变 this 指向后，返回函数，不执行。</li><p>bind(thisScopr,arg1,arg2,arg...) 多个参数</p></ul></section>',1),h=Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("div",{class:"c-h5"},"apply的使用方法(函数劫持、对象复制)"),Object(c["createElementVNode"])("div",{class:"indent"},[Object(c["createElementVNode"])("span",null,[Object(c["createTextVNode"])("可以看到 Student 不具备任何方法，但是在 "),Object(c["createElementVNode"])("span",{class:"red"},"Person.apply(this,arguments)"),Object(c["createTextVNode"])("之后，他就具备了Person类的方法及属性")])]),Object(c["createElementVNode"])("div",null,"由此得出结论： Function.apply() 能“劫持”另外一个对象， 继承另外一个对象的属性")],-1);var v=Object(c["defineComponent"])({__name:"this",setup(e){const t=Object(c["getCurrentInstance"])(),{$builtIn:o}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,v=o("\n// 'not strict' 【window】\nconsole.log(this);\nfunction funs(){\n    console.log(this); \n};\nfuns();\n\n// 'use strict' 【undefined】\nfunction stractDemo(){\n    'use strict'\n    console.log(this);\n};\nstractDemo();\n"),f=o("\nlet name = 'Global Barry';\nlet obj = {\n    name: 'Obj Barry',\n    getName: function(){\n        console.log(this.name)\n    },\n};\nobj.getName(); // 'Obj Barry'\n\nlet funs = obj.getName;\nfuns(); // 'Global Barry'\n"),E=o('\nfunction Barry(){\n    this.name = "Fashion pro Barry";\n    console.log(this);\n}\n\nlet n = new Barry();\nconsole.log(n)\n'),P=o('\n// setTimeout\nsetTimeout(function () {\n    console.log(this)\n}, 0)\n\nvar name = "my name is window"; // 注意var 和 const 输出是不一样的\nvar obj = {\n    name: "my name is obj",\n    funs: function () {\n        let timer = null;\n        clearInterval(timer);\n        timer = setInterval(function () {\n            console.log(this.name); // "my name is window"\n        }, 100);\n    },\n};\nobj.funs();\n\n\n// 回调函数\nvar o = {\n    age: 18,\n    say: function () {\n        function callback() {\n            return this.age;\n        }\n        func(callback);\n    },\n};\nfunction func(callback) {\n    var name = "Fashion Barry";\n    console.log(name, " is", callback() + " years"); \n}\no.say(); // Fashion Barry  is undefined years\n/**\n * 【解析】：\n * 函数内部的【this】指向于此函数的调用者（拥有者）\n * 但在上面这个例子中，为什么会输出unidentified\n * 虽然【callback】定义在对象【o】的【say】方法中，但实际上由于【callback】是在【func】函数中被普通调用的\n * 那么【func】中的【callback】的调用对象我们可以理解为【window】对象\n * 当使用一个对象未定义的属性时不会报错，会返回undefined，而直接使用一个未定义的变量便会报错\n*/\n\n'),y=o('\n<button id="btn">click me</button>\n\nwindow.onload = function () {\n    var btn = document.getElementById("btn");\n    btn.onclick = function () {\n        console.log(this);\n    };\n};\n'),x=o('\nvar name = "my name is window";\nvar obj = {\n    name: "my name is obj",\n    func: function () {\n        return (() => {\n            console.log(this.name); // my name is obj\n        })();\n    },\n};\nobj.func()\n'),w=o('\n// 对象方法:this指向方法前的对象\nvar person = {\n  name: "dog",\n  say: function (language) {\n    console.log(this.name + " say " + language);\n  },\n};\nperson.say("Hello world!");\n\n//call  改变this指向，传入多个参数\nvar name = "duck";\nperson.say.call(window, "Helo Window!");\n\n//apply 改变this指向，两个参数\n// person.say.apply(this, "Hello Apply!"); // 会报错TypeError: CreateListFromArrayLike called on non-object\n\nperson.say.apply(window, { name: "Hello Apply!" }); // nduck say undefined\n// apply 的第二个参数必须为数组\nperson.say.apply(this, ["Hello Apply!"]); // duck say Hello Apply\n\nvar arr = [1, 2, 3, 4];\nMath.max.apply(null, arr); //4, null表示不改变this指向\n\n// bind:改变this指向，不立即调用，而是返回该函数\nfunction multiply(x, y, z) {\n  return x * y * z;\n}\n\nvar double = multiply.bind(null, 2);\nconsole.log(double(3, 4)); // 24\n\nvar person1 = {\n  name: "dog",\n  sayHello: function () {\n    setTimeout(\n      function () {\n        console.log(this.name + " Say Hello!");\n      }.bind(this),\n      1000\n    );\n  },\n};\n\nperson1.sayHello(); //dog Say Hello!\n\n'),T=o('\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayHello = function () {\n    console.log(this.name + " Say hello!");\n  };\n}\n\nfunction Student(name, age, grade) {\n  Person.apply(this, arguments);\n  this.grade = grade;\n}\n\nvar s = new Student("Barry", 18, "middle school");\nconsole.log(s.name); // Barry\nconsole.log(s.age); // 18\nconsole.log(s.grade); //middle school\ns.sayHello(); // Barry Say hello!\n'),g=o("\n// 面试题解析\nvar x = 20;\nvar a = {\n  x: 15,\n  fn: function () {\n    var x = 30;\n    return function () {\n      return this.x;\n    };\n  },\n};\n\nconsole.log(a.fn()); // Function ƒ(){return this.x}\nconsole.log((a.fn())()); // 20 a.fn()返回的是一个函数，()()这是自执行表达式。this -> window\nconsole.log(a.fn()()); // 20 a.fn()相当于在全局定义了一个函数，然后再自己调用执行。this -> window\nconsole.log(a.fn()() == (a.fn())()); //true\nconsole.log(a.fn().call(this)); // 20 这段代码在全局环境中执行，this -> window\nconsole.log(a.fn().call(a)); // 15, 更改this指向为 a，a的x为15\n\n");return(e,t)=>{const o=Object(c["resolveComponent"])("RouterLink"),R=Object(c["resolveComponent"])("WebPrismEditor");return Object(c["openBlock"])(),Object(c["createElementBlock"])("div",null,[Object(c["createElementVNode"])("h3",n,[Object(c["createVNode"])(o,{to:"#This",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、This指向 ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",l,[Object(c["createVNode"])(o,{to:"#GlobalFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、全局函数 ")]),Object(c["createElementVNode"])("section",null,[r,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(v),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(c["isRef"])(v)?v.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",a,[Object(c["createVNode"])(o,{to:"#ObjectMethod",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、对象方法 ")]),Object(c["createElementVNode"])("section",null,[d,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(f),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(c["isRef"])(f)?f.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",s,[Object(c["createVNode"])(o,{to:"#Constructor",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、构造函数 ")]),Object(c["createElementVNode"])("section",null,[i,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(E),"onUpdate:modelValue":t[2]||(t[2]=e=>Object(c["isRef"])(E)?E.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",u,[Object(c["createVNode"])(o,{to:"#SetTimeout",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、定时器、回调函数 ")]),Object(c["createElementVNode"])("section",null,[m,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(P),"onUpdate:modelValue":t[3]||(t[3]=e=>Object(c["isRef"])(P)?P.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",j,[Object(c["createVNode"])(o,{to:"#EventFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、事件函数 ")]),Object(c["createElementVNode"])("section",null,[b,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(y),"onUpdate:modelValue":t[4]||(t[4]=e=>Object(c["isRef"])(y)?y.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",V,[Object(c["createVNode"])(o,{to:"#ArrowFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("6、箭头函数 ")]),Object(c["createElementVNode"])("section",null,[O,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(x),"onUpdate:modelValue":t[5]||(t[5]=e=>Object(c["isRef"])(x)?x.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",N,[Object(c["createVNode"])(o,{to:"#CallApplyBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("7、call、apply、bind ")]),Object(c["createElementVNode"])("section",null,[p,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(w),"onUpdate:modelValue":t[6]||(t[6]=e=>Object(c["isRef"])(w)?w.value=e:null)},null,8,["modelValue"]),h,Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(T),"onUpdate:modelValue":t[7]||(t[7]=e=>Object(c["isRef"])(T)?T.value=e:null)},null,8,["modelValue"]),Object(c["createVNode"])(R,{modelValue:Object(c["unref"])(g),"onUpdate:modelValue":t[8]||(t[8]=e=>Object(c["isRef"])(g)?g.value=e:null)},null,8,["modelValue"])])])])}}});const f=v;var E=f;const P={id:"Promise"},y={id:"Reference"},x=Object(c["createStaticVNode"])('<section><div><span>1.</span><a target="_blank" rel="help" href="http://liubin.org/promises-book/" class="a-navigation">JavaScript Promise迷你书(中文版)</a></div><div><span>2.</span><a target="_blank" href="https://juejin.cn/post/6844903455962693640" class="a-navigation">深入理解Promise(上)</a></div><div><span>3.</span><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903667494027278">从手写一个符合Promise/A+规范Promise来深入学习Promise</a></div><div><span>4.</span><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903550288412679">Promise深度学习---我のPromise/A+实现 </a></div><div><span>5.</span><a target="_blank" class="a-navigation" href="https://mp.weixin.qq.com/s/Yrwe2x6HukfqJZM6HkmRcw">【第1738期】100 行代码实现 Promises/A+ 规范</a></div><div><span>6.</span><a target="_blank" class="a-navigation" href="https://zhuanlan.zhihu.com/p/144058361">从零开始手写Promise </a></div><div><span>7.</span><a target="_blank" class="a-navigation" href="https://blog.csdn.net/weixin_56650035/article/details/121070438?spm=1001.2014.3001.5502">PromiseA+规范之手写Promise </a></div></section>',1),w={id:"ConstructorStatus"},T=Object(c["createElementVNode"])("div",{class:"c-h5"},"1. 构造函数",-1),g=Object(c["createStaticVNode"])('<section><div class="c-h5">2. 状态</div><section><ul><li>初始状态 -&gt; pending <ul type="cricle" class="ml-15"><li>初始状态可以改变</li><li>在resolve 或者 reject 调用之前都处于这个状态</li></ul></li><li>最终成功状态 -&gt; fulfilled <ul type="cricle" class="ml-15"><li>执行 resolve 函数，状态改变为 fulfilled</li><li>执行 onFulfilled 函数</li></ul></li><li>最终失败状态 -&gt; rejected <ul type="cricle" class="ml-15"><li>执行 reject 函数，状态改变为 rejected</li><li>执行 onRejected 函数</li></ul></li><li>then 方法 <ul type="cricle" class="ml-15"><li>then 方法为 Promise 对象注册了 onFulfilled 和 onRejected 函数</li></ul></li><li>catch 方法 <ul type="cricle" class="ml-15"><li>catch 方法为Promise 对象注册了 onRejected 函数</li></ul></li></ul></section></section>',1),R={id:"NineMethods"},S=Object(c["createElementVNode"])("div",{class:"c-h5"}," 1. Promise.resolve",-1),k=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])("静态方法"),Object(c["createElementVNode"])("code",null,"Promise.resolve(value)"),Object(c["createTextVNode"])("可以认为是"),Object(c["createElementVNode"])("code",null,"new Promise"),Object(c["createTextVNode"])("方法的语法糖,比如"),Object(c["createElementVNode"])("code",null,"Promise.resolve(42)"),Object(c["createTextVNode"])(" 可以认为是以下代码的语法糖 ")],-1),F={class:"indent"},C=Object(c["createElementVNode"])("code",null,"Promise",-1),_=Object(c["createElementVNode"])("code",null,"onFulfilled",-1),U=Object(c["createElementVNode"])("code",null,"new Promise",-1),A=Object(c["createElementVNode"])("code",null,"Promise",-1),B=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])(" 简单总结一下 "),Object(c["createElementVNode"])("code",null,"Promise.resolve"),Object(c["createTextVNode"])("方法的话，它的作用就是将传递给它的参数填充 "),Object(c["createElementVNode"])("code",null,"Fulfilled"),Object(c["createTextVNode"])(" 到 "),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])(" 对象后并返回这个 "),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])(" 对象。 ")],-1),I=Object(c["createElementVNode"])("div",{class:"c-h5"},"2. Promise.reject",-1),q=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createElementVNode"])("code",null,"Promise.reject(error)"),Object(c["createTextVNode"])("是和"),Object(c["createElementVNode"])("code",null,"Promise.resolve(value)"),Object(c["createTextVNode"])("类似的静态方法，是 "),Object(c["createElementVNode"])("code",null,"new Promise"),Object(c["createTextVNode"])(" 方法的快捷方式。比如 "),Object(c["createElementVNode"])("code",null,'Promise.reject(new Error("Promise reject error"))'),Object(c["createTextVNode"])(" 就是下面代码的语法糖形式 ")],-1),G=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])(" 简单总结一下 "),Object(c["createElementVNode"])("code",null,"Promise.reject"),Object(c["createTextVNode"])("方法的话：它的功能是调用该 "),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象通过then指定的 "),Object(c["createElementVNode"])("code",null,"onRejected"),Object(c["createTextVNode"])("函数，并讲错误（Error）对象传递给这个"),Object(c["createElementVNode"])("code",null,"onRejected"),Object(c["createTextVNode"])("函数 ")],-1),H=Object(c["createElementVNode"])("div",{class:"c-h5"},"3. Promise.then",-1),D=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"Promise.then(onFulfilled, onRejected)")],-1),M=Object(c["createElementVNode"])("div",{class:"c-h6"},"① 函调函数异步执行",-1),J=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"Promise/A+规范"),Object(c["createTextVNode"])("统一规定：Promise 只能使用异步调用方式 ")],-1),L=Object(c["createStaticVNode"])('<div class="c-h6">② 返回值</div><p class="indent">不管你在回调函数 <code>onFulfilled</code>中会返回一个什么样的值，或者不返回值，该值都会由 <code>Promis.resolve(return 的返回值)</code> 进行响应的包装处理。因此，最终 <code>then</code>的结果都是返回一个新创建的 <code>Promise</code>对象。 </p><p class="indent"> 也就是说，<code>Promis.then</code>不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个<code>Promise</code> 对象。正是 <code>then</code>函数中有了这样返回值的机制，才能使得在整个<code>Promise</code>链式结构当中，每个<code>then</code>方法都能给 下一个<code>then</code>方法传递参数。现在我们知道怎么返回的<code>Promise</code>是之前的还是新的？另外该<code>Promise</code>的状态又是如何？ </p>',3),W=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("从上面结果来看，实际上不管是调用 "),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("还是"),Object(c["createElementVNode"])("code",null,"catch"),Object(c["createTextVNode"])("方法， 都返回了一个新的"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象")],-1),z=Object(c["createElementVNode"])("div",{class:"c-h6 red"},"③ promise穿透",-1),$=Object(c["createElementVNode"])("p",null,"我们先来举个例子：",-1),Y=Object(c["createElementVNode"])("p",null,"如果你认为输出的是【 Barry Promise 】，那么你就错了，实际上他输出的是 【 Barry 】",-1),Z=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("产生这么的输出是因为你给"),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("方法传递了一个非函数(比如"),Object(c["createElementVNode"])("code",null,"promise"),Object(c["createTextVNode"])("对象)的值，代码会这样理解 : "),Object(c["createElementVNode"])("code",null,"then(null)"),Object(c["createTextVNode"])(",因此导致了前一个"),Object(c["createElementVNode"])("code",null,"promise"),Object(c["createTextVNode"])("的结果产生了坠落的效果，也就是和下面代码是一样的， 代码直接穿透了"),Object(c["createElementVNode"])("code",null,"then(null)"),Object(c["createTextVNode"])("进入了下一层链： ")],-1),K=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("随意添加多个"),Object(c["createElementVNode"])("code",null,"then(null)"),Object(c["createTextVNode"])("结果都是一样的")],-1),Q=Object(c["createElementVNode"])("div",{class:"c-h5"},"4. Promise.catch",-1),X=Object(c["createElementVNode"])("div",{class:"c-h6"},"① 语法糖的本质",-1),ee=Object(c["createElementVNode"])("p",{class:"indent"},[Object(c["createTextVNode"])(" 这里我们再说一遍，实际上"),Object(c["createElementVNode"])("code",null,"Promise.catch"),Object(c["createTextVNode"])("只是"),Object(c["createElementVNode"])("code",null,"promise.then(undefined, onRejected)"),Object(c["createTextVNode"])(" 方法的一个别名而已。也就是说，这个方法用来注册当"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象状态变为 "),Object(c["createElementVNode"])("code",null,"Rejected"),Object(c["createTextVNode"])("时 的回调函数。可以看下面代码，两者写法是等价的，但是很明显 "),Object(c["createElementVNode"])("code",null,"Promise.catch"),Object(c["createTextVNode"])("会让人第一眼看上去不会眼花缭乱: ")],-1),te=Object(c["createStaticVNode"])("<p>那么我们现在来说说为什么推荐使用第二种方法，而不是第一种:</p><div><ul><li>使用<code>promise.then(onFulfilled, onRejected)</code> 的话，在<code>onFulfilled</code>中发生异常的话，<code>onRejected</code> 中是捕获不到这个异常的。而且如果链式很长，每一条链上都要这么写。 </li><li> 在<code>promise.then(onFulfilled).catch(onRejected)</code> 的情况下<code>.then</code>中产生异常能在<code>.catch</code> 中捕获。<code>.then</code>和<code>.catch</code>本质上是没有区别的， 需要分场合使用 </li></ul></div>",2),oe=Object(c["createStaticVNode"])('<div class="c-h6">② 只有一个主人</div><p class="indent">我们上面已经说过了，在书写很长的<code>Promise</code>链式，从代码清晰度和简易程度来讲，在最后添加 <code>catch</code>是远远在每一层链上写<code>onRejected</code>回调函数是要好的，因为<code>catch</code>可以捕获 <code>Promise</code>链中每一层节点的错误，这句话本身没有错，但从这句话延伸出一种错误的理解：<code>catch</code> 同时监控着所有节点。实际上<code>catch</code>函数在同一个时间点只属于某一个<code>Promise</code>，因为它的主人是随着程序 的执行而不断变化的，我们来举个例子： </p>',2),ce=Object(c["createStaticVNode"])("<p>在上述例子中，如果整个程序每一步都正确执行，那么会顺序产生三个<code>Promise</code>对象，分别是 <code>Promise(1)</code>,<code>Promise(2)</code>,<code>Promise(3)</code>: </p><ul><li>可是如果在第一层具体执行逻辑出错了后，那实际上后面的两个<code>then</code> 中的回调函数压根不会被异步执行，所以会直接异步触发<code>catch</code>中的回调函数执行， 所以这种情况下<code>catch</code>是<code>Promise(1)</code>对象的<code>catch</code>。 </li><li> 如果第一层具体执行逻辑正确执行，就会异步触发第二个<code>then</code>中的回调函数执行，那么同理 ，在第二次具体执行逻辑抛出错误，会导致<code>Promise(2)</code>的状态变化，所以这种情况下<code>catch</code> 是<code>Promise(2)</code>对象的<code>catch</code>。 </li><li>同理<code>Promise(3)</code>也是如此</li></ul><p>总结下来就是：整个<code>Promise</code>链中，<code>catch</code>只属于异步触发它当中回调函数 执行的那个<code>Promise</code>，并不属于所有 <code>Promise</code></p>",3),ne=Object(c["createStaticVNode"])('<div class="c-h5">5. Promise.finally</div><p class="indent"><code>promise.finally</code>方法的回调函数不接受任何参数，这意味着<code>finally</code>没有办法 知道，前面的<code>Promise</code>状态到底是<code>fulfilled</code>还是<code>rejected</code> 。这表明，<code>finally</code>方法里面的操作，应该是与<code>Promise</code>状态无关的，不依赖于 <code>Promise</code>的执行结果。我们来看下面代码： </p>',2),le=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"finally"),Object(c["createTextVNode"])("本质上是"),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("方法的特例。我们来看下面伪代码：")],-1),re=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("上面代码中，如果不使用"),Object(c["createElementVNode"])("code",null,"finally"),Object(c["createTextVNode"])("方法，同样的语句需要为成功和失败的状态各写一次。 有了"),Object(c["createElementVNode"])("code",null,"finally"),Object(c["createTextVNode"])("方法，则只需要写一次。那么它是如何实现的呢？ ")],-1),ae=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("上述代码中，不管前面的"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("是"),Object(c["createElementVNode"])("code",null,"fulfilled"),Object(c["createTextVNode"])("还是"),Object(c["createElementVNode"])("code",null,"rejected"),Object(c["createTextVNode"])(" ，都会执行回调函数"),Object(c["createElementVNode"])("code",null,"callback")],-1),de=Object(c["createStaticVNode"])('<div class="c-h5">6. Promise.all</div><p class="indent"><code>Promise.all</code>接受一个<code>promise</code>对象的数组作为参数，当这个数组里的所有 <code>Promise</code> 对象 全部变为<code>resolve</code>或者<code>reject</code>状态的时候，它才会去调用<code>.then</code>方法。 </p><p class="indent"> 传递给<code>Promise.all</code>的 <code>promise</code>并不是一个个的顺序执行的，而是同时开始、并行执行的，我们可以看下面例子 </p>',3),se=Object(c["createStaticVNode"])('<p>为什么这个例子可以看出来<code>Promise.all()</code>是并行的呢？因为所有<code>Promise</code>执行完只用了5秒，如果3个 <code>Promise</code>是按照顺序执行的，那么应该是9秒或者，在5-9之间，因为4个<code>Promise</code>并不是同时执行的，同时执行的 话总时间就是那个花费时间最长的<code>Promise</code></p><p><code>Promise.all()</code>重要细节点 <span class="red">（面试常考）</span>：</p><div><ul><li> 如果所有的<code>Promise</code>中只有一个执行错误，那么整个<code>Promise.all</code>不会走<code>Promise.all().then()</code> 而是走<code>Promise.all().catch()</code>这个流程了。但是要注意的是虽然走到了<code>Promise.all().catch()</code>这个流程 ，<span class="red">但是其他<code>Promise</code>还是会正常执行，但不会返回结果</span></li><li> 要注意<code>Promise.all()</code>的返回值顺序，<code>Promise.all().then()</code>的返回值顺序和传入的顺序是一致的，笔试时 遇到手写<code>Promise.all()</code>时要注意 </li></ul></div>',3),ie=Object(c["createStaticVNode"])('<div class="c-h5">7. Promise.allSettled</div><p><code>Promise.allSettled()</code>的入参和<code>Promise.all、Promise.race</code>一样，接受一个<code>promise</code> 对象的数组作为参数,也是同时开始、并行执行的。但是<code>Promise.allSettled</code>的返回值需要注意以下几点： </p><p><code>Promise.allSettled</code>不会走进catch，当所有输入<code>Promise</code>都被履行或者拒绝时，<code> statusesPromise </code>会解析一个具有具体完成状态的数组 </p><div><ul><li><code>{ status: &#39;fulfilled&#39;, value:value } </code>：如果相应的<code>promise</code>被履行</li><li><code>{ status: &#39;rejected&#39;, reason: reason }</code>：如果相应的<code>promise</code>被拒绝</li></ul></div><p>我们看下面示例:</p>',5),ue=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("总结一下："),Object(c["createElementVNode"])("code",null,"Promise.allSettled()"),Object(c["createTextVNode"])("在你需要执行平行和独立的异步操作并收集所有结果时非常有效， 即使某些异步操作可能失败。")],-1),me=Object(c["createStaticVNode"])('<div class="c-h5">8. Promise.race</div><p class="indent"><code>Promise.rece()</code>的使用方法和 <code>Promise.all</code>一样，接收一个<code>promise</code> 对象的数组为参数，<code>Promise.race</code>是要有一个promise对象进入<code>Fulfilled</code>或者 <code>Rejected</code>状态的话，就会继续进行后面的处理。这里依旧有两个点要注意： </p><div><ul><li>和<code>Promise.all</code>一样是所有数组当中的<code>Promise</code>同时并行的</li><li><code>Promise.race</code> 在第一个<code>Promise</code>对象变为<code>Fulfilled</code>之后，并不会 取消其他<code>promise</code>对象的执行。</li><li><code>Promise.race</code>接受的是一个<code>Promise</code>对象数组，但是返回的确实最先完成<code>Fulfilled</code> 或者最先被<code>Rejected</code>的一个Promise的结果 </li></ul></div><p>下面我们来举个例子：</p>',4),je=Object(c["createStaticVNode"])("<p>这里我们再复习一下<code>Node</code>当中事件循环的知识：</p><div><ul><li>第一层循环：i为0时，异步触发了<code>Promise.race().catch()</code>，这里面的回调代码被放在了微任务队列中， 后面的3个<code>setTimeout</code>宏任务的回调函数代码被放进了<code>timer</code>阶段中的队列当中(其实并不是这样，因为 三个定时器都有延迟，都是在后面的事件循环中添加进来的) </li><li>第二层循环：清空微任务对列，所以控制台打印出了错误，然后清空宏任务，分别打印出<code>3000/5000/7000</code></li></ul></div>",2),be=Object(c["createStaticVNode"])('<div class="c-h5">9. Promise.any</div><p><code>Promise.any</code>的入参和<code>Promise.all、Promise.race、Promise.allSettled</code>一样， 接收一个<code>promise</code>对象的数组作为参数。 </p><div><ul><li>只要其中有一个<code>Promise</code>成功执行，就会返回已经成功执行的<code>Promise</code>的结果</li><li>如果这个<code>promise</code>对象的数组中没有一个<code>promise</code> 可以成功执行（即所有的 <code>promise</code>都失败 ），就返回一个失败的<code>promise</code> 和<code>AggregateError</code>类型的实例，它是<code>Error</code>的一个子类，用于把单一的错误集合 在一起 </li></ul></div>',3),Ve=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])(" 总计一下"),Object(c["createElementVNode"])("code",null,"Promisea.any"),Object(c["createTextVNode"])("的应用场景：如果我们现在有多台服务器，则尽量使用响应速度最快的服务器，在这种情况下， 可以使用"),Object(c["createElementVNode"])("code",null,"Promise.any()"),Object(c["createTextVNode"])("方法从最快的服务器接收响应。 ")],-1),Oe={id:"ErrorCapture"},Ne=Object(c["createStaticVNode"])('<div class="c-h5">1. 使用reject而不是throw</div><p class="indent"> 在最开始我们先来一句比较重要的话：<code>Promise</code>的构造函数，以及被<code>then</code>调用执行的函数基本上都可以认为是 在<code>try...catch</code>代码块中执行的，所以在这些代码中即使使用<code>throw</code>，程序本身也不会异常而终止。 </p><p class="indent"> 所以其实如果在<code>Promise</code>中使用<code>throw</code>语句的话，会被<code>try...catch</code>住，最终<code>Promise</code> 对象也会变为<code>Rejected</code>状态。但是我们为什么还是推荐使用<code>Promise.reject</code>呢？有下面两个原因： </p><div><ul><li>我们很难区分<code>throw</code>是我们主动抛出来的，还是因为真正的其他异常导致的，无法主动决定，属于被动。</li><li><code>Promise</code>构造函数当中通过<code>throw</code>抛出来的错误未必会被<code>Promise.catch</code> 捕获到 </li></ul></div><p>下面我们就说说什么时候通过<code>throw</code>抛出的错误未必会被<code>Promise.catch</code>捕获到：</p>',5),pe=Object(c["createStaticVNode"])("<p>这个例子非常典型，想知道为什么错误没有被<code>catch</code>住，我们要到推出原因：</p><div><ul><li>首先我们要明确的是，不论是<code>then</code>还是<code>catch</code>中注册的回调函数，都是由<code>Promise</code> 状态的变化触发的，现在也就说<code>Promise</code>状态始终在<code>pending</code>状态。 </li><li> 其次，前面不是说<code>reject</code>和<code>throw</code>都能最终让<code>Promise</code>进入<code>onReject</code> 状态，这里的<code>throw</code>为什么没有改变<code>Promise</code>的状态。 </li><li> 原因还是要从事件循环来说，我们好好想想，这段代码在第一轮的事件循环当中<code>setTimeout</code>的回调函数被放在了 <code>timer</code>阶段的队列当中，但是它没有执行啊，所以第一轮的<code>Promise</code>状态一直处于<code>pending</code> ，所以<code>then</code>和<code>catch</code>部分的代码全部没有触发，也就在第一轮事件循环当中跳过了。然后在第二轮 循环当中才执行了<code>throw</code>语句，把错误直接抛到了全局，就直接报错。所以上面的代码和下面效果一样，catch怎么可能 捕获到在它后面执行的代码呢？ </li></ul></div>",2),he=Object(c["createStaticVNode"])('<div class="c-h5">2. 在then中进行reject</div><p class="indent">如果我们想在<code>then</code>当中使用<code>reject</code>，首先我们要懂两个知识点：</p><div><ul><li><code>then</code>中的回调函数中，<code>return</code>的返回值类型不光是简单的字面值，还可以是复杂的对象类型， 比如<code>Promise</code>对象等。 </li><li> 只要修改这个返回的<code>Promise</code>的状态，在下一个<code>then</code>中注册的回调函数中的<code>onFulfilled</code> 和<code>onRejected</code>的哪一个会被调用也是能确定的 </li></ul></div><p>所以我们可以这样写代码就能在<code>then</code>当中使用<code>reject</code>:</p>',4),ve=Object(c["createElementVNode"])("p",null,"当然还能更简洁一些：",-1),fe={id:"ReturnValue"},Ee=Object(c["createStaticVNode"])("<p>关于返回值的知识其实我们在前面都已经讲过，这里总结一下并举个例子巩固一下：</p><div><ul><li><code>Promise</code>会将最后的值存储起来，如果在下次使用<code>Promise</code>方法的时候，会直接返回该值 的<code>Promise</code></li><li><code>Promise</code>能够链式调用的原因是因为它的每一个方法都返回新的<code>Promise</code> ，哪怕是<code>finally</code>方法，特殊的是<code>finally</code>会返回上一个<code>Promise</code>的值 包装成新的<code>Promise</code>，并且<code>finally</code>也不接受参数，因为无论<code>Promise</code>是 <code>reject</code>还是<code>fulfill</code>它都会被调用 </li></ul></div><p>下面我们举个例子：</p>",3),Pe=Object(c["createStaticVNode"])("<p>这个例子也很经典，即使你已经搞清楚了上面的知识点，面对这个例子也还是会蒙掉，我们来说一下：</p><div><ul><li>首先通过构造函数创建了一个<code>Promise</code>，我们这里称之为<code>Promise_1</code> ，通过<code>reject</code>进入<code>catch</code>函数，然后注意，<code>catch</code>的回调 函数返回了一个2，实际上这里是返回了一个新的<code>Promise</code>，我们这里称之为<code> Promise_2 </code>，它的状态是<code>fulfilled</code>。 </li><li> 所以这里很迷惑人的一点就是<code>p1</code>最开始是指向<code>Promise_1</code>的，当 <code>Promise_2</code>返回的时候，它又指向了<code>Promise_20</code></li><li> 最后定时器经过一秒打印出2，因为<code>Promise_2</code>在被返回的时候就是<code>fulfilled</code> 状态，<code>then</code>函数当中的回调函数自然而然的被异步触发。 </li></ul></div>",2),ye={id:"Async"},xe=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"co"),Object(c["createTextVNode"])("模块的语法糖（用于 "),Object(c["createElementVNode"])("code",null,"Generator"),Object(c["createTextVNode"])(" 函数的自动执行）")],-1),we=Object(c["createStaticVNode"])('<p>资料</p><div><ul type="square"><li><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903457170653198">深入理解 ES7 的 async/await </a></li><li><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903767129718791">async/await 优雅的错误处理方法 </a></li><li><a target="_blank" class="a-navigation" href="https://juejin.cn/post/6844903860079738887">如何在 JS 循环中正确使用 async 与 await </a></li></ul></div><p>参考总结：</p><div><ul><li> 如果一个函数通过<code>async</code>来声明，则一定可以通过<code>await</code>关键字来取到该函数 的返回值。 </li><li> 如果一个函数通过<code>async</code>来声明，则一定也可以通过<code>.then()</code>方法来取到该函数 返回的<code>Promise</code>中的值(因为<code>async</code>声明的函数，<code>return</code>出来的 结果一定是<code>Promise</code>对象 ) </li><li> 如果一个函数没有通过<code>async</code>来声明，但只要<code>return</code>出来一个<code>Promise</code>， 也可以通过<code>.then()</code>拿到里面的值(因为没有<code>async/await</code>的年代就是这样做的 )。 </li><li> 如果一个函数通过<code>async</code>声明，则在该函数内部可以使用<code>await</code>，也可以使用<code>.then()</code>。这表明， </li><li> 如果一个函数没有通过<code>async</code>声明，则在该函数内部不可以使用<code>await</code>， 但是可以使用<code>.then()</code>。 </li></ul></div>',4),Te=Object(c["createElementVNode"])("div",{class:"c-h5"},"1. 语法糖",-1),ge=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("关键词是添加在函数定义之前的，一个"),Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("函数是定义会返回"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])(" 函数的简便写法。 ")],-1),Re=Object(c["createElementVNode"])("p",null,"比如：以下两个定义是有效的",-1),Se=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("相似的，会抛出错误的"),Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("函数等效于返回失败的"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("的函数")],-1),ke=Object(c["createElementVNode"])("div",{class:"c-h5"},"2. async函数的返回值",-1),Fe=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("其实"),Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("返回值有下面这四种情况：")],-1),Ce=Object(c["createElementVNode"])("p",{class:"indent c-h6"},[Object(c["createTextVNode"])("① 返回值是"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("对象")],-1),_e=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("这种情况是最常见，也是符合"),Object(c["createElementVNode"])("code",null,"async"),Object(c["createTextVNode"])("定义的")],-1),Ue=Object(c["createElementVNode"])("p",{class:"indent c-h6"},"② 返回值是普通值",-1),Ae=Object(c["createStaticVNode"])("<p>如果<code>return</code>出来一个普通值，会被包装成一个<code>Promise</code>对象。该<code>Promise</code> 状态为<code>fulfilled</code>，该<code>Promise</code>的值为该简单值。可以使用<code>.then()</code> 方法取到该<code>Promise</code>对象的值(该值就是 <code>async</code>声明的函数返回来的简单值 )。</p>",1),Be=Object(c["createElementVNode"])("p",{class:"indent c-h6"},"③ 返回值是Error类型",-1),Ie=Object(c["createStaticVNode"])("<p>如果<code>return</code>出来是一个<code>Error</code>类型，则同样会被包装成一个<code>Promise</code>对象， 该<code>Promise</code>对象的状态是<code>reject</code>，值是<code>Error</code>的信息，想取出来该<code>Promise</code> 的报错信息，可以通过<code>.then()</code>的第二个参数，或者通过<code>.catch</code>方法。 </p>",1),qe=Object(c["createElementVNode"])("p",{class:"indent c-h6"},"④ 没有返回值",-1),Ge=Object(c["createStaticVNode"])("<p> 如果没有<code>return</code>任何东西，则同样会返回一个<code>Promise</code>对象。该<code>Promise</code> 对象的状态为<code>fulfilled</code>，该<code>Promise</code>的值为<code>undefined</code>。 </p>",1),He={id:"Await"},De=Object(c["createStaticVNode"])("<p><code>await</code>关键字，它只能在<code>async</code>函数内部使用，让我们可以等待一个<code>Promise</code></p><p>如果在<code>async</code>函数外使用<code>Promise</code>，我们依然需要使用<code>then</code>和回调函数 ，例如普通函数和全局函数。所以目前取出<code>Promise</code>对象值的两种方法：<code>.then 和 await</code></p>",2),Me=Object(c["createElementVNode"])("div",{class:"c-h5"},"1. 最大作用",-1),Je=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"await"),Object(c["createTextVNode"])("最大的作用就是代替"),Object(c["createElementVNode"])("code",null,".then()"),Object(c["createTextVNode"])("方法，让整个成为同步的写法，更容易理解")],-1),Le=Object(c["createElementVNode"])("p",{class:"indent c-h6"},"① 串行异步",-1),We=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("当串联异步的操作时，"),Object(c["createElementVNode"])("code",null,"await"),Object(c["createTextVNode"])("要比"),Object(c["createElementVNode"])("code",null,".then()"),Object(c["createTextVNode"])("方法更加简洁。")],-1),ze=Object(c["createElementVNode"])("p",{class:"indent c-h6"},"① 并行异步",-1),$e=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("虽然并行异步的代码还是离不开"),Object(c["createElementVNode"])("code",null,"Promise.all"),Object(c["createTextVNode"])("或者"),Object(c["createElementVNode"])("code",null,"Promise.race"),Object(c["createTextVNode"])("方法，但是用来处理 最终的并行结果的代码也是很简洁的。 ")],-1),Ye=Object(c["createStaticVNode"])('<div class="c-h5">2. await本质</div><p>从上面我们列出的这么多代码来看，<code>await</code>本质就是<code>.then</code>方法的语法糖。事实上 ，<code>async/await</code>其实会编译为<code>Promise</code>与<code>then</code>回调。每次我们使用 <code>await</code>，解释器会创建一个<code>Promise</code>然后把<code>async</code>函数中的后续代码( 也就是书写在<code>await</code>后面的代码 )放在<code>then</code>回调中，并被计划在<code>Promise</code> 完成之后执行。所以下面两段代码是等价的 </p>',2),Ze=Object(c["createStaticVNode"])('<p>所以<code>await</code>关键字给我们的感觉是会让代码执行到<code>await</code>这一行的时候，“暂停执行” ，等到异步操作有了结果，再继续往下执行。那么问题来了， <span class="red"><code>await</code> 关键字会阻塞线程吗？</span>不会，因为还是我们上面说的那句话： <span class="red"><code>await</code>本质上是<code>.then()</code>的语法糖，<code>await</code>并没有 改变<code>JavaScript</code>单线程的本质，没有改变<code>event Loop</code>的模型，只是方便我们写代码，更快捷 ， 更清晰。</span>如下所示： </p>',1),Ke=Object(c["createStaticVNode"])('<p>所以通过上面这一段代码我们就能 <span class="red">明白</span> ：</p><br><p><code>await</code>关键字不会阻塞<code>js</code>的<code>event loop</code>线程。当代码执行到<code>async</code> 函数遇到<code>await</code>关键词时，不会继续往下执行，而是会发起异步调用，推入异步任务队列，等待异步处理。 但是此时<code>node</code>线程并不会闲着，而是继续执行<code>async</code>函数被调用的哪一行下面的代码。等到异步 操作的结果发生了变化时，将异步结果推入任务队列，<code>event loop</code>从队列中取出事件，推入的执行栈中。 </p>',3),Qe={id:"AsyncAwaitErrorCatch"},Xe=Object(c["createElementVNode"])("p",{class:"c-h5"},"1. try-catch",-1),et=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("因为当我们使用"),Object(c["createElementVNode"])("code",null,"async/await"),Object(c["createTextVNode"])("的时候我们的代码是同步的写法，同步的错误处理理所应当会先想到的就是 "),Object(c["createElementVNode"])("code",null,"try/catch"),Object(c["createTextVNode"])("，所以对于"),Object(c["createElementVNode"])("code",null,"async/await"),Object(c["createTextVNode"])("的处理我们可以采用"),Object(c["createElementVNode"])("code",null,"try/catch"),Object(c["createTextVNode"])("。 ")],-1),tt=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])(" 实际通过上述代码可以看到："),Object(c["createElementVNode"])("code",null,"try/catch"),Object(c["createTextVNode"])("的方法在对于错误类型单一的情况下是简洁明了的，但是如果是 不同类型的错误类型，如果我们还采用"),Object(c["createElementVNode"])("code",null,"try/catch"),Object(c["createTextVNode"])("的方法也不是不行，只能在错误处理的代码上就要分类处理 ，还不一定能准确知道是那个请求方法出了问题，所以使用"),Object(c["createElementVNode"])("code",null,"try/catch"),Object(c["createTextVNode"])("在多类型错误的分析和定位是上是吃亏的： ")],-1),ot=Object(c["createStaticVNode"])('<p class="c-h5">2. .then和.catch方法输出值</p><p> 针对<code>try/catch</code>的问题我们希望就是在有不同类型错误可能出现的情况下，我们还是能准备并分别不同的类型 做处理。而<code>async/await</code>本质就是<code>Promise</code>的语法糖，既然是<code>Promise</code>那么 就可以使用<code>then</code>函数和<code>catch</code>函数，通过<code>then</code>和<code>catch</code> 输出值。 </p>',2),ct=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("当在处理不同类型的错误的时候，我么就能分别在对应的不同的"),Object(c["createElementVNode"])("code",null,"Promise"),Object(c["createTextVNode"])("的链的末尾 "),Object(c["createElementVNode"])("code",null,"catch"),Object(c["createTextVNode"])("当中书写不同的处理函数 ")],-1),nt=Object(c["createElementVNode"])("p",{class:"c-h5"},"3. 更优雅的方式",-1),lt=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("使用 "),Object(c["createElementVNode"])("code",null,"then"),Object(c["createTextVNode"])("和"),Object(c["createElementVNode"])("code",null,"catch"),Object(c["createTextVNode"])("函数及数组解构，区分正常和异常结果，封装公共处理函数。 ")],-1),rt={id:"AsyncAwaitLoop"},at=Object(c["createStaticVNode"])('<section><p>参考资料: <a target="_blank" rel="help" href="https://juejin.cn/post/6844903860079738887" class="a-navigation">如何在 JS 循环中正确使用 async 与 await</a></p><div><ul><li>如果你想连续执行 <code>await</code>调用，请使用<code>for</code>循环(或者没有任何回调的循环)。</li><li>永远不要和<code>forEach</code>一起使用<code>await</code>，而是使用<code>for</code>循环(或者没有任何回调的循环)。</li><li>不要在<code>filter</code>和<code>reduce</code>中使用<code>await</code>，如果需要，先用<code>map</code> 进一步处理，然后再使用<code>filter</code>和<code>reduce</code>进行处理。 </li></ul></div></section>',1);var dt=Object(c["defineComponent"])({__name:"promise",setup(e){const t=Object(c["getCurrentInstance"])(),{$builtIn:o}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,n=o("\nvar promise = new Promise(function (resolve, reject) {\n  // 异步处理\n  // 处理结果成功调用 resolve\n  // 失败调用 reject\n});\n"),l=o("\nnew Promise(function (resolve) {\n    resolve(42)\n})\n"),r=o('\nnew Promise(function (reject) {\n    reject(new Error("Promise reject error"))\n})\n'),a=o('\nvar promise = new Promise((resolve, reject) => {\n  console.log("inner Promise"); // 1\n  setTimeout(() => {\n    resolve("Fashion Barry"); // 3\n  }, 1000);\n});\n\npromise.then((res) => {\n  console.log("res", res);\n});\nconsole.log("outer promise"); // 2\n// Promise 实际是一个同步函数，then 方法才是异步\n// 所以输出顺序如上\n'),d=o('\nvar aPromise = new Promise((resolve, reject) => {\n  resolve("aPromise");\n});\nvar thenPromise = aPromise.then((res) => {\n  console.log("thenPromise: ", res);\n});\nvar catchPromise = aPromise.catch((err) => {\n  console.error("catchPromise: ", err);\n});\n\nconsole.log(aPromise !== thenPromise); // true\nconsole.log(thenPromise !== catchPromise); // true\nconsole.log(aPromise, thenPromise, catchPromise); // Promise { "aPromise" }, Promise { <pending> }, Promise { <pending> }\n'),s=o('\nPromise.resolve("Barry")\n.then(Promise.resolve("Barry Promise"))\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),i=o('\nPromise.resolve("Barry")\n.then(null)\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),u=o('\nPromise.resolve("Barry")\n.then(null)\n.then({ name: "My name is Barry" })\n.then(null)\n.then((result) => {\n  console.log("result", result); // "Barry"\n});\n'),m=o("\n// 第一种写法\nPromise.resolve()\n  .then((data) => console.log(data))\n  .then(undefined, (err) => console.log(err));\n\n// 第二种写法\nPromise.resolve()\n  .then((data) => console.log(data))\n  .catch((err) => console.log(err));\n"),j=o('\nlet p1 = new Promise((resolve, reject) => {\n  // 第一层执行逻辑\n  resolve("first promise"); // Promise(1)\n})\n  .then((res) => {\n    // 第二层执行逻辑\n    return "second promise"; // Promise(2)\n  })\n  .then((res) => {\n    // 第三层执行逻辑\n    return "third promise"; // Promise(3)\n  })\n  .catch((err) => {\n    console.log("err", err);\n  });\n'),b=o('\nvar p1 = new Promise((resolve, rejevt) => {\n  setTimeout(() => {\n    resolve;\n  }, 1000);\n});\n\np1.then((res) => console.log(res))\n  .catch((err) => console.log(err))\n  .finally(() => console.log("finally"));\n'),V=o("\npromise.finally(() => {\n  // 执行逻辑\n});\n// 上面代码等同于下面\npromise.then(\n  (onFulilled) => {\n    // 语句\n    return onFulilled;\n  },\n  (onRejected) => {\n    // 语句\n    throw onRejected;\n  }\n);\n"),O=o('\nPromise.prototype.finally = function (callback) {\n  let p = this.constructor;\n  return this.then(\n    (value) => p.resolve(callback()).then(() => value),\n    (reason) =>\n      p.reject(callback()).then(() => {\n        throw reason;\n      })\n  );\n};\n\nvar p = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    reject("Promise err");\n  }, 1000);\n});\np.catch((err) => console.log("err", err)).finally(() => {\n  console.log("finally");\n});'),N=o('\nvar promise1 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise1--3000");\n  }, 3000);\n});\nvar promise2 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise2--1000");\n  }, 1000);\n});\nvar promise3 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise3--5000");\n  }, 5000);\n});\n\nvar promiseArr = [promise1, promise2, promise3];\nconsole.time("promiseArr");\nPromise.all(promiseArr)\n  .then((res) => {\n    console.log("res", res); // [\'promise1--3000\', \'promise1--1000\', \'promise1--5000\']\n    console.timeEnd("promiseArr"); // 5523.29296875 ms\n  })\n  .catch((err) => console.log(err));\n'),p=o('\nlet arr = [1000, 3000, 5000, 7000];\nlet promiseArr = [];\n\nfor (let i = 0; i < arr.length; i++) {\n  let newPromise = new Promise((resolve, reject) => {\n    if (i === 0) {\n      reject(new Error("第二个错误"));\n    } else {\n      setTimeout(() => {\n        console.log(arr[i]);\n        resolve(arr[i]);\n      }, arr[i]);\n    }\n  });\n  promiseArr.push(newPromise);\n}\n\nPromise.race(promiseArr)\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n\n// 控制台报错\n// 3000\n// 5000\n// 7000\n'),h=o('\nvar promise1 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    reject(new Error("promise1--3000"));\n    // resoleve("promise1--3000");\n  }, 3000);\n});\nvar promise2 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // reject(new Error("promise1--1000"))\n    resoleve("promise2--1000");\n  }, 1000);\n});\nvar promise3 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    resoleve("promise3--5000");\n    // reject(new Error("promise1--5000"))\n  }, 5000);\n});\nvar promiseArr = [promise1, promise2, promise3];\nconsole.time("promiseArr");\nPromise.allSettled(promiseArr)\n  .then((res) => {\n    console.log("res", res);\n    console.timeEnd("promiseArr");\n  })\n  .catch((err) => console.error(err))\n  .finally(() => console.log("finally"));\n'),v=o('\nvar promise1 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // reject(new Error("promise1--3000"));\n    resoleve("promise1--3000");\n  }, 3000);\n});\nvar promise2 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // reject(new Error("promise2--1000"))\n    resoleve("promise1--1000");\n  }, 1000);\n});\nvar promise3 = new Promise((resoleve, reject) => {\n  setTimeout(() => {\n    // resoleve("promise3--5000");\n    reject(new Error("promise1--5000"))\n  }, 5000);\n});\nvar promiseArr = [promise1, promise2, promise3];\nconsole.time("promiseArr");\nPromise.any(promiseArr)\n  .then((res) => {\n    console.log("res", res); // res promise1--1000\n    console.timeEnd("promiseArr");\n  })\n  .catch((err) => console.error(err)); \n  //所有的Promise都失败， AggregateError: All promises were rejected\n'),f=o('\nvar p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    throw new Error("async error");\n  }, 500);\n});\n\np1.then((res) => {\n  console.log("res--", res);\n}).catch((err) => {\n  console.error("err--", err);\n});\n// 会直接报错，不会走到 catch\n'),E=o("\nvar p1 = new Promise(function(resolve, reject) {\n})\n.then(res => {\n})\n.catch(err => {\n})\nthrow Error('async error')   "),dt=o('\nvar onRejected = console.error.bind(console);\nvar promise = Promise.resolve();\npromise\n  .then(() => {\n    var retPromise = new Promise(function (resolve, reject) {\n      reject(new Error("this promise is rejected"));\n    });\n    return retPromise;\n  })\n  .catch(onRejected);\n'),st=o('\nvar promise = Promise.resolve();\npromise\n  .then(function () {\n    return (retPromise = Promise.reject(\n      new Error("this promise is rejected")\n    ));\n  })\n  .catch((err) => console.error("err", err));\n'),it=o('\nvar p1 = new Promise((resolve, reject) => {\n  reject("p1");\n}).catch((err) => {\n  console.error("err", err);\n  return "p2";\n});\n\nsetTimeout(() => {\n  p1.then((res) => console.log(res));\n}, 1000);\n// 先打印出error 1\n// 1秒钟以后打印出 P2\n'),ut=o('\n(function* () {\n  var f1 = yield readFile("/etc/fstab");\n  var f2 = yield readFile("/etc/shells");\n  console.log(f1.toString());\n})();\n'),mt=o('\nfunction f() {\n  return Promise.resolve("TEST");\n}\n\n// asyncF is equivalent to f!\nasync function asyncF() {\n  return "Test";\n}\n// console.log(f());\n// console.log(asyncF());\n'),jt=o('\nfunction f() {\n  return Promise.reject("TEST");\n}\n\n// asyncF is equivalent to f!\nasync function asyncF() {\n  throw "Test";\n}\n// console.log(f());\n// console.log(asyncF());\n'),bt=o('\nconst request = require("request");\nasync function f1() {\n  return new Promise(function (resolve, reject) {\n    request("https://www.baidu.com/", function (err, res, body) {\n      resolve(body);\n    });\n  });\n}\n// 用then来拿到返回值\nf1().then((res) => console.log(res));\n// 用await来拿到返回值\n(async function () {\n  console.log(await f1());\n})();\n'),Vt=o("\nasync function f1 () {\n    return 10;\n}\n\nconsole.log(f1());     // Promise {<resolved>: 10}\nfn1().then(function (x) {\n  console.log(x);      // 10\n})\n"),Ot=o('\nasync function f1() {\n  throw new Error("ssss");\n}\n// 第一种\nf1().then(\n  (onFulfilled) => {},\n  (onRejected) => console.log(onRejected)\n);\n// 第二种\nf1().catch(function (e) {\n  console.log(e);\n});\n'),Nt=o('\nvar p1 = new Promise((resolve, reject) => {\n  resolve();\n});\np1.then((res) => console.log("p1", res));\n\nasync function p2() {\n  await (1 + 1);\n}\n(async () => {\n  console.log("p2", p2());\n})();\n'),pt=o('\nvar asyncFunc1 = function () {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve("asyncFunc1");\n    }, 1000);\n  });\n};\nvar asyncFunc2 = function () {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve("asyncFunc2");\n    }, 1000);\n  });\n};\n\n// 使用 .then 进行串联操作\nfunction asyncF() {\n  asyncFunc1()\n    .then((res) => {\n      console.log("res", res);\n      return asyncFunc2();\n    })\n    .then((res2) => {\n      console.log("res2", res2);\n    });\n}\nasyncF();\n\n// 使用 await 关键字\nasync function asyncF2() {\n  let res = await asyncFunc1();\n  let res2 = await asyncFunc2();\n  console.log("res", res);\n  console.log("res2", res2);\n}\nasyncF2();\n'),ht=o('\nvar asyncFunc1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve("asyncFunc1");\n  }, 1000);\n});\n\nvar asyncFunc2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve("asyncFunc2");\n  }, 1000);\n});\n\n// 使用 .then 进行串联操作\nfunction asyncF() {\n  // [ res1, res2 ] 结构\n  Promise.all([asyncFunc1, asyncFunc2]).then(([res1, res2]) => {\n    console.log("asyncF", res1, res2);\n  });\n}\nasyncF();\n\n// 使用 await 关键字\nasync function asyncF2() {\n  let [res1, res2] = await Promise.all([asyncFunc1, asyncFunc2]);\n  console.log("asyncF2", res1, res2);\n}\nasyncF2();\n'),vt=o('\n// await写法\nawait foo();         \nconsole.log("hello");\n\n// .then写法\nfoo().then(() => {\n    console.log("hello");\n});\n'),ft=o("\nvar p1 = new Promise((resolve, reject) => {\n  console.log(1);\n  setTimeout(() => {\n    resolve(6);\n  }, 1000);\n});\n\nasync function multipleRequestAsync() {\n  console.log(3);\n  let result = await p1;\n  console.log(result);\n  console.log(7);\n}\nconsole.log(2);\nmultipleRequestAsync();\nconsole.log(4);\nconsole.log(5);\n\n// 1 2 3 4 5 6 7\n"),Et=o('\n(async () => {\n  const _fetch = () => {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject("reject promise");\n      }, 1000);\n    });\n  };\n\n  try {\n    let result = await _fetch();\n    console.log("result", result);\n  } catch (err) {\n    console.log("err", err);\n  }\n})();\n'),Pt=o("\ntry {\n    let result = await fsData()        // 读取文件\n    let result = await requestData()   // 网络请求\n    let result = await readDb()        // 读取数据库\n} catch (error) {\n    // 不同的错误进行分类\n}\n"),yt=o('\n(async () => {\n  const _fetch = () => {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject("reject promise");\n      }, 1000);\n    });\n  };\n\n  let result = await _fetch()\n    .then((res) => res)\n    .catch((err) => console.log(err));\n  console.log("result", result);\n})();\n'),xt=o("\nconst data = await fsData().then(data => data ).catch(err => // 文件读取错误的处理)\nconst data = await requestData().then(data => data ).catch(err => // 网络请求错误的处理)\nconst data = await readDb().then(data => data ).catch(err => // 数据库读写错误的处理)\n"),wt=o('\n(async () => {\n  function handleError(err) {\n    if (err !== null) {\n      console.log("err", err);\n      // 具体错误处理逻辑，Tip 还是？\n    }\n  }\n\n  function handleData(data) {\n    if (data !== null) {\n      // 具体处理结果\n    }\n  }\n  const _fetch = () => {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject("reject promise");\n      }, 1000);\n    });\n  };\n\n  const [err, data] = await _fetch()\n    .then((data) => [null, data])\n    .catch((err) => [err, null]);\n  handleData(data);\n  handleError(err);\n\n  // 抽离成公共方法\n\n  const awaitWrap = (promise) => {\n    return promise.then((data) => [null, data]).catch((err) => [err, null]);\n  };\n  const [err1, data1] = await awaitWrap(_fetch());\n  handleData(data1);\n  handleError(err1);\n})();\n');return(e,t)=>{const o=Object(c["resolveComponent"])("RouterLink"),Tt=Object(c["resolveComponent"])("WebPrismEditor"),gt=Object(c["resolveComponent"])("cod");return Object(c["openBlock"])(),Object(c["createElementBlock"])("div",null,[Object(c["createElementVNode"])("h3",P,[Object(c["createVNode"])(o,{to:"#Promise",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、Promise(异步编程) ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",y,[Object(c["createVNode"])(o,{to:"#Reference",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、参考资料 ")]),x]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",w,[Object(c["createVNode"])(o,{to:"#ConstructorStatus",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、构造函数和状态 ")]),Object(c["createElementVNode"])("section",null,[T,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(n),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(c["isRef"])(n)?n.value=e:null)},null,8,["modelValue"])]),g]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",R,[Object(c["createVNode"])(o,{to:"#NineMethods",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、九大方法 ")]),Object(c["createElementVNode"])("section",null,[S,k,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(l),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(c["isRef"])(l)?l.value=e:null)},null,8,["modelValue"]),Object(c["createElementVNode"])("p",F,[Object(c["createTextVNode"])("这个静态方法会让"),C,Object(c["createTextVNode"])("对象立即进入确定(即resolved) 状态，并将42传递给后面 "),Object(c["createVNode"])(gt,null,{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("then")]),_:1}),Object(c["createTextVNode"])(" 里所指定的 "),_,Object(c["createTextVNode"])("函数。作为 "),U,Object(c["createTextVNode"])("的快捷方式，在进行 "),A,Object(c["createTextVNode"])(" 对象的初始化或者编写测试代码的时候都非常方便。 ")]),B]),Object(c["createElementVNode"])("section",null,[I,q,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(r),"onUpdate:modelValue":t[2]||(t[2]=e=>Object(c["isRef"])(r)?r.value=e:null)},null,8,["modelValue"]),G]),Object(c["createElementVNode"])("section",null,[H,D,Object(c["createElementVNode"])("div",null,[M,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(a),"onUpdate:modelValue":t[3]||(t[3]=e=>Object(c["isRef"])(a)?a.value=e:null)},null,8,["modelValue"]),J]),Object(c["createElementVNode"])("div",null,[L,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(d),"onUpdate:modelValue":t[4]||(t[4]=e=>Object(c["isRef"])(d)?d.value=e:null)},null,8,["modelValue"]),W]),Object(c["createElementVNode"])("div",null,[z,$,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(s),"onUpdate:modelValue":t[5]||(t[5]=e=>Object(c["isRef"])(s)?s.value=e:null)},null,8,["modelValue"]),Y,Z,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(i),"onUpdate:modelValue":t[6]||(t[6]=e=>Object(c["isRef"])(i)?i.value=e:null)},null,8,["modelValue"]),K,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(u),"onUpdate:modelValue":t[7]||(t[7]=e=>Object(c["isRef"])(u)?u.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("section",null,[Q,Object(c["createElementVNode"])("div",null,[X,ee,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(m),"onUpdate:modelValue":t[8]||(t[8]=e=>Object(c["isRef"])(m)?m.value=e:null)},null,8,["modelValue"]),te]),Object(c["createElementVNode"])("div",null,[oe,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(j),"onUpdate:modelValue":t[9]||(t[9]=e=>Object(c["isRef"])(j)?j.value=e:null)},null,8,["modelValue"]),ce])]),Object(c["createElementVNode"])("section",null,[ne,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(b),"onUpdate:modelValue":t[10]||(t[10]=e=>Object(c["isRef"])(b)?b.value=e:null)},null,8,["modelValue"]),le,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(V),"onUpdate:modelValue":t[11]||(t[11]=e=>Object(c["isRef"])(V)?V.value=e:null)},null,8,["modelValue"]),re,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(O),"onUpdate:modelValue":t[12]||(t[12]=e=>Object(c["isRef"])(O)?O.value=e:null)},null,8,["modelValue"]),ae]),Object(c["createElementVNode"])("section",null,[de,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(N),"onUpdate:modelValue":t[13]||(t[13]=e=>Object(c["isRef"])(N)?N.value=e:null)},null,8,["modelValue"]),se]),Object(c["createElementVNode"])("section",null,[ie,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(h),"onUpdate:modelValue":t[14]||(t[14]=e=>Object(c["isRef"])(h)?h.value=e:null)},null,8,["modelValue"]),ue]),Object(c["createElementVNode"])("section",null,[me,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(p),"onUpdate:modelValue":t[15]||(t[15]=e=>Object(c["isRef"])(p)?p.value=e:null)},null,8,["modelValue"]),je]),Object(c["createElementVNode"])("section",null,[be,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(v),"onUpdate:modelValue":t[16]||(t[16]=e=>Object(c["isRef"])(v)?v.value=e:null)},null,8,["modelValue"]),Ve])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Oe,[Object(c["createVNode"])(o,{to:"#ErrorCapture",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、错误捕获 ")]),Object(c["createElementVNode"])("section",null,[Ne,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(f),"onUpdate:modelValue":t[17]||(t[17]=e=>Object(c["isRef"])(f)?f.value=e:null)},null,8,["modelValue"]),pe,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(E),"onUpdate:modelValue":t[18]||(t[18]=e=>Object(c["isRef"])(E)?E.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("section",null,[he,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(dt),"onUpdate:modelValue":t[19]||(t[19]=e=>Object(c["isRef"])(dt)?dt.value=e:null)},null,8,["modelValue"]),ve,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(st),"onUpdate:modelValue":t[20]||(t[20]=e=>Object(c["isRef"])(st)?st.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",fe,[Object(c["createVNode"])(o,{to:"#ReturnValue",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、返回值 ")]),Object(c["createElementVNode"])("section",null,[Ee,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(it),"onUpdate:modelValue":t[21]||(t[21]=e=>Object(c["isRef"])(it)?it.value=e:null)},null,8,["modelValue"]),Pe])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",ye,[Object(c["createVNode"])(o,{to:"#Async",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("6、async ")]),Object(c["createElementVNode"])("section",null,[xe,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(ut),"onUpdate:modelValue":t[22]||(t[22]=e=>Object(c["isRef"])(ut)?ut.value=e:null)},null,8,["modelValue"]),we,Object(c["createElementVNode"])("div",null,[Te,ge,Re,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(mt),"onUpdate:modelValue":t[23]||(t[23]=e=>Object(c["isRef"])(mt)?mt.value=e:null)},null,8,["modelValue"]),Se,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(jt),"onUpdate:modelValue":t[24]||(t[24]=e=>Object(c["isRef"])(jt)?jt.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[ke,Fe,Object(c["createElementVNode"])("div",null,[Ce,Object(c["createElementVNode"])("section",null,[_e,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(bt),"onUpdate:modelValue":t[25]||(t[25]=e=>Object(c["isRef"])(bt)?bt.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Ue,Object(c["createElementVNode"])("section",null,[Ae,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(Vt),"onUpdate:modelValue":t[26]||(t[26]=e=>Object(c["isRef"])(Vt)?Vt.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Be,Object(c["createElementVNode"])("section",null,[Ie,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(Ot),"onUpdate:modelValue":t[27]||(t[27]=e=>Object(c["isRef"])(Ot)?Ot.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[qe,Object(c["createElementVNode"])("section",null,[Ge,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(Nt),"onUpdate:modelValue":t[28]||(t[28]=e=>Object(c["isRef"])(Nt)?Nt.value=e:null)},null,8,["modelValue"])])])])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",He,[Object(c["createVNode"])(o,{to:"#Await",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("7、await ")]),Object(c["createElementVNode"])("section",null,[De,Object(c["createElementVNode"])("div",null,[Me,Je,Object(c["createElementVNode"])("div",null,[Le,Object(c["createElementVNode"])("section",null,[We,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(pt),"onUpdate:modelValue":t[29]||(t[29]=e=>Object(c["isRef"])(pt)?pt.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[ze,Object(c["createElementVNode"])("section",null,[$e,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(ht),"onUpdate:modelValue":t[30]||(t[30]=e=>Object(c["isRef"])(ht)?ht.value=e:null)},null,8,["modelValue"])])])]),Object(c["createElementVNode"])("div",null,[Ye,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(vt),"onUpdate:modelValue":t[31]||(t[31]=e=>Object(c["isRef"])(vt)?vt.value=e:null)},null,8,["modelValue"]),Ze,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(ft),"onUpdate:modelValue":t[32]||(t[32]=e=>Object(c["isRef"])(ft)?ft.value=e:null)},null,8,["modelValue"]),Ke])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",Qe,[Object(c["createVNode"])(o,{to:"#AsyncAwaitErrorCatch",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("8、async和await错误处理 ")]),Object(c["createElementVNode"])("section",null,[Object(c["createElementVNode"])("div",null,[Xe,et,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(Et),"onUpdate:modelValue":t[33]||(t[33]=e=>Object(c["isRef"])(Et)?Et.value=e:null)},null,8,["modelValue"]),tt,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(Pt),"onUpdate:modelValue":t[34]||(t[34]=e=>Object(c["isRef"])(Pt)?Pt.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[ot,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(yt),"onUpdate:modelValue":t[35]||(t[35]=e=>Object(c["isRef"])(yt)?yt.value=e:null)},null,8,["modelValue"]),ct,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(xt),"onUpdate:modelValue":t[36]||(t[36]=e=>Object(c["isRef"])(xt)?xt.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[nt,lt,Object(c["createVNode"])(Tt,{modelValue:Object(c["unref"])(wt),"onUpdate:modelValue":t[37]||(t[37]=e=>Object(c["isRef"])(wt)?wt.value=e:null)},null,8,["modelValue"])])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",rt,[Object(c["createVNode"])(o,{to:"#AsyncAwaitLoop",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("9、async和await循环中使用 ")]),at])])}}});const st=dt;var it=st;const ut={id:"Generator"},mt=Object(c["createElementVNode"])("div",{class:"brief-introduction"},[Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("迭代器的英文"),Object(c["createElementVNode"])("code",null,"iteration"),Object(c["createTextVNode"])("源自拉丁文"),Object(c["createElementVNode"])("code",null,"itero"),Object(c["createTextVNode"])("，意思是“重复”或“再来”。在软件开发领域 ，“迭代”的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。"),Object(c["createElementVNode"])("code",null,"ECMAScript 6"),Object(c["createTextVNode"])(" 规范新增了两个高级特性：迭代器和生成器。使用这两个特性，能够更清晰、高效、方便的实现迭代。 ")]),Object(c["createElementVNode"])("p",{class:"right"},"摘自《高级JavaScript程序设计 第四版》")],-1),jt={id:"Iterator"},bt=Object(c["createStaticVNode"])("<p>迭代器<code>Iterator</code>是ES6引入的一种新的遍历机制，一中接口，本质是一个指针对象，供 <code>for...of</code>消费。 </p><div><ul><li>迭代器也有<code>next()</code>方法，返回对象<code>{ value:&quot;&quot;, done:false }</code> ，第一次调用时返回第一个值 </li><li> 迭代器部署在<code>Symbol.iterator</code>属性上 </li><li><code>Array、Map、Set、String、Function的arguments</code>对象等具有原生 <code>Iterator</code>接口 </li><li><code>Number/Object</code>没有实现迭代工厂函数</li></ul></div>",2),Vt=Object(c["createElementVNode"])("p",null," 每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的示例相互之间没有联系，只会独立地遍历 可迭代对象。请看看下述代码： ",-1),Ot=Object(c["createElementVNode"])("p",null," 迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅而仅仅是使用【游标】来记录遍历可迭代对象的历程。 如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化。请看看下述代码： ",-1),Nt=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("span",{class:"red"},"【注意】"),Object(c["createTextVNode"])(" 迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。")],-1),pt={id:"CustomIterator"},ht=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])(" 与"),Object(c["createElementVNode"])("code",null,"Interable"),Object(c["createTextVNode"])("接口类似，任何实现"),Object(c["createElementVNode"])("code",null,"Iterator"),Object(c["createTextVNode"])("接口的对象都可以作为迭代器使用。 下面这个例子中"),Object(c["createElementVNode"])("code",null,"Counter"),Object(c["createTextVNode"])("类只能被一定的次数。 ")],-1),vt=Object(c["createElementVNode"])("p",null,"为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此可以把计数器 放到闭包里，然后通过闭包返回迭代器。 ",-1),ft={id:"SubGenerator"},Et={id:"AutoGenerator"};var Pt=Object(c["defineComponent"])({__name:"generator",setup(e){const t=Object(c["getCurrentInstance"])(),{$builtIn:o}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,n=o("\nlet num = 1;\nlet obj = {};\n\nconsole.log(num[Symbol.iterator]); // undefined\nconsole.log(obj[Symbol.iterator]); // undefined\n\n\n\nlet arr = [\"own\", \"two\", \"three\"];\n\nlet iter = arr[Symbol.iterator]();\nconsole.log(iter.next()); // {value: 'own', done: false}\nconsole.log(iter.next()); // {value: 'two', done: false}\nconsole.log(iter.next()); // {value: 'three', done: false}\nconsole.log(iter.next()); // {value: undefined, done: true}\n\nfor (let key in arr) {\n  console.log(key); // 0,1,2 去键名\n}\nfor (let value of arr) {\n  console.log(value); // 取值\n}\n"),l=o("\nlet arr = [\"own\", \"two\", \"three\"];\n\nlet iter1 = arr[Symbol.iterator]();\nlet iter2 = arr[Symbol.iterator]();\n\nconsole.log(iter1.next()); //{value: 'own', done: false}\nconsole.log(iter2.next()); //{value: 'own', done: false}\nconsole.log(iter1.next()); //{value: 'two', done: false}\nconsole.log(iter2.next()); //{value: 'two', done: false}\n"),r=o("\nlet arr = [\"own\", \"two\", \"three\"];\nlet iter = arr[Symbol.iterator]();\n\nconsole.log(iter.next()); //{value: 'own', done: false}\n\n// 在 arr 中间插入值\narr.splice(1, 0, \"four\");\nconsole.log(iter.next()); //{value: 'four', done: false}\nconsole.log(iter.next()); //{value: 'two', done: false}\nconsole.log(iter.next()); //{value: 'three', done: false}\nconsole.log(iter.next()); //{value: undefined, done: true}\n"),a=o("\nclass Counter {\n  // counter 的实例应该被迭代 limit 次\n  constructor(limit) {\n    this.limit = limit;\n  }\n\n  [Symbol.iterator]() {\n    let count = 1;\n    let limit = this.limit;\n\n    return {\n      next() {\n        if (count <= limit) {\n          return { done: false, value: count++ };\n        } else {\n          return { done: true, value: undefined };\n        }\n      },\n    };\n  }\n}\n\nlet counter = new Counter(3);\n\nfor (let v of counter) {\n  console.log(v);\n}\n\nfor (let v of counter) {\n  console.log(v);\n}\n");return(e,t)=>{const o=Object(c["resolveComponent"])("RouterLink"),d=Object(c["resolveComponent"])("WebPrismEditor");return Object(c["openBlock"])(),Object(c["createElementBlock"])("div",null,[Object(c["createElementVNode"])("h3",ut,[Object(c["createVNode"])(o,{to:"#Generator",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 3、Generator ")]),mt,Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",jt,[Object(c["createVNode"])(o,{to:"#Iterator",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、迭代器Iterator ")]),Object(c["createElementVNode"])("section",null,[Object(c["createElementVNode"])("div",null,[bt,Object(c["createVNode"])(d,{modelValue:Object(c["unref"])(n),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(c["isRef"])(n)?n.value=e:null)},null,8,["modelValue"])]),Object(c["createElementVNode"])("div",null,[Vt,Object(c["createVNode"])(d,{modelValue:Object(c["unref"])(l),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(c["isRef"])(l)?l.value=e:null)},null,8,["modelValue"]),Ot,Object(c["createVNode"])(d,{modelValue:Object(c["unref"])(r),"onUpdate:modelValue":t[2]||(t[2]=e=>Object(c["isRef"])(r)?r.value=e:null)},null,8,["modelValue"]),Nt])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",pt,[Object(c["createVNode"])(o,{to:"#CustomIterator",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 2、自定义迭代器Iterator ")]),Object(c["createElementVNode"])("section",null,[ht,vt,Object(c["createVNode"])(d,{modelValue:Object(c["unref"])(a),"onUpdate:modelValue":t[3]||(t[3]=e=>Object(c["isRef"])(a)?a.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("h4",ft,[Object(c["createVNode"])(o,{to:"#SubGenerator",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 3、生成器Generator ")]),Object(c["createElementVNode"])("h4",Et,[Object(c["createVNode"])(o,{to:"#AutoGenerator",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 4、Generator自动执行 ")])])}}});const yt=Pt;var xt=yt;const wt={class:"main"},Tt=Object(c["createElementVNode"])("h2",{id:"javascript"},"javascript基础问题梳理",-1),gt=Object(c["createElementVNode"])("h3",{id:"DeepClone"},"4、深拷贝和浅拷贝",-1);var Rt=Object(c["defineComponent"])({__name:"index",setup(e){const t=Object(c["getCurrentInstance"])(),{$builtIn:o}=null===t||void 0===t?void 0:t.appContext.config.globalProperties;return(e,t)=>(Object(c["openBlock"])(),Object(c["createElementBlock"])("div",wt,[Tt,Object(c["createVNode"])(E),Object(c["createVNode"])(it),Object(c["createVNode"])(xt),gt]))}});const St=Rt;t["default"]=St}}]);