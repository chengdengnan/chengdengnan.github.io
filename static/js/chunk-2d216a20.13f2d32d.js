(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d216a20"],{c2fa:function(e,t,n){"use strict";n.r(t);var c=n("7a23");const o={id:"This"},l=Object(c["createStaticVNode"])('<div style="padding-top:20px;margin-left:10px;"><p><a target="_blank" rel="help" href="http://liubin.org/promises-book/" class="a-navigation">参考资料: MDN中this解析</a></p><div class="lineH-p-40" style="margin-left:30px;"><p> 1. 对于直接调用的函数来说，不管函数被放在了什么地方，<code>this</code>都是<code>window</code>; </p><p> 2. 对于被别人调用的函数来说，被谁【点】出来的，<code>this</code>就是谁; </p><p> 3. <code>call、apply</code>时，<code>this</code>是第一个参数。<code>bind</code>要优与 <code>call/apply</code>，<code>call</code>参数多，<code>apply</code>参数少; </p><p> 4. 在构造函数中，类中(函数体中)出现的<code>this.xxx = xxx</code>中的<code>this</code> 是当前类的一个实例; </p><p> 5. 箭头函数没有自己的<code>this</code>,需要看其外层是否有函数，如果有：外层函数的<code>this</code> 就是内部箭头函数的<code>this</code>，如果没有，<code>this</code>则是<code>window</code>; </p></div></div>',1),a={id:"GlobalFunction"},d=Object(c["createElementVNode"])("p",null,[Object(c["createElementVNode"])("code",null,"this"),Object(c["createTextVNode"])("指向全局对象"),Object(c["createElementVNode"])("code",null,"window"),Object(c["createTextVNode"])("，"),Object(c["createElementVNode"])("span",{class:"red"},"注意严格模式下"),Object(c["createTextVNode"])("， "),Object(c["createElementVNode"])("code",null,"this"),Object(c["createTextVNode"])("为"),Object(c["createElementVNode"])("code",null,"undefined"),Object(c["createTextVNode"])("; ")],-1),r={id:"ObjectMethod"},i=Object(c["createElementVNode"])("p",null,"this指向调用该方法的对象",-1),s={id:"Constructor"},b=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("this指向 "),Object(c["createElementVNode"])("span",{class:"red"},"new 关键字 "),Object(c["createTextVNode"])("创建出的实例")],-1),u={id:"SetTimeout"},j=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("定时器 setTimeout 或 setInterval，以及回调函数或匿名函数自调用，"),Object(c["createElementVNode"])("span",{class:"red"},"this指向全局对象window")],-1),O={id:"EventFunction"},V=Object(c["createElementVNode"])("p",null,"元素绑定事件，事件触发后执行函数，this指向的是当前元素",-1),m={id:"ArrowFunction"},N=Object(c["createElementVNode"])("p",null,"this指向箭头函数定义时所处的对象",-1),h={id:"CallApplyBind"},f=Object(c["createStaticVNode"])('<section><ul type="square"><li> call和apply：<span class="red">改变 this 指向后</span>执行函数。 <ul style="margin-left:1rem;" type="circle"><li>call(thisScope,arg1,arg2,arg...);<span class="red"> 多个参数，第一个参数为null、undefined时，默认指向Window</span></li><li>apply(thisScope,[arg1,arg2,arg...]);<span class="red"> 两个参数</span></li></ul></li></ul><ul type="square"><li>bind: 改变 this 指向后，返回函数，不执行。</li><p>bind(thisScopr,arg1,arg2,arg...) 多个参数</p></ul></section>',1),p=Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("div",{class:"c-h5"},"apply的使用方法(函数劫持、对象复制)"),Object(c["createElementVNode"])("div",{class:"indent"},[Object(c["createElementVNode"])("span",null,[Object(c["createTextVNode"])("可以看到 Student 不具备任何方法，但是在 "),Object(c["createElementVNode"])("span",{class:"red"},"Person.apply(this,arguments)"),Object(c["createTextVNode"])("之后，他就具备了Person类的方法及属性")])]),Object(c["createElementVNode"])("div",null,"由此得出结论： Function.apply() 能“劫持”另外一个对象， 继承另外一个对象的属性")],-1);var x=Object(c["defineComponent"])({__name:"this",setup(e){const t=Object(c["getCurrentInstance"])(),{$builtIn:n}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,x=n("\n// 'not strict' 【window】\nconsole.log(this);\nfunction funs(){\n    console.log(this); \n};\nfuns();\n\n// 'use strict' 【undefined】\nfunction stractDemo(){\n    'use strict'\n    console.log(this);\n};\nstractDemo();\n"),v=n("\nlet name = 'Global Barry';\nlet obj = {\n    name: 'Obj Barry',\n    getName: function(){\n        console.log(this.name)\n    },\n};\nobj.getName(); // 'Obj Barry'\n\nlet funs = obj.getName;\nfuns(); // 'Global Barry'\n"),E=n('\nfunction Barry(){\n    this.name = "Fashion pro Barry";\n    console.log(this);\n}\n\nlet n = new Barry();\nconsole.log(n)\n'),g=n('\n// setTimeout\nsetTimeout(function () {\n    console.log(this)\n}, 0)\n\nvar name = "my name is window"; // 注意var 和 const 输出是不一样的\nvar obj = {\n    name: "my name is obj",\n    funs: function () {\n        let timer = null;\n        clearInterval(timer);\n        timer = setInterval(function () {\n            console.log(this.name); // "my name is window"\n        }, 100);\n    },\n};\nobj.funs();\n\n\n// 回调函数\nvar o = {\n    age: 18,\n    say: function () {\n        function callback() {\n            return this.age;\n        }\n        func(callback);\n    },\n};\nfunction func(callback) {\n    var name = "Fashion Barry";\n    console.log(name, " is", callback() + " years"); \n}\no.say(); // Fashion Barry  is undefined years\n/**\n * 【解析】：\n * 函数内部的【this】指向于此函数的调用者（拥有者）\n * 但在上面这个例子中，为什么会输出unidentified\n * 虽然【callback】定义在对象【o】的【say】方法中，但实际上由于【callback】是在【func】函数中被普通调用的\n * 那么【func】中的【callback】的调用对象我们可以理解为【window】对象\n * 当使用一个对象未定义的属性时不会报错，会返回undefined，而直接使用一个未定义的变量便会报错\n*/\n\n'),w=n('\n<button id="btn">click me</button>\n\nwindow.onload = function () {\n    var btn = document.getElementById("btn");\n    btn.onclick = function () {\n        console.log(this);\n    };\n};\n'),T=n('\nvar name = "my name is window";\nvar obj = {\n    name: "my name is obj",\n    func: function () {\n        return (() => {\n            console.log(this.name); // my name is obj\n        })();\n    },\n};\nobj.func()\n'),y=n('\n// 对象方法:this指向方法前的对象\nvar person = {\n  name: "dog",\n  say: function (language) {\n    console.log(this.name + " say " + language);\n  },\n};\nperson.say("Hello world!");\n\n//call  改变this指向，传入多个参数\nvar name = "duck";\nperson.say.call(window, "Helo Window!");\n\n//apply 改变this指向，两个参数\n// person.say.apply(this, "Hello Apply!"); // 会报错TypeError: CreateListFromArrayLike called on non-object\n\nperson.say.apply(window, { name: "Hello Apply!" }); // nduck say undefined\n// apply 的第二个参数必须为数组\nperson.say.apply(this, ["Hello Apply!"]); // duck say Hello Apply\n\nvar arr = [1, 2, 3, 4];\nMath.max.apply(null, arr); //4, null表示不改变this指向\n\n// bind:改变this指向，不立即调用，而是返回该函数\nfunction multiply(x, y, z) {\n  return x * y * z;\n}\n\nvar double = multiply.bind(null, 2);\nconsole.log(double(3, 4)); // 24\n\nvar person1 = {\n  name: "dog",\n  sayHello: function () {\n    setTimeout(\n      function () {\n        console.log(this.name + " Say Hello!");\n      }.bind(this),\n      1000\n    );\n  },\n};\n\nperson1.sayHello(); //dog Say Hello!\n\n'),k=n('\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayHello = function () {\n    console.log(this.name + " Say hello!");\n  };\n}\n\nfunction Student(name, age, grade) {\n  Person.apply(this, arguments);\n  this.grade = grade;\n}\n\nvar s = new Student("Barry", 18, "middle school");\nconsole.log(s.name); // Barry\nconsole.log(s.age); // 18\nconsole.log(s.grade); //middle school\ns.sayHello(); // Barry Say hello!\n'),C=n("\n// 面试题解析\nvar x = 20;\nvar a = {\n  x: 15,\n  fn: function () {\n    var x = 30;\n    return function () {\n      return this.x;\n    };\n  },\n};\n\nconsole.log(a.fn()); // Function ƒ(){return this.x}\nconsole.log((a.fn())()); // 20 a.fn()返回的是一个函数，()()这是自执行表达式。this -> window\nconsole.log(a.fn()()); // 20 a.fn()相当于在全局定义了一个函数，然后再自己调用执行。this -> window\nconsole.log(a.fn()() == (a.fn())()); //true\nconsole.log(a.fn().call(this)); // 20 这段代码在全局环境中执行，this -> window\nconsole.log(a.fn().call(a)); // 15, 更改this指向为 a，a的x为15\n\n");return(e,t)=>{const n=Object(c["resolveComponent"])("RouterLink"),B=Object(c["resolveComponent"])("WebPrismEditor");return Object(c["openBlock"])(),Object(c["createElementBlock"])("div",null,[Object(c["createElementVNode"])("h3",o,[Object(c["createVNode"])(n,{to:"#This",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、This指向 ")]),l,Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",a,[Object(c["createVNode"])(n,{to:"#GlobalFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、全局函数 ")]),Object(c["createElementVNode"])("section",null,[d,Object(c["createVNode"])(B,{modelValue:Object(c["unref"])(x),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(c["isRef"])(x)?x.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",r,[Object(c["createVNode"])(n,{to:"#ObjectMethod",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、对象方法 ")]),Object(c["createElementVNode"])("section",null,[i,Object(c["createVNode"])(B,{modelValue:Object(c["unref"])(v),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(c["isRef"])(v)?v.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",s,[Object(c["createVNode"])(n,{to:"#Constructor",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、构造函数 ")]),Object(c["createElementVNode"])("section",null,[b,Object(c["createVNode"])(B,{modelValue:Object(c["unref"])(E),"onUpdate:modelValue":t[2]||(t[2]=e=>Object(c["isRef"])(E)?E.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",u,[Object(c["createVNode"])(n,{to:"#SetTimeout",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、定时器、回调函数 ")]),Object(c["createElementVNode"])("section",null,[j,Object(c["createVNode"])(B,{modelValue:Object(c["unref"])(g),"onUpdate:modelValue":t[3]||(t[3]=e=>Object(c["isRef"])(g)?g.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",O,[Object(c["createVNode"])(n,{to:"#EventFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、事件函数 ")]),Object(c["createElementVNode"])("section",null,[V,Object(c["createVNode"])(B,{modelValue:Object(c["unref"])(w),"onUpdate:modelValue":t[4]||(t[4]=e=>Object(c["isRef"])(w)?w.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",m,[Object(c["createVNode"])(n,{to:"#ArrowFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("6、箭头函数 ")]),Object(c["createElementVNode"])("section",null,[N,Object(c["createVNode"])(B,{modelValue:Object(c["unref"])(T),"onUpdate:modelValue":t[5]||(t[5]=e=>Object(c["isRef"])(T)?T.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",h,[Object(c["createVNode"])(n,{to:"#CallApplyBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("7、call、apply、bind ")]),Object(c["createElementVNode"])("section",null,[f,Object(c["createVNode"])(B,{modelValue:Object(c["unref"])(y),"onUpdate:modelValue":t[6]||(t[6]=e=>Object(c["isRef"])(y)?y.value=e:null)},null,8,["modelValue"]),p,Object(c["createVNode"])(B,{modelValue:Object(c["unref"])(k),"onUpdate:modelValue":t[7]||(t[7]=e=>Object(c["isRef"])(k)?k.value=e:null)},null,8,["modelValue"]),Object(c["createVNode"])(B,{modelValue:Object(c["unref"])(C),"onUpdate:modelValue":t[8]||(t[8]=e=>Object(c["isRef"])(C)?C.value=e:null)},null,8,["modelValue"])])])])}}});const v=x;var E=v;const g={id:"ThisBind"},w={id:"DefaultBind"},T=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("非严格模式下，默认绑定指向全局( "),Object(c["createElementVNode"])("code",null,"node"),Object(c["createTextVNode"])("中是 "),Object(c["createElementVNode"])("code",null,"global"),Object(c["createTextVNode"])(" )")],-1),y={id:"ImplicitBind"},k=Object(c["createElementVNode"])("p",null,[Object(c["createTextVNode"])("隐式绑定的"),Object(c["createElementVNode"])("code",null,"this"),Object(c["createTextVNode"])("指的是调用堆栈的【上一级】("),Object(c["createElementVNode"])("code",null,"."),Object(c["createTextVNode"])("前的哪一个)")],-1),C={id:"DisplayBind"},B={id:"NewObject"},_={id:"ArrowFunction"},S={id:"ThisPriority"};var I=Object(c["defineComponent"])({__name:"thisBind",setup(e){const t=Object(c["getCurrentInstance"])(),{$builtIn:n}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,o=n("\n// 1. 非严格模式\nfunction myFunc() {\n  console.log(this);\n}\n\nmyFunc(); // window\n\n// 2. 严格模式\nfunction myFunc2() {\n  \"use strict\";\n  console.log(this);\n}\nmyFunc2(); // undefined\n\n// 面试题1\nvar a = 1;\nfunction fn() {\n  var a = 2;\n  console.log(this.a); // console what ?\n}\nfn(); // 1\n\n// 面试题2\nlet a = 1; //let定义自己的作用域，不挂载至window\nfunction fn2() {\n  var a = 2;\n  console.log(this.a);\n}\nfn2(); //SyntaxError: Identifier 'a' has already been declared\n\n// 面试题3\nvar b = 1;\nfunction fn3(){\n  var b = 2;\n  function fn4(){\n    console.log(this.b);\n  }\n  fn4()\n}\nfn3(); // 1\n\n// 面试题4\nconst obj = {\n  a: 1,\n  fn: function () {\n    console.log(this.a);\n  },\n};\n\nobj.fn(); // console what ? 1 obj.fn()this指向的是obj\nconst f = obj.fn; // 当赋值给时，this丢失\nf(); // undefined\n"),l=n('\nfunction fn() {\n  console.log(this.a);\n}\nconst obj = {\n  a: 1,\n};\nobj.fn = fn;\nobj.fn(); // 1\n\nfunction fn2() {\n  console.log(this.a);\n}\nconst obj1 = {\n  a: 1,\n  fn2,\n};\nconst obj2 = {\n  a: 2,\n  obj1,\n};\nobj2.obj1.fn2(); // 1\n\n// 面试题：隐式绑定失败场景\n// 1. 函数赋值\nconst obj1 = {\n  a: 1,\n  fn: function () {\n    console.log(this.a);\n  },\n};\nconst fn1 = obj1.fn; //将引用给了 fn1，等同于 fn1 = function fn1() { console.log(this.a) }\nfn1(); // undefined\n\n// 2. setTimeout\nsetTimeout(obj1.fn, 1000); // undefined 这里执行的环境同样是全局\n\n// 3. 将函数作为参数传递\nfunction run(fn) {\n  console.log(fn === obj1.fn);\n  fn();\n}\nrun(obj1.fn); //undefined，传进去的是一个引用\n\n//4、一般匿名函数也是会指向全局的\nvar name = "The Window";\nvar obj = {\n  name: "My obj",\n  getName: function () {\n    return function () {\n      // 这是一个匿名函数\n      console.log(this.name);\n    };\n  },\n};\nobj.getName()()(\n  //5、IIFE\n  function () {\n    var a = 1;\n    console.log(this.a);\n  }\n)(); //undefined\n');return(e,t)=>{const n=Object(c["resolveComponent"])("RouterLink"),a=Object(c["resolveComponent"])("WebPrismEditor");return Object(c["openBlock"])(),Object(c["createElementBlock"])(c["Fragment"],null,[Object(c["createElementVNode"])("h3",g,[Object(c["createVNode"])(n,{to:"#ThisBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、This绑定 ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",w,[Object(c["createVNode"])(n,{to:"#DefaultBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、默认绑定(函数直接调用) ")]),Object(c["createElementVNode"])("section",null,[T,Object(c["createVNode"])(a,{modelValue:Object(c["unref"])(o),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(c["isRef"])(o)?o.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",y,[Object(c["createVNode"])(n,{to:"#ImplicitBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、隐式绑定(属性访问调用，函数被别人调用) ")]),Object(c["createElementVNode"])("section",null,[k,Object(c["createVNode"])(a,{modelValue:Object(c["unref"])(l),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(c["isRef"])(l)?l.value=e:null)},null,8,["modelValue"])])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",C,[Object(c["createVNode"])(n,{to:"#DisplayBind",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、显示绑定(call/apply/bind) ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",B,[Object(c["createVNode"])(n,{to:"#NewObject",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、new创建对象 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",_,[Object(c["createVNode"])(n,{to:"#ArrowFunction",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、箭头函数 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",S,[Object(c["createVNode"])(n,{to:"#ThisPriority",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("6、优先级 ")])])],64)}}});const F=I;var A=F;const R={id:"ActionScope"},H={id:"DataStorage"},P={id:"ExcuteContext"},D={id:"ExcuteContextStack"},U={id:"ActionScopeChain"},L={id:"ActionScopeChainGrow"};function G(e,t){const n=Object(c["resolveComponent"])("RouterLink");return Object(c["openBlock"])(),Object(c["createElementBlock"])(c["Fragment"],null,[Object(c["createElementVNode"])("h3",R,[Object(c["createVNode"])(n,{to:"#ActionScope",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、作用域 ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",H,[Object(c["createVNode"])(n,{to:"#DataStorage",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、数据存储 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",P,[Object(c["createVNode"])(n,{to:"#ExcuteContext",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、执行上下文 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",D,[Object(c["createVNode"])(n,{to:"#ExcuteContextStack",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、执行上下文栈 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",U,[Object(c["createVNode"])(n,{to:"#ActionScopeChain",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、作用域与作用域链 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",L,[Object(c["createVNode"])(n,{to:"#ActionScopeChainGrow",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("5、作用域链增强 ")])])],64)}var M=n("6b0d"),W=n.n(M);const J={},$=W()(J,[["render",G]]);var q=$;const z={id:"DeepClone"},K=Object(c["createElementVNode"])("section",null,[Object(c["createElementVNode"])("p",null,"浅拷贝只复制一层对象的属性，而深拷贝则递归复制了所有层级。"),Object(c["createElementVNode"])("div",null,[Object(c["createTextVNode"])(" 参考资料： "),Object(c["createElementVNode"])("div",{class:"indent"},[Object(c["createElementVNode"])("a",{target:"_blank",rel:"help",href:"https://blog.csdn.net/weixin_56650035/article/details/123973205",class:"a-navigation"},"1. JS 你最少用几行代码实现深拷贝？")]),Object(c["createElementVNode"])("div",{class:"indent"},[Object(c["createElementVNode"])("a",{target:"_blank",rel:"help",href:"https://github.com/lodash/lodash/blob/master/cloneDeep.js",class:"a-navigation"},"2. Lodash源码")])])],-1);function Q(e,t){const n=Object(c["resolveComponent"])("RouterLink");return Object(c["openBlock"])(),Object(c["createElementBlock"])("div",null,[Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h3",z,[Object(c["createVNode"])(n,{to:"#DeepClone",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 4、深拷贝和浅拷贝 ")]),K])])}const X={},Y=W()(X,[["render",Q]]);var Z=Y;const ee={id:"ClosePackage"},te=Object(c["createElementVNode"])("div",null,null,-1);function ne(e,t){const n=Object(c["resolveComponent"])("RouterLink");return Object(c["openBlock"])(),Object(c["createElementBlock"])(c["Fragment"],null,[Object(c["createElementVNode"])("h3",ee,[Object(c["createVNode"])(n,{to:"#ClosePackage",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、闭包 ")]),te],64)}const ce={},oe=W()(ce,[["render",ne]]);var le=oe;const ae={id:"Interview"},de={id:"InterviewThis"},re={id:"InterviewActionScopeChain"},ie={id:"InterviewOrientObject"},se={id:"InterviewIntergrated"};function be(e,t){const n=Object(c["resolveComponent"])("RouterLink");return Object(c["openBlock"])(),Object(c["createElementBlock"])(c["Fragment"],null,[Object(c["createElementVNode"])("h3",ae,[Object(c["createVNode"])(n,{to:"#Interview",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])(" 1、面试 ")]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",de,[Object(c["createVNode"])(n,{to:"#InterviewThis",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("1、this指向 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",re,[Object(c["createVNode"])(n,{to:"#InterviewActionScopeChain",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("2、作用域链 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",ie,[Object(c["createVNode"])(n,{to:"#InterviewOrientObject",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("3、面向对象 ")])]),Object(c["createElementVNode"])("div",null,[Object(c["createElementVNode"])("h4",se,[Object(c["createVNode"])(n,{to:"#InterviewIntergrated",class:"a-link"},{default:Object(c["withCtx"])(()=>[Object(c["createTextVNode"])("#")]),_:1}),Object(c["createTextVNode"])("4、综合题 ")])])],64)}const ue={},je=W()(ue,[["render",be]]);var Oe=je;const Ve={class:"main"},me=Object(c["createElementVNode"])("h2",{id:"javascript"},"javascript基础问题梳理",-1);var Ne=Object(c["defineComponent"])({__name:"index",setup(e){const t=Object(c["getCurrentInstance"])(),{$builtIn:n}=null===t||void 0===t?void 0:t.appContext.config.globalProperties;return(e,t)=>(Object(c["openBlock"])(),Object(c["createElementBlock"])("div",Ve,[me,Object(c["createVNode"])(E),Object(c["createVNode"])(A),Object(c["createVNode"])(q),Object(c["createVNode"])(Z),Object(c["createVNode"])(le),Object(c["createVNode"])(Oe)]))}});const he=Ne;t["default"]=he}}]);