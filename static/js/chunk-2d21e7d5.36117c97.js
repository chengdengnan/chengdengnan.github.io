(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d21e7d5"],{d67d:function(e,t,c){"use strict";c.r(t);var o=c("7a23");const d={id:"ReactOverview"},a={id:"ReactVersion"},l=Object(o["createElementVNode"])("div",{style:{width:"80%"}},[Object(o["createElementVNode"])("p",null,"用于构建用户界面的 JavaScript 库,是一个将数据渲染为 HTML 视图的开源 JavaScript 库。"),Object(o["createElementVNode"])("p",{class:"right"},"--- 摘自React官网")],-1),n={class:"mt-15"},i={id:"ReactEcology"},r=Object(o["createStaticVNode"])('<section><div><ul><li> 脚手架/框架 <div><ul type="cricle"><li> umi：可插拔的企业级 react 应用框架 </li><li> create react app：官方支持的创建 react 单页应用程序的方法 </li><li> Nextjs：SSR框架 </li><li> React-vr：vr框架，适用于展厅、房屋设计 </li><li> Reactxp：多端框架 </li></ul></div></li><li> 组件库 <div><ul type="cricle"><li> ant Design系列：pc、mobile，引入Ant Design设计概念 </li><li> Material-UI：实现了谷歌Material Design设计规范，世界流行界面 </li></ul></div></li><li> 工具类 <div><ul type="cricle"><li> Redux：遵循函数式编程思想的状态管理插件 </li><li> Mobx：面向对象变迁和响应式编程的状态管理插件 </li><li> Immutable-js：解决javasript Immutable Data的问题 </li></ul></div></li><li> 跨端类 <div><ul type="cricle"><li> Remax：阿里的React跨端框架，目前支持支付宝、微信、字节小程序 </li><li> Taro：类React跨端框架，支持主流小程序及React Native </li><li> React Native：js编写原生的React框架 </li></ul></div></li><li> 其他 <div><ul type="cricle"><li> react-window和react-virtualized：虚拟滚动库，提供可服用组件， 用于展示列表、网络和表格数据。 </li></ul></div></li></ul></div></section>',1);var O=Object(o["defineComponent"])({__name:"overview",setup(e){const t=Object(o["getCurrentInstance"])(),{$builtIn:c}=null===t||void 0===t?void 0:t.appContext.config.globalProperties;return(e,t)=>{const c=Object(o["resolveComponent"])("RouterLink"),O=Object(o["resolveComponent"])("el-timeline-item"),s=Object(o["resolveComponent"])("el-timeline");return Object(o["openBlock"])(),Object(o["createElementBlock"])(o["Fragment"],null,[Object(o["createElementVNode"])("h3",d,[Object(o["createVNode"])(c,{to:"#ReactOverview",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 1、综述 ")]),Object(o["createElementVNode"])("div",null,[Object(o["createElementVNode"])("h4",a,[Object(o["createVNode"])(c,{to:"#ReactVersion",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])("1、react 简史及版本 ")]),Object(o["createElementVNode"])("section",null,[l,Object(o["createElementVNode"])("p",n,[Object(o["createVNode"])(s,null,{default:Object(o["withCtx"])(()=>[Object(o["createVNode"])(O,{timestamp:"2011",placement:"top"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" 起初由 Facebook 软件工程师 Jordan Wakke 创建。于 2011 年部署于 Facebook 的 newsfeed。 ")]),_:1}),Object(o["createVNode"])(O,{timestamp:"2012",placement:"top"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" 随后在 2012 年部署于 Instagram ")]),_:1}),Object(o["createVNode"])(O,{timestamp:"2013",placement:"top"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" 然后于 2013 年 5 月宣布开源 ")]),_:1}),Object(o["createVNode"])(O,{timestamp:"2015",placement:"top"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" 2015年发布v0.14.0版本：拆分react package into two，react and react-dom ")]),_:1}),Object(o["createVNode"])(O,{timestamp:"2016",placement:"top"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" 2016年发布v15.0版本：虚拟dom的diff操作同步执行 ")]),_:1}),Object(o["createVNode"])(O,{timestamp:"2017",placement:"top"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" 2017年发布React v16.0版本：使用fiber架构(分片)，小于ie11需使用polyfill ")]),_:1}),Object(o["createVNode"])(O,{timestamp:"2017-react v16.2.0",placement:"top"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" react v16.2.0（2017年）：增加Fragment组件 ")]),_:1}),Object(o["createVNode"])(O,{timestamp:"2018-react V16.3.0",placement:"top"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" react V16.3.0（2018年）：增加主要的api，React.createRef()、React.forwardRef() ")]),_:1}),Object(o["createVNode"])(O,{timestamp:"2018-V16.6.0",placement:"top"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" react V16.6.0（2018年）：增加主要的api，React.memo()、React.lazy() ")]),_:1}),Object(o["createVNode"])(O,{timestamp:"2018-V16.8.0",placement:"top"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" react V16.8.0（2019年）：增加React Hooks，用来解决状态逻辑复用问题，且不会产生 JSX 嵌套地狱 ")]),_:1}),Object(o["createVNode"])(O,{timestamp:"2020-V17.0.0",placement:"top"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" 2020年发布React v17.0版本：引入渐进式升级 ")]),_:1}),Object(o["createVNode"])(O,{timestamp:"2022-V18.0.0",placement:"top"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" 2022年发布React v18.0版本：引入useId 、useTransition 、useDeferredValue 、useSyncExternalStore 、useInsertionEffect 等 ")]),_:1})]),_:1})])])]),Object(o["createElementVNode"])("div",null,[Object(o["createElementVNode"])("h4",i,[Object(o["createVNode"])(c,{to:"#ReactEcology",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])("2、react 生态 ")]),r])],64)}}});const s=O;var b=s;const u={id:"ReactVirtualDOM"},j={id:"CreateVirtualDOM"},p=Object(o["createElementVNode"])("p",{class:"c-h6"},"第一种：JS 的方式创建虚拟DOM(几乎不用,了解即可)",-1),V=Object(o["createElementVNode"])("p",{class:"c-h6"},"第二种：JSX 的方式创建虚拟DOM",-1),m=Object(o["createElementVNode"])("p",null,[Object(o["createElementVNode"])("code",null,"JSX"),Object(o["createTextVNode"])("可以使我们更便捷的去创建虚拟DOM，也可以说"),Object(o["createElementVNode"])("code",null,"JSX"),Object(o["createTextVNode"])("创建虚拟DOM是原生 "),Object(o["createElementVNode"])("code",null,"JS"),Object(o["createTextVNode"])("创建虚拟"),Object(o["createElementVNode"])("code",null,"DOM"),Object(o["createTextVNode"])("的语法糖。 ")],-1),N={id:"VirtualDOMUnderstand"},v=Object(o["createStaticVNode"])('<section><div><p class="indent"> 从本质上说，<code>Virtual DOM</code>是一个<code>JavaScript</code>对象，通过对象的方式来表现 <code>DOM</code>结构。将页面的状态抽象为<code>JS</code>对象的形式，配合不同的渲染工具，是跨平台渲染 成为可能。通过事务处理机制，将多次<code>DOM</code>修改的结果一次性的更新到页面上，从而有效的减少页面 渲染的次数，减少修改<code>DOM</code>的重排重绘次数，提高渲染性能。 </p><p class="indent"> 虚拟<code>DOM</code>就是对<code>DOM</code>的抽象，这个对象是更加轻量级的对<code>DOM</code>的描述。 它设计的最初目的，就是更好的跨平台，比如<code>node.js</code>就没有<code>DOM</code>。如果想实现 <code>SSR</code>，那么一个方式就是借助虚拟<code>DOM</code>，因为虚拟<code>DOM</code>本身是<code>js</code> 对象。在代码渲染到页面之前，<code>Vue</code>或<code>React</code>会把代码转换成一个对象（虚拟DOM）。以 对象的形式来描述真实的<code>DOM</code>结构，最终渲染到页面。在每次数据发生变化前，虚拟<code>DOM</code>都 会缓存一份，变化之时，现在的虚拟<code>DOM</code>会与缓存的虚拟<code>DOM</code>进行比较。在<code>Vue</code> 或者<code>React</code>内部封装了<code>Diff</code>算法，通过这个算法来进行比较，渲染时只针对有变化的 <code>DOM</code>进行修改，原先没有发生改变的通过原先的数据进行渲染。 </p><p class="indent"> 另外现在前端框架的一个基本要求就是无需手动操作<code>DOM</code>，一方面是因为手动操作<code>DOM</code>无法 保证性能，多人协同的项目中如果<code>review</code>不严格，可能会有开发者写出性能较低的代码，另一方面 更重要的是省略手动<code>DOM</code>操作可以大大提高效率。 </p></div><div><p class="c-h6"> 为什么要用 Virtual DOM： </p><div><p class="s-indent c-h6">(1) 保证性能下限，在不进行手动优化的情况下，提供过得去的性能</p><p> 下面对比一下修改<code>DOM</code>时真实<code>DOM</code>操作和<code>Virtual DOM</code>操作的 过程，来看一下它们重排重绘的性能消耗： </p><div><ul><li><span class="c-h7">真实DOM：</span> 生成 <code>HTML</code> 字符串 -&gt; 重建所有的 <code>DOM</code> 元素 </li><li><span class="c-h7">Virtual DOM：</span> 生成<code>vNode</code> -&gt; <code>DOM diff</code> -&gt; 必要的<code>DOM</code>更新 </li></ul></div></div><div><p class="s-indent c-h6"> (2) 跨平台 </p><p><code>Virtual DOM</code>本质上是<code>JavaScript</code>的对象，它可以很方便的跨平台操作， 比如服务器端渲染、uniapp等。 </p></div></div></section>',1),x={id:"ReactDiff"},D=Object(o["createStaticVNode"])('<section><p> 实际上，<code>diff</code> 算法探讨的就是虚拟 <code>DOM</code> 树发生变化后，生成 <code>DOM</code> 树更新补丁的方式。它通过对比新旧两株虚拟 <code>DOM</code> 树的变更差异， 将更新补丁作用于真实 <code>DOM</code> ，以最小成本完成视图更新。 </p><p class="c-h7">具体流程如下：</p><div><ul><li>真实的 <code>DOM</code> 首先会映射为虚拟 <code>DOM</code></li><li> 当虚拟<code>DOM</code>发生变化后，就会根据差异计算生成生成<code>patch</code>，这个 <code>patch</code>是一个结构化数据，内容包含了增加、更新、移除。 </li><li> 根据<code>patch</code>去更新真实的<code>DOM</code>，反馈到用户界面上。 </li></ul></div><p class="c-h6">待完善,请等候.....</p></section>',1),f={id:"ReactKey"},M=Object(o["createStaticVNode"])('<section><p class="indent"><code>keys</code>是<code>React</code>用于追踪那些列表中元素被修改、被添加或者被移除的辅助标识。 在开发过程中，我们需要保证某个元素的<code>key</code>在同级元素中具有唯一性。 </p><p class="indent"> 在<code>React Diff</code>算法中<code>React</code>会借助元素的<code>key</code>值来判断该元素是新 创建的还是被移动而来的元素，从而减少不必要的元素重新渲染。此外，<code>React</code>还需要借助 <code>key</code>值来判断元素与本地状态的关联关系。 </p><p class="c-h7">注意事项：</p><div><ul><li><code>key</code>值一定要和具体的元素--对应 </li><li> 尽量不要用数组的<code>index</code>去作为<code>key</code></li><li> 不要在<code>render</code>的时候，用随机数或者其他操作给元素加上不稳定的<code>key</code>， 这样造成的性能开销比不加<code>key</code>的情况下更糟糕。 </li></ul></div></section>',1),h={id:"ActualDOM"},E=Object(o["createStaticVNode"])('<section><p class="indent"> 虚拟<code>DOM</code>相对原生的<code>DOM</code>不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 <code>DOM</code>的操作无论如何都不可能比真实的<code>DOM</code>操作更快。在首次渲染大量<code>DOM</code> 时，由于多了一层虚拟<code>DOM</code>的计算，虚拟<code>DOM</code>也会比<code>innerHTML</code>插入慢。 它能保证性能下限，在真实<code>DOM</code>操作的时候进行针对性优化时，还是更快的。所以要根据具体的场景 进行探讨，不能以偏概全。 </p><p class="indent"> 在整个<code>DOM</code>操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写的爽不爽，在于 <span class="c-h7">研发体验/研发效率</span>。虚拟<code>DOM</code>不是别的，正是前端开发们为了 更好的研发体验和研发效率而创建出来的高阶产物。虚拟<code>DOM</code>并不一定能带来更好的性能， <code>React</code>官方也从来没有把虚拟<code>DOM</code>作为性能层面的卖点对外输出过。 </p><p class="red"> 虚拟<code>DOM</code>的优越之处在于，它能够提供更爽、更高效的研发模式(也就是函数式的 UI 编程方式)的同时， 仍然保持一个还不错的性能。 </p></section>',1),R={id:"ReactDiffAndVueDiff"},C=Object(o["createStaticVNode"])('<section><p class="indent"><code>Diff</code>算法是指生成更新补丁的方式，主要应用于虚拟<code>DOM</code>树变化后，更新真实<code>DOM</code>。 所以<code>diff</code>算法一定存在这样一个过程：<span class="c-h7"> 触发更新 --&gt; 生成补丁 --&gt; 应用补丁 </span></p><p class="indent"><code>React</code>的<code>diff</code>算法，触发更新的时机主要在<code>state</code>变化与<code>hooks</code> 调用之后。此时触发虚拟<code>DOM</code>树变更差异，采用了深度优先遍历算法。但传统的的遍历方式，效率更低。 为了优化效率，采用了分治的方式。将单一节点的对比转换为了3种类型节点的对比，分别是树、组件及元素，以此提高效率。 </p><div><ul><li><span class="c-h7">树对比：</span> 由于网页视图中较少有跨层级节点移动，两株虚拟<code>DOM</code>树只对同一层级的节点进行比较。 </li><li><span class="c-h7">组件对比：</span> 如果组件是同一类型，则进行树对比，如果不是则直接放入到补丁中。 </li><li><span class="c-h7">元素对比：</span> 主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实<code>DOM</code>的裁剪操作。 </li></ul></div><p class="indent"> 以上是经典的<code>React Diff</code>算法内容。自 <code>React 16</code>起，引入了<code>Fiber</code>架构。 为了使整个更新过程可随时暂停恢复，节点和树分别采用了<code>FiberNode</code>和<code>FiberTree</code>进行了 重构。<code>FiberNode</code>使用了双链表的结构，可以直接找到兄弟节点与子节点。整个更新过程由 <code>current</code>与<code>workInProgress</code>两株树双缓冲完成。<code>workInProgress</code>更新 完成后，再通过修改<code>current</code>相关指针指向新节点。 </p><p class="indent c-h7"><code>Vue</code>的整体<code>diff</code>策略与<code>React</code>对齐，虽然缺乏时间切片能力，但这并不意味着 <code>Vue</code>的性能更差，因为在<code>Vue3</code>初期引入过后期因为收益不高移除掉了。除了高帧率动画， 在<code>Vue</code>中其他的场景几乎都可以使用防抖和节流去提高响应性能。 </p></section>',1);var w=Object(o["defineComponent"])({__name:"virtualDOM",setup(e){const t=Object(o["getCurrentInstance"])(),{$builtIn:c}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,d=c('\n<div id="container2"></div>\n\n\x3c!-- 使用 js 创建虚拟 DOM --\x3e\n// 1.create virtual DOM\nconst virtualDOM2 = React.createElement(\n  "h1",\n  {},\n  React.createElement("span", { id: "title" }, "Hello world!")\n);\n// 2.render virtual DOM\nReactDOM.render(virtualDOM2, document.getElementById("container2"));\n'),a=c('\n<div id="container"></div>\n\n\x3c!-- 使用jsx 创建虚拟 DOM ( script 需要加上 type="text/babel")--\x3e\n// 1.create virtual DOM\nconst virtualDOM = (\n  <h1>\n    <span id="title">Hello world!</span>\n  </h1>\n);\n// 2.render virtual DOM\nReactDOM.render(virtualDOM, document.getElementById("container"));\n');return(e,t)=>{const c=Object(o["resolveComponent"])("RouterLink"),l=Object(o["resolveComponent"])("WebPrismEditor");return Object(o["openBlock"])(),Object(o["createElementBlock"])(o["Fragment"],null,[Object(o["createElementVNode"])("h3",u,[Object(o["createVNode"])(c,{to:"#ReactVirtualDOM",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 2、虚拟 DOM ")]),Object(o["createElementVNode"])("div",null,[Object(o["createElementVNode"])("h4",j,[Object(o["createVNode"])(c,{to:"#CreateVirtualDOM",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 1、虚拟DOM的两种创建方式 ")]),Object(o["createElementVNode"])("section",null,[Object(o["createElementVNode"])("div",null,[p,Object(o["createVNode"])(l,{modelValue:Object(o["unref"])(d),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(o["isRef"])(d)?d.value=e:null)},null,8,["modelValue"])]),Object(o["createElementVNode"])("div",null,[V,m,Object(o["createVNode"])(l,{modelValue:Object(o["unref"])(a),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(o["isRef"])(a)?a.value=e:null)},null,8,["modelValue"])])])]),Object(o["createElementVNode"])("div",null,[Object(o["createElementVNode"])("h4",N,[Object(o["createVNode"])(c,{to:"#VirtualDOMUnderstand",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 2、对虚拟DOM的理解？虚拟DOM主要做了什么？虚拟DOM本身是什么？ ")]),v]),Object(o["createElementVNode"])("div",null,[Object(o["createElementVNode"])("h4",x,[Object(o["createVNode"])(c,{to:"#ReactDiff",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 3、React diff算法的原理是什么？ ")]),D]),Object(o["createElementVNode"])("div",null,[Object(o["createElementVNode"])("h4",f,[Object(o["createVNode"])(c,{to:"#ReactKey",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 4、React key是干嘛用的，为什么要加？key主要是解决哪一类问题的 ")]),M]),Object(o["createElementVNode"])("div",null,[Object(o["createElementVNode"])("h4",h,[Object(o["createVNode"])(c,{to:"#ActualDOM",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 5、虚拟DOM的引入与直接操作原生DOM相比，哪一个效率更高，为什么 ")]),E]),Object(o["createElementVNode"])("div",null,[Object(o["createElementVNode"])("h4",R,[Object(o["createVNode"])(c,{to:"#ReactDiffAndVueDiff",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 6、React与Vue的diff算法有何不同？ ")]),C])],64)}}});const T=w;var k=T;const _={id:"ReactGrammar"},g={id:"ReactJSX"},S=Object(o["createStaticVNode"])('<p class="c-h5">1. JSX语法规则</p><div><ul><li> 定义虚拟DOM时，不能写引号</li><li> 标签中混入Js表达式时要用{ }</li><li> 样式类名要用className</li><li> 内联样式，要用<code>双花括号</code>的形式</li><li> 只有一个根标签，所有标签必须闭合</li><li> 标签首字母： <div><ul type="cricle"><li>小写开头，则将改标签转为html中同名元素</li><li>大写开头，react 则去渲染对应组件</li></ul></div></li><li> 注释：{/* xxx */}</li><li> props默认值为true</li></ul></div>',2),y=Object(o["createStaticVNode"])('<p class="c-h5">2. 合法的JSX元素</p><div><ul><li>普通的DOM元素，如<code>div/span/p</code>等</li><li> 申明的react组件，例如通过<code>class</code>或者函数创建的<code>jsx</code>组件 ，用户定义的组件必须以大写字母开头 </li><li><code>false、null、undefined、true</code> 为合法元素，但是不会渲染 </li><li> 字符串最终会渲染一个<code>text节点</code></li><li> 数字类型，最终会渲染出来 </li></ul></div>',2),J={id:"FunctionComponent"},I={id:"ClassComponent"},F={id:"HasStateComponent"},B={id:"ControlComponent"};var U=Object(o["defineComponent"])({__name:"grammar",setup(e){const t=Object(o["getCurrentInstance"])(),{$builtIn:c}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,d=c('const arr = ["Vue", "React", "Angular"];\nconst virtualDOM = (\n  <div>\n    <h2 className="title">前端 JS 框架</h2>\n    <ul>\n      {arr.map((t, i) => {\n        return (\n          <li className="sub-title" style={{ color: "#F0F" }} key={i}>\n            {t}\n          </li>\n        );\n      })}\n    </ul>\n  </div>\n);\nReactDOM.render(virtualDOM, document.getElementById("container"));'),a=c("<div>\n    <p>{false && <p>test</p>}{/* 渲染空元素 */}</p>\n    <p>{0 && <p>true</p>}{/* 与门如果出现非布尔值，渲染与预期有出入，渲染出0 */}</p>\n    <p>{0 ? null : <p>true</p>} {/* 建议使用三目运算符 */}</p>\n</div>");return(e,t)=>{const c=Object(o["resolveComponent"])("RouterLink"),l=Object(o["resolveComponent"])("WebPrismEditor");return Object(o["openBlock"])(),Object(o["createElementBlock"])(o["Fragment"],null,[Object(o["createElementVNode"])("h3",_,[Object(o["createVNode"])(c,{to:"#ReactGrammar",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 3、React 基础 ")]),Object(o["createElementVNode"])("div",null,[Object(o["createElementVNode"])("h4",g,[Object(o["createVNode"])(c,{to:"#ReactJSX",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 1、JSX ")]),Object(o["createElementVNode"])("section",null,[Object(o["createElementVNode"])("div",null,[S,Object(o["createVNode"])(l,{modelValue:Object(o["unref"])(d),"onUpdate:modelValue":t[0]||(t[0]=e=>Object(o["isRef"])(d)?d.value=e:null)},null,8,["modelValue"])]),Object(o["createElementVNode"])("div",null,[y,Object(o["createVNode"])(l,{modelValue:Object(o["unref"])(a),"onUpdate:modelValue":t[1]||(t[1]=e=>Object(o["isRef"])(a)?a.value=e:null)},null,8,["modelValue"])])])]),Object(o["createElementVNode"])("div",null,[Object(o["createElementVNode"])("h4",J,[Object(o["createVNode"])(c,{to:"#FunctionComponent",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 2、函数式组件 ")])]),Object(o["createElementVNode"])("div",null,[Object(o["createElementVNode"])("h4",I,[Object(o["createVNode"])(c,{to:"#ClassComponent",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 3、类式组件 ")])]),Object(o["createElementVNode"])("div",null,[Object(o["createElementVNode"])("h4",F,[Object(o["createVNode"])(c,{to:"#HasStateComponent",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 4、有无状态组件 ")])]),Object(o["createElementVNode"])("div",null,[Object(o["createElementVNode"])("h4",B,[Object(o["createVNode"])(c,{to:"#ControlComponent",class:"a-link"},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])("#")]),_:1}),Object(o["createTextVNode"])(" 5、受控组件和非受控组件 ")])])],64)}}});const X=U;var H=X,P=Object(o["defineComponent"])({__name:"componentLifeCycle",setup(e){return(e,t)=>null}});const L=P;var A=L;const $={class:"main"},W=Object(o["createElementVNode"])("h2",null,"react 基础",-1),z={class:"overview"},G=Object(o["createElementVNode"])("span",{class:"serial-no"},"1.",-1),K=Object(o["createElementVNode"])("span",{class:"serial-no"},"2.",-1),q=Object(o["createElementVNode"])("span",{class:"serial-no"},"3.",-1),Q=Object(o["createElementVNode"])("span",{class:"serial-no"},"4.",-1);var Y=Object(o["defineComponent"])({__name:"index",setup(e){const t=Object(o["getCurrentInstance"])(),{$builtIn:c}=null===t||void 0===t?void 0:t.appContext.config.globalProperties,d=Object(o["ref"])("https://react.docschina.org/docs/hello-world.html"),a=Object(o["ref"])("https://www.jianshu.com/p/37d7de212df1"),l=Object(o["ref"])("https://goshacmd.com/controlled-vs-uncontrolled-inputs-react/"),n=Object(o["ref"])("https://www.jianshu.com/p/021736302706");return(e,t)=>{const c=Object(o["resolveComponent"])("navigationBlank");return Object(o["openBlock"])(),Object(o["createElementBlock"])("div",$,[W,Object(o["createElementVNode"])("div",z,[Object(o["createElementVNode"])("div",null,[G,Object(o["createVNode"])(c,{modelValue:d.value,"onUpdate:modelValue":t[0]||(t[0]=e=>d.value=e)},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" react官网资料 ")]),_:1},8,["modelValue"])]),Object(o["createElementVNode"])("div",null,[K,Object(o["createVNode"])(c,{modelValue:a.value,"onUpdate:modelValue":t[1]||(t[1]=e=>a.value=e)},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" 由浅入深快速掌握React Fiber ")]),_:1},8,["modelValue"])]),Object(o["createElementVNode"])("div",null,[q,Object(o["createVNode"])(c,{modelValue:l.value,"onUpdate:modelValue":t[2]||(t[2]=e=>l.value=e)},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" 受控组件和非受控组件 ")]),_:1},8,["modelValue"])]),Object(o["createElementVNode"])("div",null,[Q,Object(o["createVNode"])(c,{modelValue:n.value,"onUpdate:modelValue":t[3]||(t[3]=e=>n.value=e)},{default:Object(o["withCtx"])(()=>[Object(o["createTextVNode"])(" React 生命周期&执行顺序 ")]),_:1},8,["modelValue"])])]),Object(o["createVNode"])(b),Object(o["createVNode"])(k),Object(o["createVNode"])(H),Object(o["createVNode"])(A)])}}});const Z=Y;t["default"]=Z}}]);